<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2018-2019算法学习总结</title>
    <url>/2019/11/25/2018%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这里需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="15bf6a8485228a7b3056c20427bf944f610604221ec850a34603775ec795c742">7bdef58317331537365a441fd23fa32ec10b8c886ca586dab56f1001557a06c6e8918b89f32319498b7346e3cdb45245f4d53aba1eecfab11e501b554f45d9e8abbcb8f0067b1095c38317f97407a79b69ea1ca50b4c94420a9845697fb7f6b6c5ff99297c0d7f55e286166f68fb2c7c2a24785cbe5e1d5ccae9398835c7adf4c16d27d2c7a1c94bcabbf3b24d23c6971c5ee5110583195c5c20a9d830a63c51ecfda8463f5f127e3a4963126cb289e54201fb7778782980189273fac500802fe7ba297975a99bea257a2db98912992336501b4a6376f8eaf204b01ba1230e66bd652e7431d623225239809354d30aab54fa7b0a2c8f3a134f8335e4f4e839c5bd8845245c4a18063fef06e0ca8a6d5ead8957a1ce3a0f1d3e3425ca7470acca72bd4d1acc881dcc1362c9cbd2c1e265d42ac76a49254bbdf08bbdacb63cf1c15456362d3ef5bbf18d721873c315992c30ca32f88c73f88fe5b85964afb1175549a9d4d43846724bcaf9b935b36e58507c5cca660e423ac1fdec3968f072a55adb71307ec979c1b82e5217719ce4ce0a207d9a25b24948a28b13534227a68c06fafafdca7b2400ebd59ff8a248210d8536301925c433ecaa0b327770edd3b32ecd941a5501cf51ac816ce91c276e9ee5dffe423edfdf3a80a9dd18935b2832d6f46d00d2a1358ee9d247122525431f91b1124a431a2dd2009b7261515dde61ea8538c042dac417e85d7de47a3b98b1e22a541d559dc61e80fca95859a8d4a5d5b108e33a1decc112d0768c79e1a026e2c6b56a6e3d60fae9c4bdb08b7787077cfa72fcdb286039768a21f62ab64d9a34613c9d9d05a296f3825afa369d4cbbddf673578efdaae44d476fd6ee874b6968f992efd180665d3f3b4113700e204d2dc17397014d9688fc84cf92dfd0b578bc4c7bc32cfdccbd1b0a3028425cdc4499ba11305c38049491d43e39422251bc44fdf7bbc755be40149e6641a15860732dbf861255132408d0a5028716dcd619f7f9d9bc0d7b20776a51269c86490eccc226a7b99606dcc0100947ca4e9d3405ee112c9f1070b1413261d90debbdb57bb732381bb6c3cacbe1ec931be93eea3a46bfb067716a6930c7a41c4dda5614633717832ab3b9d418502df1b098cf8e27f1a45ab5f61c75a6395e352229d34166953c59c0cb2b90b50bd902f18c5fc86841d53fddba35920c79a2382fd9a9de0218ef980b90fc53abc423590a6073640e41f453ca4c92ee4a9cf52dc4f99a02c28ef6be1c00cfe0ef217d50868e69c769fdd46c6f53586970c5111b8031a476086edbb404a7834f2633115566150c5aab773a878aea97593656ab400b79e448567857423c50a880df498162e9b724527e99b091bdae889df1bff61de6205a64ffe00c8b1ecdd3996ef4ad6a8f37e61a35e0424e2460457543511c69bd92beb12e5e73b4a2eee033eff90f25e43b1a75bbc59aa7d19faf51f7c3e0728868eeda9865befe0f6749c1376ba4bb5500017a2464eb370c81653725af1f5dec8909d51a7c8db56a0cc57158560424d660678f0a4415a4e1095eb1b2aa1592e5b80b85b72402828f355a6049a00bc0c181e80507b6a640e75178ff1c7d5556908504b18ae9c0f63e2c7f7c067f755a2b52973e2e207dc833004bb42820196855cabdefd811d7c43424ebd30bd635b6f604791bf1fcf701ae90dc6d1cc878b26f2c152c116635141040e86588aca5923ec7af4a02bbb44dc3391654a0c8ac268103855082a942aac6778cc45d657fe3f6bdbb523e90969e207b0b1e2fec538c4be1d1081d158422ba0c324e2ecc8219f7c6008f34b13f0a5acaac287a4038103658b85011486722b90cf8ded7d6fe8aadcde44e050d6337912b6ab47352b2d8b833deef941ad20a53700c5b6d23667c0aed5f31863d38bb7ac518399e6415f20c37d7ddd7bdf4cf3bd6b479de42abbab67dd475323e1c43409ff21bb197afe4e16076440f06dfb18da9bd7792d6cae07855e24e473e7f10587f1c159ac27be8113cf1e142e2c2a0e00a7368c2f7bedb563f0c77cd3773b2cf1e1daf5087b41d81af4b67e164f4dcc2d969aa2990bb67afd195e71e324efe9d5e200bb0d4c6071d53cac10d38c00fbd0f94430a4b15a131ba19459252a4e90dd51dfd85591b1032380cf55aaed595e108bbe6aa2efef43e9ada96d9385d7c1b9a3d82b79c2d7ee4b9e49e32a8b24585959bc7a944c93ea1c09635c29ee25b0800450c29f2c737a3773e2e314f1b7a082451877ac242a07ac2e869cb68f67da68269e01edc7b67c2c80dc11a7890eed5afa95ad60ae0081e222982e4b463d8fcffe33e008b75cccb6ae2e69263e3c27332ed8b17adc25c665495cac33755d4756b8461fdd9511e5581ecc1770e444d3192caf8f804244124098fe67f05412ca5920ea10339ca29c7a45cce98dd2b961662c1402ec0c9e854fdaec525258d58df134bfd9c4c1b732af7ce12c1131da595f01fb0b13f0319ea8ae7dfaf7021dd63446e9ba1ffd6a2a793b10055445ab704bb279eda80b49330b085deb0aad729a60c2acb1523e326982114846375e7a597ea674b2002da28ad410ba236562d2456fac8d2c7c12138d82cb268bb93a3515164bdc91dbc913896ef5dbe803797272b2e72bf9d5ba879ab9c06259d63207786a6c55fac0b7da43ed1cccfce653305060b03018b06d57f41fd8650085223576e7a37f1bbfc5539baca77972724d6683e66f967793f09766d26d8fb7051c92efde95519ef4394206602618257b9641de806a1e080e27b25b213991d3d287a51b529c7b1eed6f65ce538fda1261ca14ce950922342e0d3c922b3312034b5cfbefc996ec5b497b409abc36c5addc2176fd921078faa5ccb97203e1a6f6eefb1bd0c6f37f340cf5075e28cb064f8f5481ebcae99e0d1f107dc26b108f50a02adfe5cab552a020165285d741c6c1f1b26074feda9fcdc6b5991cac71fcb58d7a65738b75b5fd3e95edff8052f3c7b2375a6c01fff580a798a09cf253b5390bf814d6dc8fca78483be32c245459de9ad6ba3bf02004d0386e4d924506c03f4a3ab74daeee923340ad327279470ad3cf07dea7af4c0e011e94e5070b986ac674879793dfbb0c50becd5a03c23ee6271afa44f1658b4f05bafb3a5b4e90ae8742348f2f2be2280ef4f0212750ce498dc712dee3e3f46380de45799de05f5ce85872584048bab8199fab3290aa42b8090fecfd4cddf0f0d08488cd301f37eeddcacc41708d97335e985d072b0ceb657fccc5c95dd1615d9ceb2aff61f0c4a9c3af6204fc8eb125edf1808890f2c4610aa555ce86711923df7e61d2e26fa69bc1d0dca3984a123d3873ad4d9481053819e868fb028f0d00d16af77d6e9394d5e20f4d9fda020582936f854842bfee8e0a9cd9b11a0ede659f9522b557a8caea5c285632d6d1c404bfc8a302819e44315127d6b7838cc3e9a90ef89603e0f84f7f504962c87edf785a55f78b875c23165436e3b5fbe7798bc7c297d91c1453e9c54de141391568337abee8decb6b7eaef63db165e700c06984c8fc71b394bb0772dcbd11543396bc112ff2bb86b6c833cbac59b9eb034523186b150bf1d694c397399e5b4c57326da7a7fb5508fc433de593e2947832d68ecc5989fb54676f0a00c91e5e76560400aca59feffd0c46527e7433bedf91c18e1bfd79d80e65063ee7a713ea7cea328f4d1539838fa5976418809c7c575439a580296cec4537993dcfdfea6c46157e81d3f1085bb4087fe3b5b299cd96797d0dd168f526f4e49e7c8bd1bb7851c5e8e92a107e665cedd59f750cad5bb7123f8a67d4d9e076b9845e5beb4ffa0f05c6dc903b0f793b4c66a0d74799457935b99bbb94ad472e8b135ce4058138b9eec241d5410311da44c38e8a926d53212bb4e82450c313071783aa68099506b97fad06ed57e15890a57f6ac3afeaf3536b54f89951e2345b7a00eccda3ad7c8094cac61bcd0ac46d557e19eca3dac19feae4f68b21969ba3e994fe405dfd85b570bf8c48377df5bfe5732a32b8f2595211d845e42582c3bd69ac518109ea2f0643c7c6834aa1790392e7a80f6a682835753772a343a292de44f3dc49aed98f278e50bb90802c1666b499c40d71896892cdaf51cf24f65e16b1870330f7fba9fcdc42801b8352e1171ef2fb394c13eef2024476c178646aadfae894cd7084b8c4227c396b9631298b21a4def5cf2038b3e5e5d663a9faa2e30b2824e83ed596c50623c54f2fd5fd1502f4adfc4af3f46debd2d84169e41e01f16900744c2ba789ef86af6f6d6f70d77c27f2ec8f01bd7be2bd212cb12632a515ed21eb0958dd8c6bdb6bd80e13e1aef6c3635ea7368dee6f98158b07339f9af067bd99a55e12da5e714c1b1f4ec1c8bf2eda8be34a31cf93cd136b7944253cb033ab118c853072b813152cbf3859c83c5fb3f5bc2d46f7be9d8b9039f4c520b3fe439370a18837dc83a39e2621314fff4d335d79d67bb295057b0d2dcb086c682954fb9911fa5cf86ab9d0b19612ca12f18a09709e973090da0a82743e0aa60224e600d8d</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>ACM</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2019GDCPC-赛后记录</title>
    <url>/2019/05/18/2019GDCPC%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<p>没有封面图，因为我懒hhhh<br><a id="more"></a></p>
<p>省赛结束已经有一周的时间了，虽然一直想要写点什么记录一下，但是这周都是在处理各种DDL，所以就拖到了现在OTZ</p>
<p>这是本蒟蒻的第一次省赛，也是第一次外出参加现场赛。具体体验嘛，emmmmmm，虽然赛前bl一直说要拿金牌最后却只拿了个铜这一点让我稍微有点失望，而且实际比赛时的体验也不怎么样（云桌面的锅！），但总体来说还是感觉良好的，<del>至少没打铁</del>。而且还见到了校长（还是这么小😂），在中大逛了一波。作为一个蒟蒻，其实还是挺好的。</p>
<p>具体说一说比赛时的过程。拿到题目后，我和bl师兄还有灿佬一起看题，然后一眼就看到了E和L，并且发现E题和之前周训做过的一道题很像。于是我们就把题目交给bl师兄，然后继续找签到题，在找题的过程中，bl师兄把E和L都给过了。值得一提的是，在bl还在敲E题的时候，华工的一支队伍就把E给A了，当时只过了三分钟……(dltql!(破音))。然后后来又找到了一个J，题意就是给你几张麻将牌，让你判断可不可以组成十三幺或者九连宝灯(不会打麻将的我一开始连题目都看不懂OTZ)。然后灿佬就去敲这道题了，并很快AC…<del>直到这时除了读题我还是没干什么事</del>。</p>
<p>把麻将题过了之后，bl开始敲C。然后就是持续三小时的debug……还好灿佬在中途去A了一道B，不然我们就要打铁了OTZ。</p>
<p>所以说，从这次省赛我得到了两个结论：</p>
<ul>
<li>灿哥nb！</li>
<li>师兄nb！</li>
<li>我太菜了！（读题选手+敲模板选手）</li>
</ul>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title>2020杭电多校第六场 I题</title>
    <url>/2020/08/07/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA-I%E9%A2%98/</url>
    <content><![CDATA[<p><span style="color: grey;">没有封面图</span><br><a id="more"></a></p>
<p>题意：对于给定的<script type="math/tex">b</script>进制数<script type="math/tex">y</script>，定义<script type="math/tex">f(y)</script>表示其<script type="math/tex">y</script>在<script type="math/tex">b</script>进制下的数位和。现在有这样的一个命题：对于任意的<script type="math/tex">b</script>进制数<script type="math/tex">y</script>和给定的<script type="math/tex">b</script>进制数<script type="math/tex">x</script>，如果<script type="math/tex">f(y)</script>整除<script type="math/tex">x</script>，则<script type="math/tex">y</script>也整除<script type="math/tex">x</script>。判断给定<script type="math/tex">b</script>和<script type="math/tex">x</script>下命题正确性。</p>
<p>思路：结论是，当<script type="math/tex">b\equiv 1 \pmod x</script>时，命题成立。原因在于，对于<script type="math/tex">b</script>进制的数<script type="math/tex">y</script>，可以将其表示为<script type="math/tex">y=c_0*b^0+c_1*b^1+c_2*b^2+\dots+c_{n-2}*b^{n-2}+c_{n-1}*b^{n-1}</script>。可以发现，如果<script type="math/tex">b\equiv 1\pmod x</script>，那么由于有<script type="math/tex">A\equiv B \pmod p\Leftrightarrow f(A)\equiv f(B)\pmod x</script>，所以，在这种情况下，有</p>
<script type="math/tex; mode=display">
\begin{equation}
c_0*b^0+c_1*b^1+c_2*b^2+\dots+c_{n-2}*b^{n-2}+c_{n-1}*b^{n-1}\equiv c_0+c_1+c_2+\dots+c_{n-2}+c_{n-1}\pmod x
\end{equation}</script><p><script type="math/tex">c_0+c_1+c_2+\dots+c_{n-2}+c_{n-1}</script>就是题目中的<script type="math/tex">f(y)</script>。所以，结论成立。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a, b) memset((a), (b), sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef, mid, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid + 1, rig, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll b, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;b, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (b &lt; x) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"F"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (b % x == <span class="number">1L</span>L)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"T"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"F"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>思维</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2020牛客多校第一场</title>
    <url>/2020/07/16/2020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA/</url>
    <content><![CDATA[<p><img src="https://pic.downk.cc/item/5f105fed14195aa594b51c3b.jpg" alt><br><a id="more"></a></p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>令<script type="math/tex">C_i=\min_{j>i,s_j=s_i}\{j-i\}</script>，则题目中所说的B-Suffix Array等价于$C_1,C_2,C_3,…，C_n$。因此，只需要求出$C$后，对$C$算一下后缀数组即可。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a, b) memset((a), (b), sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef, mid, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid + 1, rig, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> wa[maxn], wb[maxn], wv[maxn], wss[maxn], rak[maxn], <span class="built_in">height</span>[maxn], cal[maxn], n, sa[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>* r, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a] == r[b] &amp;&amp; r[a + l] == r[b + l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span>* r, <span class="keyword">int</span>* sa, <span class="keyword">int</span> n, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, p, *x = wa, *y = wb, *t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        wss[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        wss[x[i] = r[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; M; i++)</span><br><span class="line">        wss[i] += wss[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        sa[--wss[x[i]]] = i;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>, p = <span class="number">1</span>; p &lt; n; j &lt;&lt;= <span class="number">1</span>, M = p) &#123;</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>, i = n - j; i &lt; n; i++)</span><br><span class="line">            y[p++] = i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt;= j)</span><br><span class="line">                y[p++] = sa[i] - j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            wv[i] = x[y[i]];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            wss[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            wss[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; M; i++)</span><br><span class="line">            wss[i] += wss[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            sa[--wss[wv[i]]] = y[i];</span><br><span class="line">        <span class="keyword">for</span> (t = x, x = y, y = t, p = <span class="number">1</span>, x[sa[<span class="number">0</span>]] = <span class="number">0</span>, i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            x[sa[i]] = cmp(y, sa[i - <span class="number">1</span>], sa[i], j) ? p - <span class="number">1</span> : p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("./A.in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="built_in">fill</span>(cal, cal + maxn, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> pre[<span class="number">2</span>] = &#123; n + <span class="number">1</span>, n + <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[s[i] - <span class="string">'a'</span>] == n + <span class="number">1</span>) &#123;</span><br><span class="line">                cal[i] = n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cal[i] = pre[s[i] - <span class="string">'a'</span>] - i;</span><br><span class="line">            &#125;</span><br><span class="line">            pre[s[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        cal[n + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//puts("cal: ");</span></span><br><span class="line">        <span class="comment">//for (int i = 1; i &lt;= n + 1; i++) &#123;</span></span><br><span class="line">        <span class="comment">//  printf("%d ",cal[i]);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//puts("");</span></span><br><span class="line">        <span class="comment">//puts("----------------------");</span></span><br><span class="line"></span><br><span class="line">        da(cal + <span class="number">1</span>, sa, n + <span class="number">2</span>, n + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, sa[i] + <span class="number">1</span>, i == <span class="number">1</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题$n$的值一定要是$n+2$，$m$的值一定也要是$n+2$！否则不是RE就是WA！</p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>待补</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>待补</p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>待补</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>待补</p>
<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>假设两个字符串$a,b$是同一个字符串的循环节，然后在$2\times max(len(a),len(b))$的范围内比较即可。如果发现没有不相等的字符，则说明两个无穷字符串是同一个字符串，也就是相等。否则，如果$a_i&lt;b_i$，则$a&lt;b$；大于的情况同理。这道题的比较范围比较玄学，是猜出来的，但根据题解，范围只需要到$len(a)+len(b)-gcd(len(a),len(b))$即可。但目前没想明白为什么。。。等一波详细题解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a, b) memset((a), (b), sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef, mid, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid + 1, rig, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> sa, sb;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; sa &gt;&gt; sb) &#123;</span><br><span class="line">        <span class="keyword">int</span> lena = sa.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> lenb = sb.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> bnd = <span class="number">2</span> * <span class="built_in">max</span>(lena, lenb);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sa[i % lena] &lt; sb[i % lenb]) &#123;</span><br><span class="line">                ans = <span class="number">1</span>; <span class="comment">// &lt;</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sa[i % lena] &gt; sb[i % lenb]) &#123;</span><br><span class="line">                ans = <span class="number">2</span>; <span class="comment">// &gt;</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"=&lt;&gt;"</span>[ans] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>待补</p>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>题意是说，给定一个$n$个点$m$条边的流网络，有$q$次询问，第$i$次询问会把图上所有边的容量都设为$\frac{u_i}{v_i}$，查询当前情况下，从点1发送一个单位的流到点$n$的最小花费是多少。</p>
<p>为了方便处理，将所有边的容量都乘以$\frac{v_i}{u_i}$，使其变成1；原本发送一个单位的流，现在变成发送$\frac{v_i}{u_i}$个单位的流（实际上就相当于定义了一个新单位，该单位和原单位的进率是$\frac{v_i}{u_i}$）。然后在算最大流的时候，再记录下不同流量下的最小花费。</p>
<p>而NaN的情况有两种：</p>
<ul>
<li>$u=0$（不考虑这种情况会有除零错误）</li>
<li>$v/u&gt;$最大流（非整除）</li>
</ul>
<p>最后，注意一下处理最终答案的方法（代码165行）</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a, b) memset((a), (b), sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef, mid, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid + 1, rig, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> flow;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">&#125; es[maxm];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> pre[maxn], dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line">ll ansarr[maxm];</span><br><span class="line"><span class="keyword">int</span> N; <span class="comment">// 节点总个数, 节点从0~N-1</span></span><br><span class="line"><span class="keyword">int</span> M;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    N = n;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    mst(head, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap, <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    es[tol].to = v;</span><br><span class="line">    es[tol].cap = cap;</span><br><span class="line">    es[tol].cost = cost;</span><br><span class="line">    es[tol].flow = <span class="number">0</span>;</span><br><span class="line">    es[tol].nxt = head[u];</span><br><span class="line">    head[u] = tol++;</span><br><span class="line"></span><br><span class="line">    es[tol].to = u;</span><br><span class="line">    es[tol].cap = <span class="number">0</span>;</span><br><span class="line">    es[tol].cost = -cost;</span><br><span class="line">    es[tol].flow = <span class="number">0</span>;</span><br><span class="line">    es[tol].nxt = head[v];</span><br><span class="line">    head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">        pre[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = es[i].to;</span><br><span class="line">            <span class="keyword">if</span> (es[i].cap &gt; es[i].flow &amp;&amp; dis[v] &gt; dis[u] + es[i].cost) &#123;</span><br><span class="line">                dis[v] = dis[u] + es[i].cost;</span><br><span class="line">                pre[v] = i;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre[t] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mcmf</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, ll&amp; cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll flow = <span class="number">0</span>;</span><br><span class="line">    cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(s, t)) &#123;</span><br><span class="line">        ll Min = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pre[t]; i != <span class="number">-1</span>; i = pre[es[i ^ <span class="number">1</span>].to]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Min &gt; es[i].cap - es[i].flow) &#123;</span><br><span class="line">                Min = es[i].cap - es[i].flow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pre[t]; i != <span class="number">-1</span>; i = pre[es[i ^ <span class="number">1</span>].to]) &#123;</span><br><span class="line">            es[i].flow += Min;</span><br><span class="line">            es[i ^ <span class="number">1</span>].flow -= Min;</span><br><span class="line">            cost += es[i].cost * Min;</span><br><span class="line">        &#125;</span><br><span class="line">        flow += Min;</span><br><span class="line">        ansarr[(<span class="keyword">int</span>)flow] = cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch - <span class="string">'0'</span>);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//inline void Swap(ll&amp; a,ll&amp; b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//ll tmp=a;</span></span><br><span class="line"><span class="comment">//a=b;b=tmp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M) != EOF) &#123;</span><br><span class="line">        init(N);</span><br><span class="line">        <span class="keyword">int</span> ai, bi, ci;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            ai = <span class="built_in">read</span>();</span><br><span class="line">            bi = <span class="built_in">read</span>();</span><br><span class="line">            ci = <span class="built_in">read</span>();</span><br><span class="line">            ai--;</span><br><span class="line">            bi--;</span><br><span class="line">            addedge(ai, bi, <span class="number">1</span>, ci);</span><br><span class="line">        &#125;</span><br><span class="line">        ll miniflow;</span><br><span class="line">        ll maxiflow = mcmf(<span class="number">0</span>, N - <span class="number">1</span>, miniflow);</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        q = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            u = <span class="built_in">read</span>();</span><br><span class="line">            v = <span class="built_in">read</span>();</span><br><span class="line">            <span class="comment">//printf("maxiflow = %lld\n",maxiflow);</span></span><br><span class="line">            <span class="keyword">if</span> (u == <span class="number">0</span> || ((<span class="number">1L</span>L * v) / u == maxiflow &amp;&amp; (<span class="number">1L</span>L * v) % u &gt; <span class="number">0</span>) || (<span class="number">1L</span>L * v) / u &gt; maxiflow) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"NaN"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> idx = v / u;</span><br><span class="line">            ll up = ansarr[idx] * u + (ansarr[idx + <span class="number">1</span>] - ansarr[idx]) * (v % u);</span><br><span class="line">            <span class="comment">//if(v&lt;up) Swap(v, up)</span></span><br><span class="line">            ll g = gcd(<span class="number">1L</span>L * v, up);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>, up / g, v / g);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>待补</p>
<h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>高数签到题。虽然这题是我A的，但是因为高数太菜，所以其实积分结果是在OEIS上找到的hhh。</p>
<p>积分过程如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\because (x-x^2)^n&=\frac{1}{4}-\left( \frac{1}{2}-x\right )^2 \\
\therefore \int_0^1(x-x^2)^ndx&=\int_0^1\left(\frac{1}{4}-\left(\frac{1}{2}-x\right)^2\right)^ndx\\
&=\frac{1}{4^n}\int_0^1\left(1-4\left(\frac{1}{2}-x\right)^2\right)^ndx\\
&=\frac{1}{4^n}\int_0^1\left(1-(2x-1)^2\right)^ndx
\end{aligned}</script><p>令$\sin t=2x-1$，则有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\int_0^1(x-x^2)^ndx&=\frac{1}{4^n}\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}(1-\sin^2t)^ndx\\
&=\frac{1}{4^n}\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}(1-\sin^2t)^n\frac{\cos t}{2}dt\\
&=\frac{1}{4^n}\int_0^{\frac{\pi}{2}}\cos^{2n+1}tdt
\end{aligned}</script><p>由Wallis公式：</p>
<script type="math/tex; mode=display">
\int_0^{\frac{\pi}{2}}\cos^nxdx=
\begin{cases}
\frac{\pi(2k)!!}{2(2k+1)!!}&\text{n=2k}\\
\frac{(2k)!!}{(2k+1)!!}&\text{n=2k+1}
\end{cases}</script><p>其中，$\frac{(2k)!!}{(2k+1)!!}=\frac{2\times4\times6\times\dots\times(2n-2)\times2n}{1\times3\times5\times\dots\times(2n-1)\times(2n+1)}$。因此，有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\int_0^1(x-x^2)^ndx&=\frac{1}{4^n}\frac{(2n)!!}{(2n+1)!!}\\
&=\frac{1}{4^n}\frac{(2n)!!}{\frac{(2n+1)!}{(2n)!!}}\\
&=\frac{1}{4^n}\frac{(2n!!)^2}{(2n+1)!}\\
&=\frac{1}{4^n}\frac{4^n(n!)^2}{(2n+1)!}\\
&=\frac{(n!)^2}{(2n+1)!}
\end{aligned}</script><p>得到上面的积分结果后，套式子再求个逆元就行了。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a, b) memset((a), (b), sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef, mid, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid + 1, rig, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bnd = <span class="number">2e6</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line">ll frac[bnd];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    frac[<span class="number">0</span>] = frac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= bnd; i++) &#123;</span><br><span class="line">        frac[i] = (frac[i - <span class="number">1</span>] % mod * i % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll&amp; x, ll&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll d = exgcd(a, n, x, y);</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (x % n + n) % n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        ll f = frac[n];</span><br><span class="line">        ll ff = frac[<span class="number">2</span> * n + <span class="number">1</span>];</span><br><span class="line">        ll up = (f % mod * f % mod) % mod;</span><br><span class="line">        ll down = ff % mod;</span><br><span class="line">        ll ans = (up % mod * inv(down, mod) % mod) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC016B Colorful Hats</title>
    <url>/2020/03/03/ACG016B-Colorful-Hats/</url>
    <content><![CDATA[<p><img src="https://pic.downk.cc/item/5e5e72b398271cb2b862f2b8.jpg" alt></p>
<a id="more"></a>
<p>题意是说，每只猫都带有一顶帽子，且每只猫能看到除自己以外的其他人的帽子总共有多少种颜色。问是否能构造出一个帽子颜色的序列，满足每只猫看到的颜色数目。</p>
<p>设看到的颜色数的最大值为$maxi$，最小值为$mini$。</p>
<p>一个显而易见的结论是，如果$maxi-mini&gt;1$，则结果为No(可自行验证)</p>
<p>然后考虑$maxi==mini$的情况。如果两者的值是1或$n-1$，那结果是Yes</p>
<p>否则，对于任意一种颜色，必须要有至少两只猫的帽子是这种颜色的。（草稿纸上画个图即可知道，原因是，假设有一种颜色只被一只猫所拥有，因为自己是看不到自己的帽子的，所以对于这只猫来说，他所看到的帽子的颜色会比其他猫所看到的颜色少一种，这就不符合初始条件）</p>
<p>最后考虑$maxi!=mini$的情况。对于那些颜色数为$mini$的猫，其帽子的颜色必然只为它所拥有，即这种颜色只会在一只猫的头上出现；而对于那些颜色数为$maxi$的猫，其帽子的颜色则至少要被两只猫拥有。所以可以先把颜色数为$mini$的都填充了，然后看看剩下的颜色是否可以保证填入剩下的猫之后，每种颜色至少被两只猫所拥有。</p>
<p>PS：蒟蒻第一次做atcoder，感觉真的好锻炼思维qwq</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> maxi=-INF;<span class="keyword">int</span> mini=INF;</span><br><span class="line">    <span class="keyword">int</span> minicnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">        maxi=<span class="built_in">max</span>(maxi,arr[i]);</span><br><span class="line">        mini=<span class="built_in">min</span>(mini,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==mini) minicnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxi-mini&gt;<span class="number">1</span>||maxi&gt;n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxi==mini)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mini==n<span class="number">-1</span>||mini==<span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(n/mini&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxi!=mini)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=n-minicnt;</span><br><span class="line">        <span class="keyword">int</span> y=maxi-minicnt;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x/y&lt;<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>2020牛客多校第三场</title>
    <url>/2020/07/19/2020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA/</url>
    <content><![CDATA[<p><img src="https://pic.downk.cc/item/5f14552214195aa594e12634.jpg" alt><br><a id="more"></a></p>
<h3 id="A-贪心"><a href="#A-贪心" class="headerlink" title="A 贪心"></a>A 贪心</h3><p>给定四种状态，状态0没有钓鱼也不能做鱼饵；状态1可以做鱼饵，但是没有鱼；状态三有鱼但不能做鱼饵；状态四有鱼也可以做鱼饵。没有鱼的状态下，如果有鱼饵，可以钓鱼。</p>
<p>做法是简单贪心。有鱼的时候直接钓鱼，没鱼但能做鱼饵就做鱼饵，没鱼且不能做鱼饵就看看有没有鱼饵可以用来钓鱼。从左到右扫一遍，如果最后发现鱼饵有剩下，那就答案加上<strong>鱼饵数/2</strong>，表示原本做鱼饵的状态，一半用来做鱼饵，一般用这些做出来的鱼饵钓鱼</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a, b) memset((a), (b), sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef, mid, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid + 1, rig, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">int</span> ba=<span class="number">0</span>,ans=<span class="number">0</span>;<span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%1d"</span>,&amp;tmp);</span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="number">2</span>||tmp==<span class="number">3</span>) ans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp==<span class="number">1</span>) ba++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ba&gt;<span class="number">0</span>) ba--,ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+ba/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-简单思维题"><a href="#B-简单思维题" class="headerlink" title="B 简单思维题"></a>B 简单思维题</h3><p>刚看完题目的时候以为是线段树or Splay区间搬移，但想到签到题不太可能需要用到复杂的数据结构。后来wxdl说有很简单的思路，于是我就去看其他题了。赛后发现，实际上只需要移动指针即可维护答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> q;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];<span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d"</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'M'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                p=(p+x)%len;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                x=<span class="built_in">abs</span>(x);</span><br><span class="line">                p-=x;</span><br><span class="line">                p=(p%len+len)%len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'A'</span>)&#123;</span><br><span class="line">            x--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,s[(p+x)%len]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-简单计算几何"><a href="#C-简单计算几何" class="headerlink" title="C 简单计算几何"></a>C 简单计算几何</h3><p>给出右手的形状，并说明左手和右手是对称的。现在给出一组20个点的坐标，问这些坐标表示的是左手还是右手。</p>
<p>题目中一个很重要的条件是，测试数据中的手和题面中的手相比，只会平移和旋转，而不会放大缩小。同时又观察到，图中由一条长为6的边、一条长为1的边和一条长为3的边组成的手指只有拇指。所以可以搞一个宽度为4的窗口，找到这样的四个点：两组相邻点的距离分别是6和3。这样就能找到拇指的位置。找到之后，用叉乘判断下在拇指左侧的点多还是右侧的点多即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-3</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Eps=<span class="number">1e-8</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;Eps)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="built_in">point</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>(<span class="keyword">double</span> _x,<span class="keyword">double</span> _y)&#123;</span><br><span class="line">        x=_x;y=_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">point</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="built_in">point</span>&amp; b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">point</span>(x-b.x,y-b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span>^(<span class="keyword">const</span> <span class="built_in">point</span>&amp; b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.y-y*b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span>&#123;</span></span><br><span class="line">    <span class="built_in">point</span> s,e;</span><br><span class="line">    <span class="built_in">line</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">line</span>(<span class="built_in">point</span> _s,<span class="built_in">point</span> _e)&#123;</span><br><span class="line">        s=_s;e=_e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">relation</span><span class="params">(<span class="built_in">point</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c=sgn((p-s)^(e-s));</span><br><span class="line">        <span class="keyword">if</span>(c&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">point</span> ps[<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span>&amp; pa,<span class="keyword">const</span> <span class="built_in">point</span>&amp; pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(pa.x-pb.x)+sqr(pa.y-pb.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span>&amp; pa,<span class="keyword">const</span> <span class="built_in">point</span>&amp; pb,<span class="keyword">const</span> <span class="built_in">point</span>&amp; pc,<span class="keyword">const</span> <span class="built_in">point</span>&amp; pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dis1=dist(pa,pb);</span><br><span class="line">    <span class="keyword">double</span> dis2=dist(pc,pd);</span><br><span class="line">    <span class="comment">//printf("dis1 = %lf, dis2 = %lf, %lf, %lf\n",dis1,dis2,fabs(dis1-3.0),fabs(dis2-6.0));</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">fabs</span>(dis1<span class="number">-6.00</span>)&lt;eps&amp;&amp;<span class="built_in">fabs</span>(dis2<span class="number">-3.00</span>)&lt;eps)||(<span class="built_in">fabs</span>(dis1<span class="number">-3.00</span>)&lt;eps&amp;&amp;<span class="built_in">fabs</span>(dis2<span class="number">-6.00</span>)&lt;eps)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">double</span> X,Y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;X,&amp;Y);</span><br><span class="line">            ps[i].x=X;ps[i].y=Y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="keyword">int</span> idx1,idx2,idx3,idx4;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            idx1=i;idx2=(i+<span class="number">1</span>)%<span class="number">20</span>;</span><br><span class="line">            idx3=(i+<span class="number">2</span>)%<span class="number">20</span>;idx4=(i+<span class="number">3</span>)%<span class="number">20</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(ps[idx1],ps[idx2],ps[idx3],ps[idx4]))&#123;</span><br><span class="line">                pos=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//printf("pos = %d\n",pos);</span></span><br><span class="line">        <span class="function"><span class="built_in">line</span> <span class="title">L</span><span class="params">(ps[pos],ps[(pos+<span class="number">1</span>)%<span class="number">20</span>])</span></span>;</span><br><span class="line">        <span class="keyword">int</span> lef=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rig=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(pos+<span class="number">2</span>)%<span class="number">20</span>;i!=pos;i=(i+<span class="number">1</span>)%<span class="number">20</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> rela=L.relation(ps[i]);</span><br><span class="line">            <span class="keyword">if</span>(rela==<span class="number">1</span>) lef++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rela==<span class="number">2</span>) rig++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lef&lt;rig) <span class="built_in">puts</span>(<span class="string">"right"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"left"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="F-数论、拓展欧几里得"><a href="#F-数论、拓展欧几里得" class="headerlink" title="F 数论、拓展欧几里得"></a>F 数论、拓展欧几里得</h3><p>题意是说，给出两个整数$a,b$，$c,d,e,f$都是未知数，求方程$\frac{c}{d}-\frac{e}{f}=\frac{a}{b}$的任意一个解。同时，需要满足以下两个条件：</p>
<ul>
<li>$d&lt;b\ and\ f&lt;d$</li>
<li>$1\leq c,e\leq 4\times 10^{12}$</li>
</ul>
<p>思路是这样的，分三种情况讨论：</p>
<ul>
<li><p>$\gcd(a,b)&gt;1$</p>
<p>设$g=\gcd(a,b)$，则有$\frac{(a+1)/g}{b/g}-\frac{a/g}{b/g}=\frac{a}{b}$。因为$g&gt;1$，所以$b/g&lt;b$，所以直接令$c=(a+1)/g,d=b/g,e=a/g,f=b/g$即可。</p>
</li>
<li><p>$\gcd(a,b)=1$，且$b$的质因数至少有两个</p>
<p>设此时的$b=p_1^{x_1}p_2^{x_2}p_3^{x_3}\dots p_n^{x_n}$，令$d=p_1^{x_1},f=\frac{b}{d}$，则有$df=b$。问题转化为求解不定方程$cf-de=a$。用exgcd求解即可。</p>
</li>
<li><p>$\gcd(a,b)=1$，且$b=p^x$（$p$是素数）。也就是说$b$是1或者一个指数的幂次</p>
<p>此时无解，原因是，如果$b$是1，那么$d,f$就只能取0，这显然是不可能的。如果$b=p^x$，则可以设$d=p^u,f=p^{x-u}$。exgcd有解的充要条件是$\gcd(d,f)\mid a$，所以有$\gcd(d,f)=p^{\min{u,x-u}}$。但因为$\gcd(a,b)=1$，所以$a$的质因子中没有$p$，也就是说$\gcd(d,f)\nmid a$，exgcd不可能有解。</p>
</li>
</ul>
<p>拓展欧几里得解不定方程$ax+by=c$，最后的解一定要乘以$\frac{c}{\gcd(a,b)}$！因为求解这个方程的时候，实际上是在求解$ax’+by’=\gcd(a,b)$，因此要左右两边都同乘上$\frac{c}{\gcd(a,b)}$这个因子，才是最终的解！数论忘得一干二净orz</p>
<h3 id="L-签到题"><a href="#L-签到题" class="headerlink" title="L 签到题"></a>L 签到题</h3><p>温暖的签到题，代码就不放了</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ4403-序列统计(组合数学，卢卡斯定理)</title>
    <url>/2019/01/28/BZOJ4403-%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>题目链接:<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4403" rel="external nofollow noopener noreferrer" target="_blank">序列统计</a><br><img src="https://pic.superbed.cn/item/5c4e754f5f3e509ed97c0c84" alt></p>
<p>&emsp;&emsp;首先，L与R实际上是没太大意义的，因为我们需要的只是L和R之间含有多少个数，即R-L+1个数。其次，要注意一点，在一个序列中，数字是可以重复的。以样例中的2 4 5为例，符合要求的序列有{4},{5},{4,5},{4,4},{5,5}。事实上，问题可以转化为“有R-L+1个不同的盒子，若要将i(1&lt;=i&lt;=n)个相同的小球放进这些盒子里(某些盒子可以为空)，问对于所有的i，放法的总和是多少？”其中，不同的盒子代表着不同的数，在一个盒子中放入一个球，相当于选取一次该数字作为序列中的成员。再将问题抽象一下，即为“将i个小球划分成k堆(1&lt;=k&lt;=i)，问对于所有的i，划分方法的总和是多少？”对于这个问题，我们可以直接用C(m+n,n)求解(对于本题是C(seg+n,n),seg=R-L+1)另外，通过观察可知(其实是我不会推导。。。。。。),通过C(m+n,n)求出的数会比正确答案大1，故最终答案为C(seg+n,n)-1。<br>又因为10^6+3为素数，故可以用Lucas。</p>
<p>代码如下:<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdlib&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long <span class="keyword">ll;</span></span><br><span class="line"><span class="keyword">ll </span>fpow(<span class="keyword">ll </span>a,<span class="keyword">ll </span><span class="keyword">b,ll </span>p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ll </span>ans=<span class="number">1</span><span class="comment">;a%=p;</span></span><br><span class="line">    while(<span class="keyword">b)</span></span><br><span class="line"><span class="keyword"> </span>   &#123;</span><br><span class="line">        if(<span class="keyword">b&amp;1)</span></span><br><span class="line"><span class="keyword"> </span>           ans=(ans*a)%p;</span><br><span class="line">        a=(a*a)%p;</span><br><span class="line">        <span class="keyword">b&gt;&gt;=1;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ll </span>inv(<span class="keyword">ll </span>x,<span class="keyword">ll </span>p)</span><br><span class="line">&#123;</span><br><span class="line">    return fpow(x,p<span class="number">-2</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ll </span>comb(<span class="keyword">ll </span>n,<span class="keyword">ll </span>m,<span class="keyword">ll </span>p)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;m)        return <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ll </span>up=<span class="number">1</span><span class="comment">;ll down=1;</span></span><br><span class="line">    for(int i=n-m+<span class="number">1</span><span class="comment">;i&lt;=n;i++)        up=(up*i)%p;</span></span><br><span class="line">    for(int i=<span class="number">1</span><span class="comment">;i&lt;=m;i++)        down=(down*i)%p;</span></span><br><span class="line">    return up*inv(down,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ll </span>lucas(<span class="keyword">ll </span>a,<span class="keyword">ll </span><span class="keyword">b,ll </span>p)</span><br><span class="line">&#123;</span><br><span class="line">    return !<span class="keyword">b?1:lucas(a/p,b/p,p)*comb(a%p,b%p,p)%p;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword">int </span>main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    <span class="keyword">ll </span>n,lef,rig;</span><br><span class="line">    <span class="keyword">ll </span>p=<span class="number">3</span>+<span class="number">1</span>e6;</span><br><span class="line">    <span class="keyword">scanf("%d",&amp;t);</span></span><br><span class="line"><span class="keyword"> </span>   while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">scanf("%lld </span>%<span class="keyword">lld </span>%<span class="keyword">lld",&amp;n,&amp;lef,&amp;rig);</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">ll </span>seg=rig-lef+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">ll </span>ans=<span class="number">0</span><span class="comment">; </span></span><br><span class="line">        ans=(lucas(seg+n,n,p)+p<span class="number">-1</span>)%p;</span><br><span class="line">        printf(<span class="string">"%lld\n"</span>,ans)<span class="comment">; </span></span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Aizu - ALDS1_1_D-Maximum Profit（转化思想+DP）</title>
    <url>/2019/02/13/Aizu-ALDS1-1-D-Maximum-Profit/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/Aizu-ALDS1_1_D" rel="external nofollow noopener noreferrer" target="_blank">Aizu - ALDS1_1_1_D</a></p>
<p>(这貌似是个日本的oj？名字叫aizu有点奇怪呢hhhh)<br><a id="more"></a></p>
<p>&emsp;&emsp;这道题的思路是首先将相减转化为相加。我们可以在原数组的基础上再构造一个新的数组sub[],sub[]中存放的是R[i+1]-R[i]，因此，有以下式子成立：<br>(R[i+1]-R[i]) + (R[i+2]-R[i+1]) + ··· + (R[j-1]-R[j-2]) + (R[j] - R[j-1]) = sub[i+1] + sub[i+2] + ··· + sub[j-1] + sub[j] = R[j] - R[i]<br>&emsp;&emsp;这么一来，求差的最大值就转化为了求sub[]的连续子序列和的最大值，而这只需要用dp求即可。状态转移方程为dp[j] = max(dp[j-1] + sub[j],sub[j])。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200000</span>+<span class="number">5</span>;</span><br><span class="line">ll R[maxn];</span><br><span class="line">ll sub[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">memset</span>(R,<span class="number">0</span>,<span class="keyword">sizeof</span>(R));</span><br><span class="line">    <span class="built_in">memset</span>(sub,<span class="number">0</span>,<span class="keyword">sizeof</span>(sub));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;R[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        sub[i]=R[i+<span class="number">1</span>]-R[i];</span><br><span class="line">    dp[<span class="number">1</span>]=sub[<span class="number">1</span>];</span><br><span class="line">    ll ans=INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>]+sub[i],sub[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;ans)</span><br><span class="line">            ans=dp[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>简单DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC2019哈尔滨站总结</title>
    <url>/2019/10/15/CCPC2019%E5%93%88%E5%B0%94%E6%BB%A8%E7%AB%99%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/Hc44a6b020fd5413ca3b54eea908034afn.jpg" alt></p>
<a id="more"></a>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>萌新的第一场区域赛，抱队友大腿拿了个铜，不至于打铁qwq。队友实在太强辣！</p>
<h4 id="热身赛"><a href="#热身赛" class="headerlink" title="热身赛"></a>热身赛</h4><p>热身赛四道题，A，B都是傻逼题；C，D是牛客多校原题，然而我们并没有敲出来……C题原本的想法是枚举矩阵起点，然后单调栈维护纵向横向两个方向最远可以拓展的距离；后来听对面女队的小姐姐讨论，觉得可以尺取法搞搞，结果热身赛结束了都没弄出来😭。后悔没有好好补多校的题😭</p>
<p>热身赛草草结束，去东林恰了个晚饭，<del>东林的饭堂还挺好吃的</del></p>
<h4 id="正赛"><a href="#正赛" class="headerlink" title="正赛"></a>正赛</h4><p>正赛一共过了下面四题</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Problem</th>
<th>Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td>F - Fixing Banners</td>
<td>直接6!暴力枚举</td>
</tr>
<tr>
<td>I - Interesting Permutation</td>
<td>牛逼队友找规律，我一脸懵逼……</td>
</tr>
<tr>
<td>J - Justifying the Conjecture</td>
<td>>=5的情况都有解，奇数分解成3 + x，偶数分解成2 + x</td>
</tr>
<tr>
<td>K - Keeping Rabbits</td>
<td>无论经过多少天，概率分布都不会变化</td>
</tr>
</tbody>
</table>
</div>
<p>开场看题时沿用了我们队一直以来的策略，我从后面开始看题，zh学长从前面开始看题，pzc中间随便看。根据赛前训练的经验，签到题一般是倒数第二或第三题，再加上这次的倒数第一题是一道题面贼长的大模拟，于是看题时我没有从倒数第一题开始，而是直接选了最签到的 J，发现果然是水题，于是把题意喂给主代码手，10min内水过。</p>
<p>往后又看到了K，于是把题意告诉学长，然后自己接着看题。看题过程中发现了F和I，觉得有搞头，然后去搞了搞F，喂给学长和代码手，过了。紧接着是学长敲K，也是一发过。开场签到感觉很顺利，<del>然后就开始自闭了</del></p>
<p>签完前三题后，开始搞I 。题意是说给定一个$1$到$n$的排列$a_1,a_2,a_3,…,a_n$，对于两个序列<script type="math/tex">f_i=max\{a_1,a_2,a_3,...,a_i\}</script>，<script type="math/tex">g_i=min\{a_1,a_2,a_3,...,a_i\}</script>，定义$h_i=f_i-g_i$。现在给出一个$h$序列，问有多少个$1$到$n$的排列，可以生成这样的一个$h$序列。</p>
<p>第一反应是dp，但队里的dp选手想不出要怎么d OTZ。过了一会后牛逼队友发现这东西可以找规律解决，结果打了个表对拍一下，结果发现规律好像推错了……于是继续自闭，直到差不多一点的时候，队友才把正确的规律搞了出来，然后搞搞搞，终于过了😭。对于这题我个人感觉挺惭愧的，可以说除了读题对拍意外没有其他贡献，<del>后期还挂机了</del>。I题过了之后，排名上升到了121，终于苟到铜牌了OTZ</p>
<p>这时候还剩下一个半小时，感觉如果不把E过掉，很可能会打铁（不过事实证明还是能有铜的）。于是疯狂搞E，但最终还是很遗憾没有弄出来。赛后跟我校的另一支队了解了一下，得知他们将快读换成了A题题面上的快读就过了……过了……队友听到这都要哭了，<del>我也要哭了qwq</del></p>
<p>第一场区域赛，没有打铁，我个人已经非常满意了。大致总结一下自身的问题，一就是精神不够集中，容易进入挂机状态。无论是平时训练还是现场赛都是如此。二就是时间的利用效率还不够高，比如说这次现场赛，后期卡E题的时候，我对这题几乎是0贡献，那这时为什么我不去搞搞那两道模拟题，想个大概的框架，然后把题意和自己的想法喂给擅长模拟题的队友呢？或许这样我们能A五题？</p>
<p>就这样吧，这周银川站加油💪</p>
<h4 id="一些题外话"><a href="#一些题外话" class="headerlink" title="一些题外话"></a>一些题外话</h4><p><img src="https://ae01.alicdn.com/kf/H7d0f28ea3f4c49c19ad981ce10d5ac0du.jpg" alt></p>
<center>摄于深圳—哈尔滨的飞机上</center>



<p><img src="https://ae01.alicdn.com/kf/Hb1000c4c83664acb8eda52e37b4c3bdce.png" alt></p>
<center>东林里面居然还有个自然博物馆，我酸了qwq</center>





<p><img src="https://ae01.alicdn.com/kf/H3d63cdbd1f44496ca159ea95fcf3795cR.jpg" alt></p>
<center>哈尔滨特色锅包肉，然而并不喜欢甜食。。。</center>

<p><img src="https://ae01.alicdn.com/kf/Hc44a6b020fd5413ca3b54eea908034afn.jpg" alt></p>
<center>摄于哈尔滨太阳岛</center>]]></content>
      <categories>
        <category>ACM</category>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CCPC</tag>
        <tag>赛后总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces988A ~ 998E</title>
    <url>/2019/03/28/Co-de-for/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/CodeForces-988A" rel="external nofollow noopener noreferrer" target="_blank">988D - Diverse Team</a></p>
<p>没什么好说的<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    mst(cnt,<span class="number">0</span>);</span><br><span class="line">    mst(arr,<span class="number">0</span>);mst(ans,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        cnt[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;<span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[arr[i]])&#123;</span><br><span class="line">            tot++;</span><br><span class="line">            cnt[arr[i]]=<span class="number">0</span>;</span><br><span class="line">            ans[idx++]=i;</span><br><span class="line">            <span class="keyword">if</span>(tot&gt;=k)        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot&gt;=k)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>,ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/CodeForces-988B" rel="external nofollow noopener noreferrer" target="_blank">988B - Substrings Sort</a></p>
<p>先根据字符串长度排个序，再用find找一下是否有子串即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="built_in">string</span> strs[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> sa,<span class="built_in">string</span> sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sa.<span class="built_in">size</span>()&gt;sb.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;strs[i];</span><br><span class="line">    sort(strs,strs+n,cmp);</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs[i].<span class="built_in">find</span>(strs[i+<span class="number">1</span>])==<span class="number">-1</span>)&#123;</span><br><span class="line">            flag=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;strs[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/CodeForces-988C" rel="external nofollow noopener noreferrer" target="_blank">988C - Equal Sums</a></p>
<p>对于一个序列，将总和减去某个元素所得到的数放进map中，map的key是这个元素，value是这个元素出现的次数，然后进行到后面的序列时再用map查找即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; mp;        <span class="comment">//序列序号，元素序号 </span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; ansp;</span><br><span class="line">    <span class="keyword">int</span> ansi,ansj;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[j];</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">                sum+=arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">1</span>;idx&lt;=n;idx++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp.count(sum-arr[idx])!=<span class="number">0</span>&amp;&amp;mp[sum-arr[idx]].first!=i)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    ansp=mp[sum-arr[idx]];</span><br><span class="line">                    ansi=i;ansj=idx;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    mp[sum-arr[idx]]=make_pair(i,idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ansi,ansj);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ansp.first,ansp.second);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/CodeForces-988D" rel="external nofollow noopener noreferrer" target="_blank">988D - Points and Powes of Two</a></p>
<p>这道题有一个结论，就是符合要求的数字不超过三个，且它们之间满足一个关系，即三个数之间成等差数列，公差为2的n次幂(具体怎么来的，可以看这篇文章-&gt;<a href="https://blog.csdn.net/weixin_39453270/article/details/80548442" rel="external nofollow noopener noreferrer" target="_blank">Codeforces 988D（STL运用+思维）</a>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ll arr[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="built_in">set</span>&lt;ll&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;arr[i]);</span><br><span class="line">        st.insert(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;<span class="number">2e9</span>+<span class="number">5</span>;j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.count(arr[i]+j)&amp;&amp;st.count(arr[i]+<span class="number">2</span>*j))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"3\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld %lld %lld\n"</span>,arr[i],arr[i]+j,arr[i]+<span class="number">2</span>*j);</span><br><span class="line">                <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;<span class="number">2e9</span>+<span class="number">5</span>;j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.count(arr[i]+j))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,arr[i],arr[i]+j);</span><br><span class="line">                <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1\n%lld\n"</span>,arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">end</span>:;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/CodeForces-988E" rel="external nofollow noopener noreferrer" target="_blank">988E</a></p>
<p>因为能被25整除的数其末尾两位数一定是00,25,50,75中的其中一个，所以对于暴力模拟即可，得到四个交换次数，最后取最小的那个。对于前导0的处理，方法是若完成模拟后出现了前导0，就将这个0与数字中第一个(从高位开始数)非零的数交换，并将交换步数加到答案上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="comment">//00,25,50,75</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> ch1,<span class="keyword">char</span> ch2,<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==ch2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                swap_(str[j],str[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==ch1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len<span class="number">-2</span>;j++)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                swap_(str[j],str[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                pos=i;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt+=pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> num;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="keyword">int</span> ans1,ans2,ans3,ans4;</span><br><span class="line">    ans1=solve(<span class="string">'0'</span>,<span class="string">'0'</span>,num);</span><br><span class="line">    ans2=solve(<span class="string">'2'</span>,<span class="string">'5'</span>,num);</span><br><span class="line">    ans3=solve(<span class="string">'5'</span>,<span class="string">'0'</span>,num);</span><br><span class="line">    ans4=solve(<span class="string">'7'</span>,<span class="string">'5'</span>,num);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">min</span>(ans1,<span class="built_in">min</span>(ans2,<span class="built_in">min</span>(ans3,ans4)));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 1095B Array Stabilization</title>
    <url>/2019/02/24/CodeForces-1095B-Array-Stabilization/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/CodeForces-1095B" rel="external nofollow noopener noreferrer" target="_blank">Array Stabilization</a></p>
<p>&emsp;&emsp;题意是要求最大值和最小值的差值的最小值。容易想到，对于一个有序序列，最可能得到这个最小值的是删去这个序列的最大值或最小值，因为删去除最大值和最小值外的数并不会改变差值的最小值。因此，我们只需要比较一下删去最大值和最小值后得到的差值，然后挑小的那个即可。<br><a id="more"></a></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JIN 678</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    sort(arr,arr+n);</span><br><span class="line">    <span class="keyword">int</span> ans1,ans2;</span><br><span class="line">    ans1=arr[n<span class="number">-2</span>]-arr[<span class="number">0</span>];</span><br><span class="line">    ans2=arr[n<span class="number">-1</span>]-arr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">min</span>(ans1,ans2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 1095A Repeating Cipher </title>
    <url>/2019/02/24/CodeForces-1095A-Repeating-Cipher/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/CodeForces-1095A" rel="external nofollow noopener noreferrer" target="_blank">Repeating Cipher</a></p>
<p>&emsp;&emsp;emmmmmm感觉没什么好说的hhhhh</p>
<a id="more"></a>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JIN 678</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">char</span> ans[<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">    <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;j++,i+=j)</span><br><span class="line">        ans[cnt++]=str[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>;idx&lt;cnt;idx++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,ans[idx]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces1136C - Nastya Is Transposing Matrices</title>
    <url>/2019/04/28/CodeForces-1136C-Nastya-Is-Transposing-Matrices/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1HXZebRCw3KVjSZR0q6zcUpXak.jpg" alt>Photo by Fancycrave.com from Pexels</p>
<a id="more"></a>
<p><a href="https://cn.vjudge.net/problem/CodeForces-1136C" rel="external nofollow noopener noreferrer" target="_blank">Nastya Is Transposing Matrices</a></p>
<p>题目大意就是说有两个$n \times m$的矩阵A和B，现在可以从矩阵A中取出一个方阵并对这个方阵进行转置，问能否通过这种操作来使得A转换为B。</p>
<p>首先，转置是不会影响被转置方阵的主对角线的，他只会对被转置方阵的副对角线上的元素的顺序造成影响。因此，要判断A是否能通过这样的操作转换为B，只需要判断在每一个指向右上方方向的直线上，A和B的所具有的元素是否相同即可。比方说：</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_1=
\begin{bmatrix}
1&2&3\\
4&5&6\\
7&8&9
\end{bmatrix}
\  ,
B_1=
\begin{bmatrix}
1&2&3\\
4&7&6\\
5&8&9
\end{bmatrix}
\end{aligned}</script><p>这两个矩阵之间，A<sub>1</sub>是可以通过转置得到B<sub>1</sub>的，因为它们右上角方向上的数分别是1；2，4；3，5，7；6，8；9，只是排列顺序不一样。</p>
<p>但下面这两个矩阵就不行了：</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_2=
\begin{bmatrix}
1&2&3\\
4&5&6\\
7&8&9
\end{bmatrix}
\  ,
B_2=
\begin{bmatrix}
1&2&3\\
9&7&6\\
5&8&9
\end{bmatrix}
\end{aligned}</script><p>其中原因不再赘述。</p>
<p>代码如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> ma[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> mb[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> arr1[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=x;</span><br><span class="line">    <span class="keyword">int</span> j=y;</span><br><span class="line">    <span class="keyword">int</span> cnt1=<span class="number">0</span>;<span class="keyword">int</span> cnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=x,j=y;i&gt;=<span class="number">1</span>&amp;&amp;j&lt;=m;i--,j++)&#123;</span><br><span class="line">        arr1[cnt1++]=ma[i][j];</span><br><span class="line">        arr2[cnt2++]=mb[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr1,arr1+cnt1);</span><br><span class="line">    sort(arr2,arr2+cnt2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt1;i++)</span><br><span class="line">        <span class="keyword">if</span>(arr1[i]!=arr2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;ma[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;mb[i][j];</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check(i,<span class="number">1</span>))&#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check(n,i))&#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1064D - Labyrinth</title>
    <url>/2019/08/25/Codeforces-1064D-Labyrinth/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H322f2a344041467eac0980910fa45d97Q.jpg" alt></p>
<a id="more"></a>
<p><a href="https://cn.vjudge.net/problem/CodeForces-1064D" rel="external nofollow noopener noreferrer" target="_blank">Labyrinth</a></p>
<p>题意是说，有一个迷宫，限制了左移和右移的次数，但上移和下移的次数不做限制，问从某一点出发，最多能访问多少个点。</p>
<p>bfs搜一遍，每个节点记录当前剩余的左移和右移次数。需要注意的是，这题应该使用优先队列，每次走的时候优先走那些剩余左右移动次数多的点，这样才能尽可能地访问更多的点。这应该也算是一种贪心策略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> lmx,rmx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> lef,rig;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; na) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lef==na.lef)    <span class="keyword">return</span> rig&lt;na.rig;        <span class="comment">//优先走那些左右次数大的点,否则会导致有些点无法到达 </span></span><br><span class="line">        <span class="keyword">return</span> lef&lt;na.lef;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;        <span class="comment">//上,下,左,右 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> cx,<span class="keyword">int</span> cy)</span>            <span class="comment">//行,列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cx&lt;<span class="number">0</span>||cx&gt;=n||cy&lt;<span class="number">0</span>||cy&gt;=m||mp[cx][cy]==<span class="string">'*'</span>||vis[cx][cy])    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> sx,<span class="keyword">int</span> sy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    mst(vis,<span class="number">0</span>);</span><br><span class="line">    priority_queue&lt;node&gt; que;</span><br><span class="line">    que.push(node&#123;sx,sy,lmx,rmx&#125;);</span><br><span class="line">    vis[sx][sy]=<span class="number">1</span>;ans++;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        node cur=que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">int</span> xx=cur.x;<span class="keyword">int</span> yy=cur.y;</span><br><span class="line">        <span class="keyword">int</span> L=cur.lef;</span><br><span class="line">        <span class="keyword">int</span> R=cur.rig;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx=xx+dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ty=yy+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(L&lt;=<span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(check(tx,ty))&#123;</span><br><span class="line">                    vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">                    que.push(node&#123;tx,ty,L<span class="number">-1</span>,R&#125;);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(R&lt;=<span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(check(tx,ty))&#123;</span><br><span class="line">                    vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">                    que.push(node&#123;tx,ty,L,R<span class="number">-1</span>&#125;);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(check(tx,ty))&#123;</span><br><span class="line">                    vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">                    que.push(node&#123;tx,ty,L,R&#125;);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> r,c;<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;r,&amp;c);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;lmx,&amp;rmx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=bfs(r<span class="number">-1</span>,c<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>BFS&amp;DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C++</tag>
        <tag>BFS</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces1077C - Good Array</title>
    <url>/2019/03/31/Codeforces-1077C/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/CodeForces-1077C" rel="external nofollow noopener noreferrer" target="_blank">Good Array</a></p>
<p>题目大意就是对于一个有限数列，如果其中一个元素可以表示为数列中其他所有元素的和，则这个数列(数组)被称为Good Array。现在有一个数列a，请找出所有的元素，使得删去这些元素后这个数列为Good Array<br><a id="more"></a></p>
<p>思路:如果一个数列是Good Array,则一定是其他元素的和等于数列中最大的元素的值。故先排个序，然后用前缀和<script type="math/tex">O(n)</script>解决(注意要用long long)</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ll val;</span><br><span class="line">    ll id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line">node arr[<span class="number">2</span>*maxn];</span><br><span class="line">ll sum[<span class="number">2</span>*maxn];</span><br><span class="line">ll ans[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;mst(arr,<span class="number">0</span>);</span><br><span class="line">    mst(sum,<span class="number">0</span>);</span><br><span class="line">    mst(ans,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i].val;</span><br><span class="line">        arr[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+arr[i].val;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>;ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[n<span class="number">-2</span>]==arr[n<span class="number">-1</span>].val)</span><br><span class="line">                ans[cnt++]=arr[i].id;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[n<span class="number">-1</span>]-arr[<span class="number">1</span>].val==arr[n].val)</span><br><span class="line">                ans[cnt++]=arr[i].id;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[i<span class="number">-1</span>]==arr[n].val)</span><br><span class="line">                ans[cnt++]=arr[i].id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[i<span class="number">-1</span>]+sum[n<span class="number">-1</span>]-sum[i<span class="number">-1</span>]-arr[i].val==arr[n].val)</span><br><span class="line">                ans[cnt++]=arr[i].id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %lld"</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 149D Coloring Brackets</title>
    <url>/2019/07/30/CodeForces-149D-Coloring-Brackets/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/Ha807ab515a9047d3ac8f965971498456a.jpg" alt></p>
<p>Photo by <strong>eberhard grossgasteiger</strong> from <strong>Pexels</strong></p>
<a id="more"></a>
<p><a href="https://cn.vjudge.net/problem/CodeForces-149D" rel="external nofollow noopener noreferrer" target="_blank">Coloring Brackets</a></p>
<p>（区间dp好题！）</p>
<p>题目大意是说，给定一个保证配对的括号序列S，现在要对这些括号染上蓝色或红色，且需要满足以下三个要求:</p>
<ul>
<li>对于每个括号，要么染上红色，要么染上蓝色，要么不染色</li>
<li>对于每一对配对的括号，有且仅有一个括号被染色</li>
<li>任意两个相邻的括号都没有相同的颜色</li>
</ul>
<p>问一共有多少种染色方案。</p>
<p>思路是区间DP，用$dp[lef][rig][l][r]$表示对于子区间$S<em>{lef···rig}$，在左端括号颜色为$l$右端括号颜色为$r$的情况下，所能得到的染色方案数。如果$S</em>{lef}$和$S<em>{rig}$配对，则处理$S</em>{lef+1···rig-1}$，然后从$dp[lef+1][rig-1][i][j]$转移得到$dp[lef][rig][1][0]$，$dp[lef][rig][2][0]$，$dp[lef][rig][0][1]$，$dp[lef][rig][0][2]$。如果不配对，则找出区间$[lef,rig]$中和左括号配对的那个括号的下标$mat$，然后依次为区间断点来合并区间转移得到结果。此时的状态转移方程为</p>
<script type="math/tex; mode=display">
dp[lef][rig][i][j]=(dp[lef][rig][i][j]+dp[lef][mat][i][k]*dp[mat+1][rig][p][j])\ \%\ mod</script><p>关于如何找到左括号配对的右括号，只需要用个栈做一下预处理即可。左括号入栈，右括号将当前栈顶元素与右括号配对并弹栈。</p>
<p>最后只需要把$dp[1][len][0…2][0…2]$分别加起来即可得到答案。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">705</span>];</span><br><span class="line"><span class="keyword">int</span> match[<span class="number">705</span>];</span><br><span class="line">ll dp[<span class="number">705</span>][<span class="number">705</span>][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'('</span>)&#123;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            match[i]=stk.top();</span><br><span class="line">            match[stk.top()]=i;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    mst(dp,0);</span></span><br><span class="line">    <span class="keyword">if</span>(rig<span class="number">-1</span>==lef)&#123;</span><br><span class="line">        dp[lef][rig][<span class="number">1</span>][<span class="number">0</span>]=dp[lef][rig][<span class="number">0</span>][<span class="number">1</span>]=dp[lef][rig][<span class="number">2</span>][<span class="number">0</span>]=dp[lef][rig][<span class="number">0</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(match[lef]==rig)&#123;</span><br><span class="line">        solve(lef+<span class="number">1</span>,rig<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;        <span class="comment">//枚举左端颜色 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;    <span class="comment">//枚举右端颜色 </span></span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">1</span>)</span><br><span class="line">                    dp[lef][rig][<span class="number">1</span>][<span class="number">0</span>]=(dp[lef][rig][<span class="number">1</span>][<span class="number">0</span>]+dp[lef+<span class="number">1</span>][rig<span class="number">-1</span>][i][j])%mod;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">2</span>)</span><br><span class="line">                    dp[lef][rig][<span class="number">2</span>][<span class="number">0</span>]=(dp[lef][rig][<span class="number">2</span>][<span class="number">0</span>]+dp[lef+<span class="number">1</span>][rig<span class="number">-1</span>][i][j])%mod;</span><br><span class="line">                <span class="keyword">if</span>(j!=<span class="number">1</span>)</span><br><span class="line">                    dp[lef][rig][<span class="number">0</span>][<span class="number">1</span>]=(dp[lef][rig][<span class="number">0</span>][<span class="number">1</span>]+dp[lef+<span class="number">1</span>][rig<span class="number">-1</span>][i][j])%mod;</span><br><span class="line">                <span class="keyword">if</span>(j!=<span class="number">2</span>)</span><br><span class="line">                    dp[lef][rig][<span class="number">0</span>][<span class="number">2</span>]=(dp[lef][rig][<span class="number">0</span>][<span class="number">2</span>]+dp[lef+<span class="number">1</span>][rig<span class="number">-1</span>][i][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mat=match[lef];</span><br><span class="line">        solve(lef,mat);solve(mat+<span class="number">1</span>,rig);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//枚举颜色 </span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;<span class="number">3</span>;p++)&#123;</span><br><span class="line">                    <span class="comment">//枚举颜色 </span></span><br><span class="line">                        <span class="keyword">if</span>(k!=p||k==<span class="number">0</span>)&#123;        <span class="comment">//&lt;-</span></span><br><span class="line">                            dp[lef][rig][i][j]=(dp[lef][rig][i][j]+dp[lef][mat][i][k]*dp[mat+<span class="number">1</span>][rig][p][j])%mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">    init(len);</span><br><span class="line">    mst(dp,<span class="number">0</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    solve(<span class="number">1</span>,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">            ans=(ans+dp[<span class="number">1</span>][len][i][j])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>区间DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
        <tag>CodeForces</tag>
        <tag>好题！</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1374E1 - Reading Books (easy version)</title>
    <url>/2020/07/08/Codeforces-1374E1-Reading-Books-easy-version/</url>
    <content><![CDATA[<p><img src="https://pic.downk.cc/item/5f05d99d14195aa59424eb9e.jpg" alt></p>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>每次期末后的复建运动都格外痛苦（</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>题意是说，给定$n$本书，如果书都有属性$a,b,t$。如果$a=1$，则说明Alice喜欢读这本书，$0$则不喜欢；如果$b=1$，则说明Bob喜欢读这本书，$0$则不喜欢。$t$是每本书的代价。从中选出若干本书，这些书中Alice和Bob喜欢读的都不少于$k$本。问如何选择，才能使代价总和最小。</p>
<p>思路是贪心。记Alice和Bob都喜欢的书为11类，只有Alice喜欢的为10类，只有Bob喜欢的为01类。容易注意到，选择Alice和Bob都喜欢读的书性价比要更高一些。所以，我们首先对三种属性分别排序，如果当前取了$i$本11类的书，那么，对于Alice，我们要为她取10类和01类共$k-i$本书；Bob也是同理。如果发现10类或01类的书的数目小于$k-i$，则说明在取$i$本11类书的情况下，没有可行的方案。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a, b) memset((a), (b), sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef, mid, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid + 1, rig, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll t;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; nn) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t &lt; nn.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node allone[maxn];</span><br><span class="line">node A[maxn];</span><br><span class="line">node B[maxn];</span><br><span class="line">ll sum1[maxn];</span><br><span class="line">ll sum2[maxn];</span><br><span class="line">ll sum3[maxn];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mp.clear();</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> idx1, idx2, idx3;</span><br><span class="line">    idx1 = idx2 = idx3 = <span class="number">1</span>;</span><br><span class="line">    ll t_;</span><br><span class="line">    <span class="keyword">int</span> a_, b_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %d %d"</span>, &amp;t_, &amp;a_, &amp;b_);</span><br><span class="line">        <span class="keyword">if</span> (a_ &amp;&amp; b_)</span><br><span class="line">            allone[idx1++] = &#123; t_, a_, b_ &#125;;</span><br><span class="line">        <span class="keyword">if</span> (a_ &amp;&amp; !b_)</span><br><span class="line">            A[idx2++] = &#123; t_, a_, b_ &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!a_ &amp;&amp; b_)</span><br><span class="line">            B[idx3++] = &#123; t_, a_, b_ &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(allone + <span class="number">1</span>, allone + idx1);</span><br><span class="line">    sort(A + <span class="number">1</span>, A + idx2);</span><br><span class="line">    sort(B + <span class="number">1</span>, B + idx3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum1[i] = sum1[i - <span class="number">1</span>] + allone[i].t;</span><br><span class="line">        sum2[i] = sum2[i - <span class="number">1</span>] + A[i].t;</span><br><span class="line">        sum3[i] = sum3[i - <span class="number">1</span>] + B[i].t;</span><br><span class="line">    &#125;</span><br><span class="line">    ll inf = numeric_limits&lt;ll&gt;::max();</span><br><span class="line">    ll ans = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= min(k, idx1 - <span class="number">1</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = k - i;</span><br><span class="line">        <span class="keyword">if</span> (idx2 - <span class="number">1</span> &gt;= tmp &amp;&amp; idx3 - <span class="number">1</span> &gt;= tmp) &#123;</span><br><span class="line">            ans = min(ans, sum1[i] + sum2[k - i] + sum3[k - i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == inf) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Codeforces 1389 B&amp;C</title>
    <url>/2020/08/06/Codeforces-1389B-Array-Walk/</url>
    <content><![CDATA[<h2 id="B-Array-Walk"><a href="#B-Array-Walk" class="headerlink" title="B. Array Walk"></a>B. Array Walk</h2><p>题意：给定一个长度为$n$的序列，从下标1开始，走$k$步，其中最多$z$步向左。每走到一个位置就取一次这个位置的数。问可以取到的最大总和是多少。</p>
<a id="more"></a>
<p>思路：考虑dp，$dp[i][j]$表示走了$i$步，$j$步为向左时的最大总和。则当$dp[i][j]$可以由走了$i-1$步、现在向右走以及走了$i-1$步、现在向左走这两个状态转移而来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a, b) memset((a), (b), sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef, mid, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid + 1, rig, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> a[maxn], dp[maxn][<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;k, &amp;z);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= z; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + a[<span class="number">1</span> + i - <span class="number">2</span> * j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[<span class="number">1</span> + i - <span class="number">2</span> * j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= z; j++) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Good-String"><a href="#C-Good-String" class="headerlink" title="C. Good String"></a>C. Good String</h2><p>题意：如果将一个字符串循环左移一位与循环右移一位后，得到的两个新字符串相等，则称该字符串为good string。给定一个字符串$s$，问需要至少删除$s$中多少个字符，才能使其变成good string。</p>
<p>思路：容易发现，good string只有两种情况：1、整个字符串只有一种字符；2、字符串形如$ababab…$，且长度为偶数。对于第一种情况，只需要找出出现次数最多的字符即可；对于第二种情况，因为字符只有10种，暴力枚举一下可以组成good string的两种字符就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a, b) memset((a), (b), sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef, mid, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid + 1, rig, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        mst(cnt, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            cnt[s[i] - <span class="string">'0'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            maxi = <span class="built_in">max</span>(maxi, cnt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=len;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(l%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s[k]==i+<span class="string">'0'</span>) l++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s[k]==j+<span class="string">'0'</span>) l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(l&amp;<span class="number">1</span>) l--;</span><br><span class="line">                ans2=<span class="built_in">max</span>(ans2,l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf("ans2 = %d\n", ans2);</span></span><br><span class="line">        ans2 = len - ans2;</span><br><span class="line">        <span class="keyword">int</span> ans1 = len - maxi;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">min</span>(ans2, ans1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Codeforces Round #544 (Div. 3)</title>
    <url>/2019/03/23/Codeforces-Round-544-Div-3/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/1133/A" rel="external nofollow noopener noreferrer" target="_blank">A - Middle of the Contest</a><br><br>这没什么好说的了吧……<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">505</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h1,m1;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d:%d"</span>,&amp;h1,&amp;m1);</span><br><span class="line">    <span class="keyword">int</span> h2,m2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d:%d"</span>,&amp;h2,&amp;m2);</span><br><span class="line">    <span class="keyword">int</span> tot1=h1*<span class="number">60</span>+m1;</span><br><span class="line">    <span class="keyword">int</span> tot2=h2*<span class="number">60</span>+m2;</span><br><span class="line">    <span class="keyword">if</span>(tot1&gt;tot2)</span><br><span class="line">        swap(tot1,tot2);</span><br><span class="line">    <span class="keyword">int</span> sub=(tot2-tot1)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=tot1+sub;</span><br><span class="line">    <span class="keyword">int</span> h_ans=ans/<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> m_ans=ans%<span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d\n"</span>,h_ans,m_ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://codeforces.com/problemset/problem/1133/B" rel="external nofollow noopener noreferrer" target="_blank">B - Preparation for International Women’s Day</a><br><br>这题有必要说一下。首先对于两个数a,b，若要它们的和可以整除k，则有以下两种情况:</p>
<ul>
<li>1.a%k == 0且b%k == 0</li>
<li>2.(a%k+b%k)%k == 0</li>
</ul>
<p>做法是，首先用一个arr数组把输入的所有数%k的结果存起来，数组里面存的是余数所出现的次数。对于第一种情况，只需要用arr[0]去处理。而对于0以外的余数，则将arr[i]和arr[k-i]进行比较。若arr[i]！=arr[k-i],则ans+=min(arr[i],arr[k-i]);若arr[i]==arr[k-i],则ans+=arr[i](或者ans+=arr[k-i])。还需要考虑一种情况，如果i==k-i，则ans+=arr[i]。另外，还需要注意，如果arr[i]==arr[k-i]与i==k-i同时成立，很明显应该ans+=arr[i]。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    mst(arr,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">        arr[tmp%k]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    ans+=arr[<span class="number">0</span>]/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]!=arr[k-i])&#123;</span><br><span class="line">            ans+=<span class="built_in">min</span>(arr[i],arr[k-i]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==k-i)&#123;        <span class="comment">//&lt;-1</span></span><br><span class="line">            ans+=arr[i]/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==arr[k-i])&#123;        <span class="comment">//&lt;-2</span></span><br><span class="line">            ans+=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//1和2不能颠倒，因为如果两者都成立，则应该执行1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codeforces.com/problemset/problem/1133/C" rel="external nofollow noopener noreferrer" target="_blank">C - Balanced Team</a><br> </p>
<p>先排个序，然后对于学生i，二分找出第一个比a[i]+5大的数的下标，然后以此维护最大值</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-1</span>;<span class="keyword">int</span> t1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=a[i]+<span class="number">5</span>;</span><br><span class="line">        pos=upper_bound(a,a+n,tmp)-a;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,pos-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codeforces.com/problemset/problem/1133/D" rel="external nofollow noopener noreferrer" target="_blank">D - Zero Quantity Maximization</a><br> </p>
<p>用map记录每一个d出现的次数，然后再找出value值最大的d。要注意的是,当a==0&amp;&amp;b==0时，d一定存在且为任意实数，故ans++；当a==0&amp;&amp;b!=0时，无解，直接跳过。<del>昨晚TLE了好几发居然是因为数组开小了OTZ</del></p>
<p>代码如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">int</span> ok=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>&amp;&amp;a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            ok++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b!=<span class="number">0</span>&amp;&amp;a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> tmp=(-b)/a[i];</span><br><span class="line">        mp[tmp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it=mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();it++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,it-&gt;second);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+ok);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://codeforces.com/problemset/problem/1133/E" rel="external nofollow noopener noreferrer" target="_blank">E - K Balanced Teams</a><br> </p>
<p>C题的升级版。一开始是用的贪心，然后就wa了……正确方法是dp，但我不会OTZ……<del>遂看题解</del>。</p>
<p>首先当然是排个序</p>
<p>然后，状态转移方程是这个👇</p>
<center><b>dp[i][j]=max(dp[i-1][j],dp[pos-1][j-1]+i-pos+1)</b></center>

<p>dp[i][j]指的是前i个人组成j个队伍最多可以挑选多少人；pos是i左侧第一个满足<br>arr[i]-arr[pos]的点的下标。</p>
<p>代码如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dp[i][j]=max(dp[i-1][j],dp[pos-1][j-1]+i-pos+1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    sort(arr+<span class="number">1</span>,arr+<span class="number">1</span>+n);</span><br><span class="line">    mst(dp,<span class="number">0</span>);dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pos=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(arr[i]-arr[pos]&gt;<span class="number">5</span>&amp;&amp;pos&lt;=n)        pos++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(k,i);j++)</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[pos<span class="number">-1</span>][j<span class="number">-1</span>]+i-pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[n][i]); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces1131B - Draw!</title>
    <url>/2019/04/25/Codeforces1131B-Draw/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1X.IlSNTpK1RjSZFMq6zG_VXaS.jpg" alt></p>
<p>Photo by Angela Huang from Pexels</p>
<a id="more"></a>
<p><a href="https://cn.vjudge.net/problem/CodeForces-1131B" rel="external nofollow noopener noreferrer" target="_blank">Draw!</a></p>
<p>emmmmm一道不知道怎么归类的题目，大概应该归类为思维题？</p>
<p>题目大意是说给出一场球赛中两个队伍几个时间点的比分情况，要你根据这几个比分情况来计算整个比赛过程中最多可能有多少次平局。</p>
<p>大致分析一下样例即可得到思路：对于一支队伍，依次取两个相邻时间点上的得分，将这两个得分分别看作是一个区间的左端点和右端点，那么对于两个相邻的时间点，我们就可以得到两个区间（分别属于两支队伍），然后求一下两个区间的交集的长度，答案即为所有符合要求的交集的长度。要注意的是，需要设一个rightest变量来表示当前当前已经计算到的“最右端的数”，从而避免重复计算。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> a1,b1;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a1&gt;&gt;b1;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>))&#123;</span><br><span class="line">        a[<span class="number">0</span>]=b[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>]=a1;b[<span class="number">1</span>]=b1;</span><br><span class="line">        pos=<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        a[<span class="number">0</span>]=b[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        pos=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++,pos++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[pos]&gt;&gt;b[pos];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightest=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> lef1=a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> lef2=b[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> rig1=a[i];</span><br><span class="line">        <span class="keyword">int</span> rig2=b[i];</span><br><span class="line">        <span class="keyword">int</span> lef=<span class="built_in">max</span>(lef1,lef2);</span><br><span class="line">        <span class="keyword">int</span> rig=<span class="built_in">min</span>(rig1,rig2);</span><br><span class="line">        <span class="keyword">while</span>(lef&lt;=rightest)</span><br><span class="line">            lef++;</span><br><span class="line">        <span class="keyword">if</span>(rig-lef&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            rightest=rig;</span><br><span class="line">            ans+=rig-lef+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces1136D - Nastya Is Buying Lunch</title>
    <url>/2019/04/28/Codeforces1136D-Nastya-Is-Buying-Lunch/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/CodeForces-1136D" rel="external nofollow noopener noreferrer" target="_blank">Nastya Is Buying Lunch</a></p>
<p><img src="https://ae01.alicdn.com/kf/HTB1lkBjXfxj_uVjSZFqq6yboFXao.jpg" alt>Photo from Pexels</p>
<a id="more"></a>
<p>题目大意是说有n个数1到n，它们按照一定的顺序排列。然后现在有m个数对$(u,v)$，意思是说，如果数字u排在数字v的前面(左边)，且两个数字相邻，那么两个数字就可以交换位置。问，对于排在最后的数字，通过这样的交换位置的操作，这个数字最多可以前进多少个位置(向左移动多少次)。</p>
<p>emmmmmmm比赛时真的没想出来……<del>后期补题的时候也没想出来OTZ</del>，于是不得不去看题解hhhhh</p>
<p>先说说我的想法:首先这题第一感觉是一道贪心题，那我们是否可以通过找到一个最长的“连续交换序列”来实现最后一个数尽可能多地向前移动呢？所谓的连续交换序列就是说，在这个序列里，前后两个交换操作是连续的，执行完前一个操作后恰好可以执行下一个操作…….emmmmmm事实证明这是个非常错误的想法，而且也不好实现</p>
<p>所以正确的做法应该是，记录每一个数后面有多少个可以与他交换的数，用一个cnt数组来记录。对于一个数，如果最后一个数$x=que[i]$与这个数的距离，即$n-ans-i$($ans$是最后一个数目前所移动了的距离)刚好和$cnt[x]$相等，那就说明一定有一种操作可以将x换到这个数当前所在的位置,这是就ans++;如果不相等，那么更新以下cnt数组。非常巧妙的做法呢。</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> que[<span class="number">3</span>*maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[<span class="number">3</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">3</span>*maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;mst(cnt,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;que[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        vec[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec[que[n]].<span class="built_in">size</span>();i++)</span><br><span class="line">        cnt[vec[que[n]][i]]++;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[que[i]]==n-ans-i)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vec[que[i]].<span class="built_in">size</span>();j++)</span><br><span class="line">                cnt[vec[que[i]][j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-2612-Find A Way(BFS)</title>
    <url>/2019/01/26/HDOJ-2612-Find-A-Way-BFS/</url>
    <content><![CDATA[<p>&emsp;&emsp; 这是一道稍微有点特殊的题，特殊之处在于它需要使用2次广搜。刚开始做的时候思路是把所有肯德基的位置记录下来，然后以每一个肯德基的位置为终点来bfs。。。。。。然后就TLE了OTZ。。。。。。后来发现只需要只需要用两次bfs，把整个地图走遍，如果走到的地方是肯德基，就记录此时的步数，然后两个最小值相加乘以11就行了。<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">char</span> nbo[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> kfc_dis1[maxn][maxn],kfc_dis2[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> yif[<span class="number">1</span>][<span class="number">2</span>],mer[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> stp;</span><br><span class="line">&#125;pos;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pos xxx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((nbo[xxx.row][xxx.col]==<span class="string">'M'</span>)||(nbo[xxx.row][xxx.col]==<span class="string">'Y'</span>)||(nbo[xxx.row][xxx.col]==<span class="string">'#'</span>)||</span><br><span class="line">       (xxx.row&gt;=n)||(xxx.row&lt;<span class="number">0</span>)||(xxx.col&gt;=m)||(xxx.col&lt;<span class="number">0</span>)||(vis[xxx.row][xxx.col]==<span class="number">1</span>))        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> kcnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> stx,<span class="keyword">int</span> sty)</span>        <span class="comment">//x为行,y为列 </span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    kcnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pos&gt; que;</span><br><span class="line">    pos now,next,sta;</span><br><span class="line">    sta.row=stx;sta.col=sty;sta.stp=<span class="number">0</span>;</span><br><span class="line">    que.push(sta);</span><br><span class="line">    vis[stx][sty]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;    </span><br><span class="line">        now=que.front();</span><br><span class="line">        <span class="keyword">if</span>(nbo[now.row][now.col]==<span class="string">'@'</span>)    </span><br><span class="line">            kfc_dis2[now.row][now.col]=now.stp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;    </span><br><span class="line">            next.row=now.row+dir[i][<span class="number">0</span>];</span><br><span class="line">            next.col=now.col+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(check(next))</span><br><span class="line">            &#123;    </span><br><span class="line">                vis[next.row][next.col]=<span class="number">1</span>;</span><br><span class="line">                next.stp=now.stp+<span class="number">1</span>;</span><br><span class="line">                que.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">memset</span>(nbo,<span class="number">0</span>,<span class="keyword">sizeof</span>(nbo));<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(kfc_dis1,<span class="number">0</span>,<span class="keyword">sizeof</span>(kfc_dis1));<span class="built_in">memset</span>(kfc_dis2,<span class="number">0</span>,<span class="keyword">sizeof</span>(kfc_dis2));</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>,<span class="built_in">step</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        getchar(); </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;nbo[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(nbo[i][j]==<span class="string">'M'</span>)        &#123;mer[<span class="number">0</span>][<span class="number">0</span>]=i;mer[<span class="number">0</span>][<span class="number">1</span>]=j;&#125;</span><br><span class="line">                <span class="keyword">if</span>(nbo[i][j]==<span class="string">'Y'</span>)        &#123;yif[<span class="number">0</span>][<span class="number">0</span>]=i;yif[<span class="number">0</span>][<span class="number">1</span>]=j;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=INT_MAX;</span><br><span class="line">        bfs(mer[<span class="number">0</span>][<span class="number">0</span>],mer[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">memcpy</span>(kfc_dis1,kfc_dis2,<span class="keyword">sizeof</span>(kfc_dis2));            <span class="comment">//kfc_cnt1:mer到各个肯德基距离,kfc_cnt2:yif到各个肯德基距离 </span></span><br><span class="line">        <span class="built_in">memset</span>(kfc_dis2,<span class="number">0</span>,<span class="keyword">sizeof</span>(kfc_dis2));</span><br><span class="line">        bfs(yif[<span class="number">0</span>][<span class="number">0</span>],yif[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                <span class="keyword">if</span>(ans&gt;kfc_dis1[i][j]+kfc_dis2[i][j]&amp;&amp;kfc_dis1[i][j]&amp;&amp;kfc_dis2[i][j])</span><br><span class="line">                    ans=kfc_dis1[i][j]+kfc_dis2[i][j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="number">11</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;另外，在hdoj的讨论版里有人说Y和M不能走，但经过尝试，”Y和M可以走”以及“Y和M不可以走”这两种写法都是可以AC的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>BFS&amp;DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1002-A+B Problem</title>
    <url>/2019/01/26/HDOJ1002-A+B-Problem/</url>
    <content><![CDATA[<p>大数相加，方法就是用字符串存数字，然后模拟手算的方法计算。虽是水题，但有些细节还是要注意。<br><a id="more"></a><br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">1010</span>],b[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">char</span> rsl[<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=str[i];</span><br><span class="line">        str[i]=str[len-i<span class="number">-1</span>];</span><br><span class="line">        str[len-i<span class="number">-1</span>]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> a[],<span class="keyword">char</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stop</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(rsl,<span class="string">'0'</span>,<span class="keyword">sizeof</span>(rsl));</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">max</span>(<span class="built_in">strlen</span>(a),<span class="built_in">strlen</span>(b));</span><br><span class="line">    a[<span class="built_in">strlen</span>(a)]=b[<span class="built_in">strlen</span>(b)]=<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((a[i]-<span class="string">'0'</span>)+(b[i]-<span class="string">'0'</span>)+(rsl[i]-<span class="string">'0'</span>)&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            rsl[i]=(((a[i]-<span class="string">'0'</span>)+(b[i]-<span class="string">'0'</span>)+(rsl[i]-<span class="string">'0'</span>))%<span class="number">10</span>)+<span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//            printf("ans[i]=%c\n",rsl[i]);</span></span><br><span class="line">            rsl[i+<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">stop</span>=i+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//            printf("ans[i+1]=%c\n",rsl[i+1]);</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rsl[i]=(a[i]-<span class="string">'0'</span>+b[i]-<span class="string">'0'</span>+rsl[i]-<span class="string">'0'</span>)+<span class="string">'0'</span>;</span><br><span class="line">            <span class="built_in">stop</span>=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rsl[<span class="built_in">stop</span>+<span class="number">1</span>]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> la,lb;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> test=<span class="number">0</span>;test&lt;t;test++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="string">'0'</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="string">'0'</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,b);</span><br><span class="line">        la=<span class="built_in">strlen</span>(a);lb=<span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="comment">//    int len=max(strlen(a),strlen(b));</span></span><br><span class="line">        rev(a);rev(b);</span><br><span class="line">        add(a,b);</span><br><span class="line">        rev(rsl);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,test+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=la<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" + "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lb<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" = "</span>);</span><br><span class="line">        <span class="built_in">puts</span>(rsl);</span><br><span class="line">        <span class="keyword">if</span>(test!=t<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>入门</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1171-Big Event in HDU（多重背包做法）</title>
    <url>/2019/02/13/HDOJ1171-Big-Event-in-HDU/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1171" rel="external nofollow noopener noreferrer" target="_blank">HDOJ1171</a><br>这道题之前是用01背包做的，现在用多重背包的做法解决。这其实更符合题意（个人认为）</p>
<a id="more"></a>
<p>代码如下：</p>
<p>版本三(二进制优化的多重背包，93ms)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">5</span>; </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">5005</span>],m[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_one</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val,<span class="keyword">int</span> vtot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=vtot;j&gt;=cost;j--)</span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-cost]+val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val,<span class="keyword">int</span> vtot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=cost;j&lt;=vtot;j++)</span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-cost]+val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiple</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val,<span class="keyword">int</span> num,<span class="keyword">int</span> vtot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(cost*num&gt;=vtot)</span><br><span class="line">    &#123;</span><br><span class="line">        complete(cost,val,vtot);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        zero_one(k*cost,k*val,vtot);</span><br><span class="line">        num-=k;</span><br><span class="line">        k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zero_one(num*cost,num*val,vtot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF&amp;&amp;n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        mst(v,<span class="number">0</span>);mst(m,<span class="number">0</span>);mst(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val,num;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;val,&amp;num);</span><br><span class="line">            sum+=val*num;</span><br><span class="line">            v[i]=val;m[i]=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            multiple(v[i],v[i],m[i],sum/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> a=sum-dp[sum/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> b=dp[sum/<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二进制优化的模板→<a href="https://blog.csdn.net/mystery_guest/article/details/51878140" rel="external nofollow noopener noreferrer" target="_blank">多重背包二进制优化模板分析</a></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>多重背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU5446-Unknown Treasure(卢卡斯定理，中国剩余定理)</title>
    <url>/2019/01/28/HDOJ5446-Unknown-Treasure/</url>
    <content><![CDATA[<p>题目链接:<a href="https://cn.vjudge.net/problem/HDU-5446" rel="external nofollow noopener noreferrer" target="_blank">Unknown Treasure</a></p>
<p><img src="https://pic.superbed.cn/item/5c4e95c85f3e509ed97caf5f" alt></p>
<p>这道题求得实际上是C(n,m)%M,M=p1·p2·p3···pk。又因为pi都是素数，故可用卢卡斯定理。但这里不可以直接用Lucas，因为Lucas的使用条件是“C(n,m)很大，但p不太大，同时p为素数”，而这里的M可能会很大。故我们可以先求C(n,m)%p1,C(n,m)%p2,C(n,m)%pk，然后再利用中国剩余定理得到最终答案。</p>
<p>代码如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">//从n个苹果中挑出m个相互不同的苹果</span></span><br><span class="line"><span class="function">LL <span class="title">mulq</span><span class="params">(LL a,LL b,LL m)</span>        <span class="comment">//(a*b)%m</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=(ans+a)%m;</span><br><span class="line">        a=(a+a)%m;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">powq</span><span class="params">(LL a,LL b,LL mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;a%=mod;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL x,LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> powq(x,p<span class="number">-2</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">comb</span><span class="params">(LL n,LL m,LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m||m&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL up=<span class="number">1</span>;</span><br><span class="line">    LL down=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=n-m+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        up=(up*i)%p;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        down=(down*i)%p;</span><br><span class="line">    <span class="keyword">return</span> up*inv(down,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lucas</span><span class="params">(LL a,LL b,LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b?<span class="number">1</span>:lucas(a/p,b/p,p)*comb(a%p,b%p,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">china</span><span class="params">(<span class="keyword">int</span> k,LL a[],LL m[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL M=<span class="number">1</span>;LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        M*=m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL tmp=M/m[i];        <span class="comment">//tmp==&gt;mi        </span></span><br><span class="line">        ans=(ans+mulq(tmp*inv(tmp,m[i]),a[i],M))%M;        <span class="comment">//ti==&gt;ti*mi=1 (mod mi)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans+M)%M;            <span class="comment">//通解为kM+∑(i=0,k)(ai*ti*Mi) </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL t,k;</span><br><span class="line">    LL n,m;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    LL r[<span class="number">15</span>],md[<span class="number">15</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="keyword">sizeof</span>(r));</span><br><span class="line">        <span class="built_in">memset</span>(md,<span class="number">0</span>,<span class="keyword">sizeof</span>(md));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            LL tmp=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tmp);</span><br><span class="line">            md[cnt]=tmp;</span><br><span class="line">            r[cnt++]=lucas(n,m,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        LL pro=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)    </span><br><span class="line">            pro*=md[i];</span><br><span class="line">        LL ans=china(k,r,md);        <span class="comment">//为什么答案就是中国剩余定理求出的值？不应该再模上乘积吗? </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans%pro);    <span class="comment">//因为中国剩余定理在计算时已经算了这个模;中国剩余定理求出的是解集中的最小解，即c(m,m)%M;</span></span><br><span class="line">                                    <span class="comment">//当然，如果在main中再模一次M,也是可以AC的    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3037-Saving Beans(卢卡斯定理，组合数)</title>
    <url>/2019/01/27/HDOJ3037-Saving-Beans-%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%8C%E7%BB%84%E5%90%88%E6%95%B0/</url>
    <content><![CDATA[<p>&emsp;&emsp;题目链接：<a href="https://cn.vjudge.net/problem/HDU-3037" rel="external nofollow noopener noreferrer" target="_blank">HDOJ-3037</a></p>
<p>&emsp;&emsp;这道题关键之处在于式子的推导，只要把式子推导出来了，就可以直接套用Lucas的模板，从而求出答案。那么，公式要怎么求呢？</p>
<p>&emsp;&emsp;首先，问题要求的是从n棵树中收集不超过m个果实(原本以为是将不多于m个果实放到n棵树中……这题目表达有问题啊！)。也就是说，问题其实是求方程x1+x2+x3+···+xn=m的非负整数解的个数。那么我们要怎求呢？<br>&emsp;&emsp;首先，如果是求正整数解的个数，那我们可以直接用最简单的隔板法，即C(m-1,n-1);但这里求的是非负整数解，也就是说x1，x2，···,xn中的一个或多个可以为0。这种情况下，我们仍可以用隔板法来计算。方法是，将求非负整数解这一个问题转化为求正整数解，也就是将每一个x(x1,x2,···,xm)都加上1，构造一个新的方程y1+y2+···+yn=m(yi=xi+1)。显然，由于方程是线性的，故新方程的正整数解的个数等于原方程的非负整数解的个数。而新方程的解的个数为C((m+n)-1,n-1)=C((m+n)-1,m)。</p>
<p>&emsp;&emsp;而我们要求的实际上是(∑(i=0,m)C(m+n-1,i))%p，根据公式C(n,k)=C(n-1,k-1)+C(n-1,k)(上取大，下加一),可得到(∑(i=0,m)C(m+n-1,i))%p=C(m+n,m)%p。又因为p为质数，故用Lucas即可。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">powq</span><span class="params">(ll a,ll b,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;a%=p;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=(ans*a)%p;</span><br><span class="line">        a=(a*a)%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> powq(a,p<span class="number">-2</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">comb</span><span class="params">(ll n,ll m,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m)        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll up=<span class="number">1</span>;</span><br><span class="line">    ll down=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n-m+<span class="number">1</span>;i&lt;=n;i++)        up=(up*i)%p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)        down=(down*i)%p;</span><br><span class="line">    <span class="keyword">return</span> up*inv(down,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lucas</span><span class="params">(ll n,ll m,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !n?<span class="number">1</span>:lucas(n/p,m/p,p)*comb(n%p,m%p,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n,p;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;n,&amp;m,&amp;p);     </span><br><span class="line">        ll ans=lucas(n+m,n,p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2602 - Bone Collector</title>
    <url>/2019/02/17/HDOJ2602-Bone-Collector/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-2602" rel="external nofollow noopener noreferrer" target="_blank">Bone Collector</a></p>
<p>&emsp;&emsp;一道01背包模板题，套模板即可<br><a id="more"></a><br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>; </span><br><span class="line"><span class="keyword">int</span> value[maxn],w[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,vtot;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;vtot);</span><br><span class="line">        <span class="built_in">memset</span>(value,<span class="number">0</span>,<span class="keyword">sizeof</span>(value));<span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="keyword">sizeof</span>(w));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;value[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=vtot;j&gt;=w[i];j--)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+value[i]);</span><br><span class="line">        <span class="keyword">int</span> ans=dp[vtot];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1018 - Big Number</title>
    <url>/2019/02/24/HDU1018-Big-Number/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-1018" rel="external nofollow noopener noreferrer" target="_blank">Big Number</a></p>
<p>&emsp;&emsp;直接套用stirling数的公式即可。关于strling数，可参考下图</p>
<p><img src="https://pic.superbed.cn/item/5c72a85b3a213b0417767d95" alt><br><a id="more"></a><br>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> e=<span class="number">2.718281828459</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;log10(103)&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        ans=(<span class="keyword">int</span>)(<span class="built_in">floor</span>((<span class="built_in">log10</span>((<span class="number">2</span>*pi*n)))/<span class="number">2</span>+n*<span class="built_in">log10</span>(n/e))+<span class="number">1</span>);        <span class="comment">//stirling公式 </span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**/</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1171 - Big Event in HDU</title>
    <url>/2019/02/17/HDU1171-Big-Event-in-HDU/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-1171" rel="external nofollow noopener noreferrer" target="_blank">Big Event in HDU</a></p>
<p>&emsp;&emsp;这道题是让我们将设备根据价值尽可能地平均分成两半，其实就是把设备的价值总和平分成两个部分，然后以此为背包，将这个背包尽可能填满。因为这里的“体积”和“价值”都是设备的价值，所以其实就是求价值的最大值。题目还要求输出时，大的在前面，小的在后面，这可以利用整除的特性做到，因为一个整数a整除2得到的结果一定是小于或等于a/2(非整除)的。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF&amp;&amp;n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">int</span> half=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">int</span> val,temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;val,&amp;temp);</span><br><span class="line">            <span class="keyword">while</span>(temp--)</span><br><span class="line">            &#123;</span><br><span class="line">                v[idx++]=val;</span><br><span class="line">                half+=val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp=half;</span><br><span class="line">        half/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;idx;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=half;j&gt;=v[i];j--)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+v[i]);</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        a=tmp-dp[half];</span><br><span class="line">        b=dp[half];</span><br><span class="line">      <span class="comment">//cout&lt;&lt;max(a,b)&lt;&lt;" "&lt;&lt;min(a,b)&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1248 - 寒冰王座</title>
    <url>/2019/02/22/HDU1248-%E5%AF%92%E5%86%B0%E7%8E%8B%E5%BA%A7/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-1248" rel="external nofollow noopener noreferrer" target="_blank">寒冰王座</a></p>
<a id="more"></a>
<p>&emsp;&emsp;套用模板即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> money[<span class="number">5</span>]=&#123;<span class="number">150</span>,<span class="number">200</span>,<span class="number">350</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        mst(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=money[i];j&lt;=n;j++)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-money[i]]+money[i]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n-dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>完全背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1301 - Jungle Roads</title>
    <url>/2019/02/27/HDU1301-Jungle-Roads/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-1301" rel="external nofollow noopener noreferrer" target="_blank">Jungle Roads</a></p>
<p>套用Kruskal或Prim的模板即可。这里我用的时Kruskal。</p>
<a id="more"></a>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,cost; </span><br><span class="line">&#125;edge;</span><br><span class="line">edge arr[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge e1,edge e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.cost&lt;e2.cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        pre[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==pre[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> pre[x]=findr(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rsl=<span class="number">0</span>;<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fx=findr(arr[i].from);</span><br><span class="line">        <span class="keyword">int</span> fy=findr(arr[i].to);</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[fx]=fy;</span><br><span class="line">            rsl+=arr[i].cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rsl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n)</span><br><span class="line">    &#123;    </span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="keyword">char</span> ch,ch1;</span><br><span class="line">            <span class="keyword">int</span> k,aacm;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;ch&gt;&gt;k;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">            &#123;    </span><br><span class="line">                edge tmp;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;ch1&gt;&gt;aacm;</span><br><span class="line">                getchar();</span><br><span class="line">                tmp.from=ch-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">                tmp.to=ch1-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">                tmp.cost=aacm;</span><br><span class="line">                arr[cnt++]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr,arr+cnt,cmp);</span><br><span class="line">        <span class="keyword">int</span> ans=kruskal();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>Kruskal</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1811 - Rank of Tetris</title>
    <url>/2019/03/21/HDU1811-Rank-of-Tetris/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-1811" rel="external nofollow noopener noreferrer" target="_blank">Rank of Tetris</a><br><br></p>
<p>&emsp;&emsp;根据题单的提示，这是一道拓补排序+并查集的题目，然而我并不会拓补排序……所以这里先写一下拓补排序相关的东西吧……</p>
<p>&emsp;&emsp;首先，拓补排序是对一系列有先后顺序的“活动”的排序。何为“有先后顺序的‘活动’”？举个例子，假如现在某人要穿衣服，那他必须要先穿内衣再穿中间的毛衣，最后再穿外套。拓补排序就是使用有向无环图(DAG)来对这些有先后顺序的活动进行排序，得到一个可行的顺序。对于同一系列的活动，可能有多于一种顺序可以使他们满足拓补排序。这跟穿衣服时可以先穿裤子再穿毛衣然后再穿外套，也可以先穿毛衣再穿裤子然后穿外套是一样的。</p>
<p>&emsp;&emsp;拓补排序的实现：先找出入度为0的点，然后将这个点以及与这个点相连的边删除，并将与这个点直接相连的点的入度都减一。再找出当前入度为0的点，重复上述过程…….当所有点的入度都为0时，说明所有的点都已经被安排了一个拓补序，拓补排序完成。如果不能使所有点的入度都为0，则可以判断当前这个图不是DAG。因此，拓补排序还可以用来判断一个有向图是否有环</p>
<p>&emsp;&emsp;具体到这道题。思路是，对于rating相等的两个点，比如说a和b，因为它们之间的序号一定不一样，所以两者之间一定能够连接一条有向边。可是如果接下来又出现了一个b = c呢？那b和c之间也要连一条有向边。不仅如此，a和c之间也要连一条有向边。所以如果出现了a = b = c = d = e = …的情况，这个图就会很复杂。所以我们可以用并查集将那些rating相等的点都连接起来，然后将他们的根节点作为他们的代表元素，即将这些点看成是一个点。然后再用拓补排序判一下环即可。</p>
<p>&emsp;&emsp;需要注意的细节是，如果之前已经出现了a = b，往后可能会出现a &gt; b或者a &lt; b，这是要判断为CONFLICT</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="comment">//n个点，m条边</span></span><br><span class="line"><span class="comment">//将'='的点用并查集聚合为一个点</span></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> deg[<span class="number">2</span>*maxn];        <span class="comment">//记录每个点的入度</span></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line">edge edges[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        pre[i]=i;</span><br><span class="line">    mst(head,<span class="number">-1</span>);mst(deg,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges[tot].to=v;</span><br><span class="line">    edges[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">    deg[v]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==pre[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> pre[x]=findr(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">int</span> root_cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> in_que_cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[i]==i)&#123;</span><br><span class="line">            root_cnt++;</span><br><span class="line">            <span class="keyword">if</span>(deg[i]==<span class="number">0</span>)</span><br><span class="line">                que.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(que.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        in_que_cnt++;</span><br><span class="line">        <span class="keyword">int</span> fro=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[fro];i!=<span class="number">-1</span>;i=edges[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=findr(edges[i].to);</span><br><span class="line">            deg[tmp]--;</span><br><span class="line">            <span class="keyword">if</span>(deg[tmp]==<span class="number">0</span>)</span><br><span class="line">                que.push(tmp);        <span class="comment">//为什么这里不需要将入队次数++?</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(in_que_cnt&lt;root_cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;        <span class="comment">//冲突(有环)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!flag)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;        <span class="comment">//不可确定关系</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;        <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],ch[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %c %d"</span>,&amp;a[i],&amp;ch[i],&amp;b[i]);</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">if</span>(ch[i]==<span class="string">'='</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> fa=findr(a[i]);</span><br><span class="line">                <span class="keyword">int</span> fb=findr(b[i]);</span><br><span class="line">                <span class="keyword">if</span>(fa!=fb)        <span class="comment">//若rating相等，则合并，因为a和b的序号</span></span><br><span class="line">                                <span class="comment">//一定不一致，绝对可以比出大小</span></span><br><span class="line">                    pre[fa]=fb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> fa=findr(a[i]);</span><br><span class="line">            <span class="keyword">int</span> fb=findr(b[i]);</span><br><span class="line">            <span class="keyword">if</span>(ch[i]!=<span class="string">'='</span>&amp;&amp;fa==fb)&#123;</span><br><span class="line">                ans=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch[i]==<span class="string">'&lt;'</span>)&#123;        <span class="comment">//a &lt; b</span></span><br><span class="line">                add_edge(findr(b[i]),findr(a[i]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch[i]==<span class="string">'&gt;'</span>)&#123;</span><br><span class="line">                add_edge(findr(a[i]),findr(b[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">0</span>)</span><br><span class="line">            ans=topo();</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"CONFLICT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"UNCERTAIN"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"OK"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>拓补排序</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>拓补排序</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1864 - 最大报销额</title>
    <url>/2019/02/18/HDU1864-%E6%9C%80%E5%A4%A7%E6%8A%A5%E9%94%80%E9%A2%9D/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-1864" rel="external nofollow noopener noreferrer" target="_blank">最大报销额</a></p>
<p>&emsp;&emsp;这道题有两个需要注意的地方：一是题目说的“每项”其实是“每类”，也就是A类,B类和C类，而不是每个物品……(这题目表述有问题啊！)；二是在计算时要将所有的数据扩大100倍然后再转为int，计算出最后结果后再缩小为原来的倍率，否则无法用钱数来做背包(浮点数无法作为数组下标)。</p>
<a id="more"></a>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">3000005</span>];</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> q;<span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;q&gt;&gt;n)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)        <span class="keyword">break</span>;</span><br><span class="line">        q*=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> qtmp=(<span class="keyword">int</span>)q;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));<span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">        <span class="keyword">bool</span> flag;<span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">char</span> ch;<span class="keyword">double</span> a,b,c,tmp;</span><br><span class="line">            <span class="keyword">int</span> num;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;num;getchar();</span><br><span class="line">            a=b=c=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(num--)</span><br><span class="line">            &#123;    </span><br><span class="line">                tmp=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%c:%lf"</span>,&amp;ch,&amp;tmp);<span class="keyword">char</span> c=getchar();</span><br><span class="line">                tmp*=<span class="number">100</span>;</span><br><span class="line">                <span class="keyword">if</span>(ch==<span class="string">'A'</span>)</span><br><span class="line">                    a+=tmp;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'B'</span>)</span><br><span class="line">                    b+=tmp;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'C'</span>)</span><br><span class="line">                    c+=tmp;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                    sum+=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">100000</span>||a&gt;<span class="number">60000</span>||b&gt;<span class="number">60000</span>||c&gt;<span class="number">60000</span>)</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                m[idx++]=(<span class="keyword">int</span>)sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=idx;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=qtmp;j&gt;=m[i];j--)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-m[i]]+m[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,dp[qtmp]/<span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2067 - 小兔的棋盘 </title>
    <url>/2019/02/24/HDU2067-%E5%B0%8F%E5%85%94%E7%9A%84%E6%A3%8B%E7%9B%98/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-2067" rel="external nofollow noopener noreferrer" target="_blank">小兔的棋盘</a></p>
<p>&emsp;&emsp;这道题有两种方法，一是dp，二是用卡特兰数(事实上我觉得dp是很自然的想法)</p>
<p>&emsp;&emsp;先说dp。对于棋盘的第0行(从下往上、从左往右数),除了(0,0)外，所有的点都只能由左边走来；对于棋盘的第0列，除了(0,0)外，所有的点都只能由左边走来。而对于对角线上的点，因为不能跨越对角线，所以这些点都只能由下边走来。而以上三种情况都不符合的点，则可以由左边或下边的点走来。故有一下dp代码：<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">35</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">35</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)</span><br><span class="line">                d[i][j]+=d[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                d[i][j]+=d[i<span class="number">-1</span>][j]+d[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>完整版的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll d[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    freopen(<span class="string">"rabbit.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    mst(d,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;=<span class="number">35</span>;col++)</span><br><span class="line">        d[<span class="number">0</span>][col]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;=<span class="number">35</span>;row++)</span><br><span class="line">        d[row][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">35</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">35</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)</span><br><span class="line">                d[i][j]+=d[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                d[i][j]+=d[i<span class="number">-1</span>][j]+d[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp();</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">35</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %lld %lld\n"</span>,++kase,i,d[i][i]*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第二种方法，卡特兰数。事实上我完全不知道为什么这题可以用卡特兰数来解，网上的题解说的是“细心观察，我们可以发现这道题恰好符合卡特兰数”(……)。那我们就用一下吧……</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll cata[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_catalan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cata[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">35</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i<span class="number">-1</span>;j++)</span><br><span class="line">            cata[i]+=cata[j]*cata[i-j<span class="number">-1</span>];            <span class="comment">//抄公式。。。 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    mst(cata,<span class="number">0</span>);get_catalan();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">-1</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        kase++;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;kase&lt;&lt;<span class="string">" "</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="number">2</span>*cata[n]&lt;&lt;<span class="built_in">endl</span>;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关于卡特兰数，可以看这个：</p>
<p><img src="https://pic.superbed.cn/item/5c72ad323a213b041776b839" alt></p>
<p><img src="https://pic.superbed.cn/item/5c72ad563a213b041776b9f8" alt></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2191 - 悼念512汶川大地震遇难同胞——珍惜现在，感恩生活</title>
    <url>/2019/02/22/HDU2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87%E9%81%87%E9%9A%BE%E5%90%8C%E8%83%9E%E2%80%94%E2%80%94%E7%8F%8D%E6%83%9C%E7%8E%B0%E5%9C%A8%EF%BC%8C%E6%84%9F%E6%81%A9%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-2191" rel="external nofollow noopener noreferrer" target="_blank">悼念512汶川大地震遇难同胞——珍惜现在，感恩生活</a></p>
<p>&emsp;&emsp;直接套用多重背包模板即可</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">105</span>],val[<span class="number">105</span>],k[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_one</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val,<span class="keyword">int</span> vtot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=vtot;j&gt;=cost;j--)</span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-cost]+val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val,<span class="keyword">int</span> vtot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=cost;j&lt;=vtot;j++)</span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-cost]+val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiple</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val,<span class="keyword">int</span> num,<span class="keyword">int</span> vtot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(cost*num&gt;=vtot)</span><br><span class="line">    &#123;</span><br><span class="line">        complete(cost,val,vtot);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        zero_one(k*cost,k*val,vtot);</span><br><span class="line">        num-=k;</span><br><span class="line">        k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zero_one(num*cost,num*val,vtot);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        mst(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;val[i]&gt;&gt;k[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            multiple(v[i],val[i],k[i],n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>多重背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>多重背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2049 - 不容易系列之(4)——考新郎</title>
    <url>/2019/02/24/HDU2049-%E4%B8%8D%E5%AE%B9%E6%98%93%E7%B3%BB%E5%88%97%E4%B9%8B-4-%E2%80%94%E2%80%94%E8%80%83%E6%96%B0%E9%83%8E/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-2049" rel="external nofollow noopener noreferrer" target="_blank">不容易系列之(4)——考新郎</a></p>
<p>&emsp;&emsp;错排公式的应用。因为n个新郎中有m个“错排”了，所以先用C(n,m)求出从n个新郎中挑m个出来的方案数，再乘以错排数即可。</p>
<p>&emsp;&emsp;关于错排公式，可看这里：</p>
<p><img src="https://pic.superbed.cn/item/5c72aa803a213b0417769896" alt></p>
<p><img src="https://pic.superbed.cn/item/5c72aaa23a213b0417769b58" alt><br><a id="more"></a></p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">ll combi[<span class="number">25</span>];</span><br><span class="line">ll d[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_com</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    combi[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        combi[i]=combi[i<span class="number">-1</span>]*(n-i+<span class="number">1</span>)/i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_mistake</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>,d[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=m;i++)</span><br><span class="line">        d[i]=(i<span class="number">-1</span>)*(d[i<span class="number">-1</span>]+d[i<span class="number">-2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        mst(combi,<span class="number">0</span>);mst(d,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        make_com(n);make_mistake(m);</span><br><span class="line">        ll ans=combi[m]*d[m];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1969 - Pie</title>
    <url>/2019/02/22/HDU1969-Pie/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-1969" rel="external nofollow noopener noreferrer" target="_blank">Pie</a></p>
<p>&emsp;&emsp;二分答案的经典题。所谓二分答案，即在整个可能的答案空间内进行二分操作，每次都检验一下mid，并根据检验结果调整lef和rig的值。</p>
<a id="more"></a>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi acos(-1.0)        <span class="comment">//用反三角函数计算Pi</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> arr[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> f,n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> todo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        sum+=(<span class="keyword">int</span>)(arr[i]/todo);        <span class="comment">//计算当前体积下能分出多少份派</span></span><br><span class="line">    <span class="keyword">if</span>(sum&gt;=f)    <span class="comment">//如果可以分出不少于f(f在main中修改过，f=f+1)块，则当前体积可行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;f;</span><br><span class="line">        f+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">            arr[i]=arr[i]*arr[i]*pi;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr,arr+n,cmp);</span><br><span class="line">        <span class="keyword">double</span> l=<span class="number">0</span>;<span class="keyword">double</span> r=arr[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">double</span> mid=l+((r-l)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span>(r-l&gt;<span class="number">1e-6</span>)                <span class="comment">//注意精度</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid=l+((r-l)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(check(mid))    <span class="comment">//有些时候不一定是l=mid或r=mid，有可能是l=mid+1或</span></span><br><span class="line">                l=mid;       <span class="comment">//r=mid-1，这要根据情况而定。但一般而言，如果是浮点数，              </span></span><br><span class="line">            <span class="keyword">else</span>             <span class="comment">//只需l=mid或r=mid</span></span><br><span class="line">                r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2222 &amp; HDU2896 - AC自动机模板</title>
    <url>/2019/08/31/HDU2222-HDU2896-AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H65722373b7674099b56790ec509eb5a8B.jpg" alt></p>
<a id="more"></a>
<p>屯板子屯板子……</p>
<p><a href="https://cn.vjudge.net/problem/HDU-2222" rel="external nofollow noopener noreferrer" target="_blank">HDU2222 - Keywords Search</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">500005</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> fail[<span class="number">500005</span>];</span><br><span class="line">    <span class="keyword">int</span> ed[<span class="number">500005</span>];</span><br><span class="line">    <span class="keyword">int</span> rt,L;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            next[L][i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ed[L]=<span class="number">0</span>;<span class="keyword">int</span> tmpL=L;L++;</span><br><span class="line">        <span class="keyword">return</span> tmpL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        L=<span class="number">0</span>;</span><br><span class="line">        rt=newnode();</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())    que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert_</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cur=rt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch=str[i];</span><br><span class="line">            <span class="keyword">if</span>(next[cur][ch-<span class="string">'a'</span>]==<span class="number">-1</span>)&#123;</span><br><span class="line">                next[cur][ch-<span class="string">'a'</span>]=newnode();</span><br><span class="line">            &#125;</span><br><span class="line">            cur=next[cur][ch-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ed[cur]++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fail[rt]=rt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(next[rt][i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                next[rt][i]=rt;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                fail[next[rt][i]]=rt;</span><br><span class="line">                que.push(next[rt][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u=que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(next[u][i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    next[u][i]=next[fail[u]][i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    fail[next[u][i]]=next[fail[u]][i];</span><br><span class="line">                    que.push(next[u][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">queue</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> now=rt;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            now=next[now][str[i]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">int</span> tmp=now;</span><br><span class="line">            <span class="keyword">while</span>(tmp!=rt)&#123;</span><br><span class="line">                ans+=ed[tmp];</span><br><span class="line">                ed[tmp]=<span class="number">0</span>;</span><br><span class="line">                tmp=fail[tmp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"i = "</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;ed[i]&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie acmaton;        <span class="comment">//内部有大数组，需要开全局变量 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        acmaton.init();</span><br><span class="line">        <span class="built_in">string</span> tmps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tmps;acmaton.insert_(tmps);</span><br><span class="line">        &#125;</span><br><span class="line">        acmaton.build();</span><br><span class="line"><span class="comment">//        acmaton.show();</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;tmps;</span><br><span class="line">        <span class="keyword">int</span> ans=acmaton.<span class="built_in">queue</span>(tmps);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/HDU-2896" rel="external nofollow noopener noreferrer" target="_blank">HDU2896 - 病毒侵袭</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ansvec;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">100005</span>][<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> fail[<span class="number">100005</span>];</span><br><span class="line">    <span class="keyword">int</span> edstr[<span class="number">100005</span>];</span><br><span class="line">    <span class="keyword">int</span> rt,L;</span><br><span class="line">    <span class="keyword">int</span> scnt;    <span class="comment">//字符串数量 </span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">128</span>;i++)&#123;</span><br><span class="line">            next[L][i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edstr[L]=<span class="number">0</span>;<span class="keyword">int</span> tmpL=L;L++;</span><br><span class="line">        <span class="keyword">return</span> tmpL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        L=<span class="number">0</span>;scnt=<span class="number">0</span>;</span><br><span class="line">        rt=newnode();</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())    que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert_</span><span class="params">(<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">int</span> cur=rt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch=str[i];</span><br><span class="line">            <span class="keyword">if</span>(next[cur][ch]==<span class="number">-1</span>)&#123;</span><br><span class="line">                next[cur][ch]=newnode();</span><br><span class="line">            &#125;</span><br><span class="line">            cur=next[cur][ch];</span><br><span class="line">        &#125;</span><br><span class="line">        edstr[cur]=++scnt;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fail[rt]=rt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">128</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(next[rt][i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                next[rt][i]=rt;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                fail[next[rt][i]]=rt;</span><br><span class="line">                que.push(next[rt][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u=que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">128</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(next[u][i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    next[u][i]=next[fail[u]][i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    fail[next[u][i]]=next[fail[u]][i];</span><br><span class="line">                    que.push(next[u][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">int</span> now=rt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            now=next[now][str[i]];</span><br><span class="line">            <span class="keyword">int</span> tmp=now;</span><br><span class="line">            <span class="keyword">while</span>(tmp!=rt)&#123;</span><br><span class="line">                <span class="keyword">if</span>(edstr[tmp]!=<span class="number">0</span>)</span><br><span class="line">                    ansvec.push_back(edstr[tmp]);</span><br><span class="line">                tmp=fail[tmp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"i = "</span>&lt;&lt;i&lt;&lt;<span class="string">" edstr[i] = "</span>&lt;&lt;edstr[i]&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie acmaton;        <span class="comment">//内部有大数组，需要开全局变量 </span></span><br><span class="line"><span class="keyword">char</span> cha[<span class="number">205</span>];</span><br><span class="line"><span class="keyword">char</span> web[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        acmaton.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,cha);acmaton.insert_(cha);</span><br><span class="line">        &#125;</span><br><span class="line">        acmaton.build();</span><br><span class="line">        <span class="keyword">int</span> m;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> webtot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            ansvec.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,web);</span><br><span class="line">    <span class="comment">//        printf("web: %s\n",web);</span></span><br><span class="line">            acmaton.query(web);</span><br><span class="line">            <span class="keyword">int</span> cntt=ansvec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//        debug;</span></span><br><span class="line">            <span class="keyword">if</span>(cntt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sort(ansvec.<span class="built_in">begin</span>(),ansvec.<span class="built_in">end</span>());</span><br><span class="line">                webtot++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"web %d: "</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> sz=ansvec.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==sz<span class="number">-1</span>)    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ansvec[i]);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,ansvec[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//    cout&lt;&lt;"total: "&lt;&lt;webtot&lt;&lt;"\n";//</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"total: %d\n"</span>,webtot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
        <category>AC自动机</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2376 &amp; HDU5723</title>
    <url>/2019/04/22/HDU2376-HDU5723/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1l7AwSCzqK1RjSZPxq6A4tVXaO.jpg" alt></p>
<p><del>(封面图与内容完全无关，只是因为图好看才放上来)</del><br><a id="more"></a></p>
<p>这次打算把HDU3276和HDU5723两道题放在一起讲，主要是因为这两道题都涉及到了求树上任意两点的距离的总和；HDU5723除此之外还多了一点就是求最小生成树。不过讲真，个人认为其实HDU5723将对这两者融合得并不好，求最小生成树以及求距离和这两个之间的联系有点牵强……emmmmmm，毕竟只是签到题？</p>
<p>先说<a href="https://cn.vjudge.net/problem/HDU-2376" rel="external nofollow noopener noreferrer" target="_blank">HDU3276</a></p>
<p>直接枚举每一个点对然后对点对dfs肯定是行不通的，所以我们可以这么考虑：对于一条边而言，它对于距离总和的“贡献”，即为它被走过的次数乘以它的长度。而它被走过的次数，就是它符合这样的条件的点对的个数：一个点在这条边的一侧，另一个点在这条边的另一侧。由此即可求出这条边的贡献。总的距离之和即为所有边的贡献的总和。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    ll wei;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; gra[maxn];</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;gra[rt].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> son=gra[rt][i].to;</span><br><span class="line">        <span class="keyword">if</span>(son==fa)        <span class="keyword">continue</span>;</span><br><span class="line">        edge&amp; e=gra[rt][i];</span><br><span class="line">        dfs(son,rt);</span><br><span class="line">        sum[rt]+=sum[son];</span><br><span class="line">        ans+=sum[son]*((ll)n-sum[son])*e.wei;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;<span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            gra[i].<span class="built_in">clear</span>();        <span class="comment">//记得清空，否则可能mle</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;ll d;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %lld"</span>,&amp;a,&amp;b,&amp;d);</span><br><span class="line">            gra[a].push_back(edge&#123;b,d&#125;);</span><br><span class="line">            gra[b].push_back(edge&#123;a,d&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">double</span> tot=ans/(((<span class="keyword">double</span>)(n<span class="number">-1</span>)*(<span class="keyword">double</span>)n)/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>,tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
    <p>注意题目中的精度是10<sup>-6</sup>!所以要%.6lf!另外因为这题是spj，所以虽然看起来样例没过，其实没关系</p>
</div>

<p>然后是<a href="https://cn.vjudge.net/problem/HDU-5723" rel="external nofollow noopener noreferrer" target="_blank">HDU5723</a></p>
<p>其实只是在上面题目的基础上多了个求最小生成树，kruskal求一下即可。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    ll wei;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn];</span><br><span class="line">edge arr[maxn*<span class="number">10</span>];</span><br><span class="line">ll sum[maxn];</span><br><span class="line">ll ans; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.wei&lt;b.wei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        pre[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[x]==x)</span><br><span class="line">        <span class="keyword">return</span> pre[x];</span><br><span class="line">    <span class="keyword">return</span> pre[x]=findr(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll rsl=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fx=findr(arr[i].from);</span><br><span class="line">        <span class="keyword">int</span> fy=findr(arr[i].to);</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[fx]=fy;</span><br><span class="line">            rsl+=arr[i].wei;</span><br><span class="line">            num++;</span><br><span class="line">            tree[arr[i].from].push_back(i);</span><br><span class="line">            tree[arr[i].to].push_back(i); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> rsl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">exp=1/(n*(n-1))*(tot_len*2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[rt].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>&amp; idx=tree[rt][i];        <span class="comment">//tree数组中存的是边的编号 </span></span><br><span class="line">        <span class="keyword">int</span> son;</span><br><span class="line">        <span class="keyword">if</span>(rt==arr[idx].from)</span><br><span class="line">            son=arr[idx].to;</span><br><span class="line">        <span class="keyword">if</span>(rt==arr[idx].to)</span><br><span class="line">            son=arr[idx].from;</span><br><span class="line">        <span class="keyword">if</span>(son==fa)        <span class="keyword">continue</span>;</span><br><span class="line">        dfs(son,rt);</span><br><span class="line">        sum[rt]+=sum[son];</span><br><span class="line">        ans+=(ll)((sum[son]*((ll)n-sum[son]))*(arr[idx].wei));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)        tree[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;ll w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %lld"</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">            arr[i]=edge&#123;x,y,w&#125;;</span><br><span class="line">        &#125;    </span><br><span class="line">        sort(arr+<span class="number">1</span>,arr+m+<span class="number">1</span>,cmp);</span><br><span class="line">        ll min_cost=kruskal();</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">double</span> <span class="built_in">exp</span>=(<span class="keyword">double</span>)ans*(<span class="number">2</span>/((<span class="keyword">double</span>)n*(<span class="keyword">double</span>)(n<span class="number">-1</span>)));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %.2lf\n"</span>,min_cost,<span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
    <p>tree存的是边在arr中的编号</p>
</div>]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>并查集</tag>
        <tag>树上求所有点对的距离的和</tag>
        <tag>dfs</tag>
        <tag>kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2639 - Bone Collector II</title>
    <url>/2019/02/17/HDU2639-Bone-Collector-II/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-2639" rel="external nofollow noopener noreferrer" target="_blank">Bone Collector II</a></p>
<p>&emsp;&emsp;这道题与Bone Collector的不同之处在于，这道题求的是第k优解，而非最优解。那应该怎么做呢？</p>
<p>&emsp;&emsp;首先，01背包的核心方程式dp[j] = max(dp[j] , dp[j - w[i]] + v[i]) ,也就是说，每一个新状态都是由dp[j]或dp[j - w[i]] + v[i]转移来的。我们首先用一个数组a[]和一个数组b[]将这两个状态存起来，然后再循环求得第k优解。这个过程有点像是，一个年级有两个班，我需要知道全年级的前十名是谁，那我就可以通过得到第一个班的前十是谁和第二个班的前十是谁来求得全年级的前十。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> wei[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>],b[<span class="number">1005</span>]; </span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        mst(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n,vtot,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;vtot,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)        <span class="built_in">cin</span>&gt;&gt;val[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)        <span class="built_in">cin</span>&gt;&gt;wei[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=vtot;j&gt;=wei[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;k;q++)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[q]=dp[j][q];</span><br><span class="line">                    b[q]=dp[j-wei[i]][q]+val[i];</span><br><span class="line">                &#125;</span><br><span class="line">                a[k]=<span class="number">-1</span>;b[k]=<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> idx1=<span class="number">0</span>;<span class="keyword">int</span> idx2=<span class="number">0</span>;<span class="keyword">int</span> idx3=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>((idx1&lt;k||idx2&lt;k)&amp;&amp;idx3&lt;k)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[idx1]&gt;b[idx2]?dp[j][idx3]=a[idx1++]:dp[j][idx3]=b[idx2++];</span><br><span class="line">                    <span class="keyword">if</span>(idx3==<span class="number">0</span>||dp[j][idx3<span class="number">-1</span>]!=dp[j][idx3])        <span class="comment">//这个判断是防止有重复数据</span></span><br><span class="line">                        idx3++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[vtot][k<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2546 - 饭卡</title>
    <url>/2019/02/18/HDU2546-%E9%A5%AD%E5%8D%A1/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-2546" rel="external nofollow noopener noreferrer" target="_blank">饭卡</a></p>
<p>&emsp;&emsp;一道01背包的题目，特殊之处在于要先拿出5元用来买最贵的东西，剩下的钱即为背包，然后就是普通的01背包了。</p>
<a id="more"></a>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> pri[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(pri,<span class="number">0</span>,<span class="keyword">sizeof</span>(pri));</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pri[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(m&lt;<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> vtot=m<span class="number">-5</span>;</span><br><span class="line">        sort(pri+<span class="number">1</span>,pri+<span class="number">1</span>+n);        <span class="comment">//要余额最小，则需要先买便宜的，再买贵的 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=vtot;j&gt;=pri[i];j--)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-pri[i]]+pri[i]);</span><br><span class="line">        <span class="keyword">int</span> ans=m-pri[n]-dp[vtot];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2647 - Reward</title>
    <url>/2019/03/21/HDU2647-Reward/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-2647" rel="external nofollow noopener noreferrer" target="_blank">Reward</a><br></p>
<p>其实就是用拓补排序判一下环，但需要注意两点：一是反向建图。这主要是为了计算奖金时的方便，因为反向建图就可以从奖金最少的那个人出发，遍历整个图，逐步累加得到答案；如果是正向建图，则需要先找到奖金最少的那个人，将他作为起点……二是这道题其实是根据每个点(人)在图中的深度来确定每个点(人)的奖金的。已下图为例：</p>
<p><br></p>
<center>![](https://pic.superbed.cn/item/5c9392d03a213b0417d8b072)</center>

<p>3和4的深度是一样的，所以两者的奖金也一样。因此，不能简单地认为，如果可以拓补排序了，答案就是888 + (n * (n - 1)) / 2</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;        <span class="comment">//n个点,m条边 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> maxi; </span><br><span class="line">edge edges[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> deg[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> dep[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges[tot].to=v;</span><br><span class="line">    edges[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">    deg[v]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(deg[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            que.push(i);</span><br><span class="line">            deg[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;    </span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">int</span> fro=que.front();</span><br><span class="line">        ans+=(<span class="number">888</span>+dep[fro]);</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[fro];i!=<span class="number">-1</span>;i=edges[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ito=edges[i].to;</span><br><span class="line">            deg[ito]--;</span><br><span class="line">            <span class="keyword">if</span>(deg[ito]==<span class="number">0</span>)&#123;</span><br><span class="line">                dep[ito]=dep[fro]+<span class="number">1</span>;</span><br><span class="line">                que.push(ito);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        tot=<span class="number">0</span>;mst(head,<span class="number">-1</span>);</span><br><span class="line">        mst(deg,<span class="number">0</span>);mst(dep,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            add_edge(b,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rsl=topo();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;rsl&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>拓补排序</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>拓补排序</tag>
        <tag>反向建图</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2464 - A Pair of Graphs</title>
    <url>/2019/04/10/HDU2464-A-Pair-of-Graphs/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-2464" rel="external nofollow noopener noreferrer" target="_blank">A Pair of Graphs</a></p>
<p>一道同构图的题目。大意就是给出两幅图，同时可以执行两种操作，分别是加边和删边，在A图上加边、删边的代价是Ia，Da；在B图上加边、删边的代价是Ib，Db。现在要通过这两种操作使得两幅图同构，问怎样的操作代价最小，求这个最小代价</p>
<p>因为数据范围很小，N&lt;=8，所以可以直接枚举。具体见代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="comment">/*在无向图中，关联一对顶点的无向边如果多于1条，则称这些边为平行边，</span></span><br><span class="line"><span class="comment">平行边的条数称为重数。在有向图中，关联一对顶点的有向边如果多于1条，</span></span><br><span class="line"><span class="comment">并且这些边的始点与终点相同(也就是它们的的方向相同)，称这些边为平行边。</span></span><br><span class="line"><span class="comment">含平行边的图称为多重图，既不含平行边也不包含自环的图称为简单图*/</span></span><br><span class="line"><span class="keyword">bool</span> ga[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> gb[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> es_a,es_bb;</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;es_a&gt;&gt;es_bb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;es_a==<span class="number">0</span>&amp;&amp;es_bb==<span class="number">0</span>)        <span class="keyword">break</span>;</span><br><span class="line">        mst(ga,<span class="number">0</span>);mst(gb,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ia,ib,da,db;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ia&gt;&gt;ib&gt;&gt;da&gt;&gt;db;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;es_a;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">            ga[x][y]=ga[y][x]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;es_bb;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">            gb[x][y]=gb[y][x]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            arr[i]=i;</span><br><span class="line">        <span class="keyword">int</span> fac=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)        fac*=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;fac;k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ga[i][j]!=gb[arr[i]][arr[j]])&#123;        <span class="comment">//如果两个条边之间的关系不一致</span></span><br><span class="line">                        <span class="keyword">if</span>(ga[i][j])</span><br><span class="line">                            tmp+=<span class="built_in">min</span>(da,ib);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tmp+=<span class="built_in">min</span>(ia,db);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,tmp);</span><br><span class="line">            next_permutation(arr,arr+n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>,++kase,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>同构图</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>同构图</tag>
        <tag>暴力枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2104 - Kth number 主席树or划分树模板</title>
    <url>/2019/09/07/HDU2665-Kth-Number-%E4%B8%BB%E5%B8%AD%E6%A0%91or%E5%88%92%E5%88%86%E6%A0%91%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/He1712fd2c08f40a985b1ef436e9be051G.jpg" alt></p>
<a id="more"></a>
<p><a href="http://poj.org/problem?id=2104" rel="external nofollow noopener noreferrer" target="_blank">Kth number</a></p>
<p>模板题，题意是求区间第k大，套一下主席树模板或者划分树模板即可（屯板子）</p>
<p>代码如下：</p>
<p>主席树：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> rt[maxn&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> ls[maxn&lt;&lt;<span class="number">5</span>],rs[maxn&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span>&amp; root)</span>        <span class="comment">//其实就是一个为各节点分配id的过程 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    root=++tot;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lef,mid,ls[root]);</span><br><span class="line">    build(mid+<span class="number">1</span>,rig,rs[root]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> root)</span>        </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_=++tot;        <span class="comment">//建一棵新树 </span></span><br><span class="line">    ls[root_]=ls[root];</span><br><span class="line">    rs[root_]=rs[root];</span><br><span class="line">    sum[root_]=sum[root]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)    <span class="keyword">return</span> root_;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid)&#123;</span><br><span class="line">        ls[root_]=update(lef,mid,ls[root_]);        <span class="comment">//如果修改点在左儿子，就新建一个左儿子 </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        rs[root_]=update(mid+<span class="number">1</span>,rig,rs[root_]);        <span class="comment">//如果修改点在右儿子，就新建一个右儿子 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> x=sum[ls[v]]-sum[ls[u]];</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)    <span class="keyword">return</span> lef;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=k)&#123;</span><br><span class="line">        ans=query(ls[u],ls[v],lef,mid,k);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ans=query(rs[u],rs[v],mid+<span class="number">1</span>,rig,k-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> lisan[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    <span class="built_in">cin</span>&gt;&gt;arr[i],lisan[i]=arr[i];</span><br><span class="line">    sort(lisan+<span class="number">1</span>,lisan+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> len=unique(lisan+<span class="number">1</span>,lisan+<span class="number">1</span>+n)-lisan<span class="number">-1</span>;</span><br><span class="line">    build(<span class="number">1</span>,len,rt[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p=lower_bound(lisan+<span class="number">1</span>,lisan+<span class="number">1</span>+len,arr[i])-lisan;</span><br><span class="line">        rt[i]=update(<span class="number">1</span>,len,rt[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> L,R,k;<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;R&gt;&gt;k;</span><br><span class="line">        ans=query(rt[L<span class="number">-1</span>],rt[R],<span class="number">1</span>,len,k);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;lisan[ans]&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>划分树：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">20</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> to_lef[<span class="number">20</span>][maxn]; </span><br><span class="line"><span class="keyword">int</span> sorted[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> lev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>; </span><br><span class="line">    <span class="keyword">int</span> sup=mid-lef+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lef;i&lt;=rig;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[lev][i]&lt;sorted[mid])&#123;</span><br><span class="line">            sup--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sublef=lef;<span class="keyword">int</span> subrig=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lef;i&lt;=rig;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==lef)&#123;</span><br><span class="line">            to_lef[lev][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            to_lef[lev][i]=to_lef[lev][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[lev][i]&lt;sorted[mid]||tree[lev][i]==sorted[mid]&amp;&amp;sup&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            tree[lev+<span class="number">1</span>][sublef++]=tree[lev][i];</span><br><span class="line">            to_lef[lev][i]++;</span><br><span class="line">            <span class="keyword">if</span>(tree[lev][i]==sorted[mid])    sup--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tree[lev+<span class="number">1</span>][subrig++]=tree[lev][i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    build(lef,mid,lev+<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>,rig,lev+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> lev,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L==R)    <span class="keyword">return</span> tree[lev][L];</span><br><span class="line">    <span class="keyword">int</span> lef_,tolef;</span><br><span class="line">    <span class="keyword">if</span>(L==lef)&#123;</span><br><span class="line">        lef_=<span class="number">0</span>;tolef=to_lef[lev][R];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lef_=to_lef[lev][L<span class="number">-1</span>];</span><br><span class="line">        tolef=to_lef[lev][R]-lef_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=tolef)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_lef=lef+lef_;</span><br><span class="line">        <span class="keyword">int</span> tmp_rig=lef+lef_+tolef<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> query(lev+<span class="number">1</span>,lef,mid,tmp_lef,tmp_rig,k);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_lef=mid+L-lef-lef_+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp_rig=mid+R-lef-lef_-tolef+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> query(lev+<span class="number">1</span>,mid+<span class="number">1</span>,rig,tmp_lef,tmp_rig,k-tolef);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sorted[i]);</span><br><span class="line">        tree[<span class="number">0</span>][i]=sorted[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(sorted+<span class="number">1</span>,sorted+<span class="number">1</span>+n);</span><br><span class="line">    build(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,k;<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;k);</span><br><span class="line">        <span class="keyword">int</span> ans=query(<span class="number">0</span>,<span class="number">1</span>,n,x,y,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>主席树</tag>
        <tag>划分树</tag>
        <tag>屯板子</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3466 - Proud Merchant</title>
    <url>/2019/02/18/HDU3466-Proud-Merchant/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-3466" rel="external nofollow noopener noreferrer" target="_blank">Proud Merchant</a></p>
<p>&emsp;&emsp;这道题最难搞的地方在于如何处理“小于qi时不能买”这一要求。苦思冥想许久，依然不知如何解决，于是只好去看题解……</p>
<p>&emsp;&emsp;这道题的做法是首先将“商人”按照q-p排序，然后再进行01背包。为什么是按照q-p排序呢？假设有两件物品A,B,他们对应的p,q分别是p1,q1和p2,q2。如果这两件东西都要买，那么，如果先买A，就至少需要p1 + q2的钱才能把两件东西都买到；如果先买B，就至少需要p2 + q1的钱才能把两件东西都买到。为了买到尽可能多的东西，获得尽可能大的价值，就应该按照代价小的方式来买。也就是说，假如先买A比先买B所需的代价更小，就有p1 + q2 &lt; p2 + q1，即q1 - p1 &lt; q2 - p2。</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p,q,v;</span><br><span class="line">&#125;mer;</span><br><span class="line">mer arr[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(mer a,mer b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.q-a.p)&lt;(b.q-b.p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i].p&gt;&gt;arr[i].q&gt;&gt;arr[i].v;</span><br><span class="line">        sort(arr,arr+n,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=arr[i].q;j--)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-arr[i].p]+arr[i].v);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2669 - Romantic</title>
    <url>/2019/03/02/HDU2669-Romantic/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-2669" rel="external nofollow noopener noreferrer" target="_blank">Romantic</a></p>
<p>&emsp;&emsp;一道拓展欧几里得的题目，因为是ax + by = 1,所以可以直接用求逆元的方法来求出x,再根据y = (1 - ax) / b求得y。题目要求x是非负的，这在求逆元的过程中已得到了解决。</p>
<a id="more"></a>
<p>代码如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll&amp; x,ll&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ll r;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;    </span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r=exgcd(b,a%b,y,x);</span><br><span class="line">        y-=x*(a/b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ll x,y;</span><br><span class="line">    ll g=exgcd(a,b,x,y);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>%g)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    x*=<span class="number">1</span>/g;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>)        b=-b;</span><br><span class="line">    ll ans=x%b;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=<span class="number">0</span>)</span><br><span class="line">        ans+=b;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ans=solve(a,b);</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"sorry"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll ansx=ans;</span><br><span class="line">            ll ansy=(<span class="number">1</span>-a*ansx)/b;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ansx&lt;&lt;<span class="string">" "</span>&lt;&lt;ansy&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>HDU2955 - Robberies</title>
    <url>/2019/02/17/HDU2955-Robberies/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-2955" rel="external nofollow noopener noreferrer" target="_blank">Robberies</a></p>
<p>&emsp;&emsp;依然是01背包，但这次的有点特殊。特殊之处在于，背包的总体积是可以获得的钱的最大值( 如果是以概率为背包也不能枚举啊23333 )，然后用动态规划求得获得该钱数被抓的最大概率( 如果在最大概率的情况下都不会被抓，那就肯定不会被抓 )。</p>
<a id="more"></a>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">double</span> p[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        mst(dp,<span class="number">0</span>);mst(m,<span class="number">0</span>);mst(p,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="keyword">double</span> ptot;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ptot&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;m[i]&gt;&gt;p[i];</span><br><span class="line">            sum+=m[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=m[i];j--)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-m[i]]*(<span class="number">1.0</span>-p[i]));</span><br><span class="line">      <span class="comment">//这里先求不会被抓的概率然后用1减去这个概率，就是被抓的概率(高中数学)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">double</span> ans=<span class="number">1.0</span>-dp[j];</span><br><span class="line">            <span class="keyword">if</span>(ptot-ans&gt;<span class="number">1e-9</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU4015 - Mario and Mushrooms( The 36th ACM/ICPC Asia Regional Shanghai Site —— Warmup E题)</title>
    <url>/2019/03/24/HDU4015-Mario-and-Mushrooms-The-36th-ACM-ICPC-Asia-Regional-Shanghai-Site-%E2%80%94%E2%80%94-Warmup-E%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-4015" rel="external nofollow noopener noreferrer" target="_blank">Mario and Mushrooms</a></p>
<p>一道数学题，和pzc推了差不多一小时的式子，结果还是错了OTZ，<del>遂看题解</del><br>然后发现这题其实就是直接把Raney引理套一套就行了<del>(Raney引理又是什么神仙？？？)</del></p>
<p>Raney引理:</p>
<blockquote>
<p>设整数序列A={Ai,i=1,2,…,N}，且部分和为Sk=A1+,…,+Ak，序列中的所有的数字之和为Sn=1；则在A的N个循环表示中，有且仅有一个序列B，满足B的任意部分和Si均大于零。</p>
</blockquote>
<p>一篇文章:<br><a href="https://blog.csdn.net/a363514083/article/details/6760409?locationNum=15" rel="external nofollow noopener noreferrer" target="_blank">HDOJ4105和raney引理</a></p>
<p><del>所以当时为什么不直接打表</del></p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> m,k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">1</span>/(m*k+k+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %.8lf\n"</span>,++kase,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附:自己推出来的错误式子，留个纪念</p>
<p>\begin{equation}<br>\frac{\frac{k(k+1)m}{2}}{C_{km+1+k}^{k}}<br>\end{equation}</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3926 - Hand in Hand</title>
    <url>/2019/04/06/HDU3926-Hand-in-Hand/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-3926" rel="external nofollow noopener noreferrer" target="_blank">Hand in Hand</a></p>
<p>题目大意是给你两张图，让你判断这两张图是否同构，条件是两张图上的点最多都只有两个度数，可以看作是一个简单的同构图问题。</p>
<p>首先说一下什么是同构图</p>
<p>按字面意思理解，同构图即为”相同结构的图”，用图论中的术语描述就是</p>
<blockquote>
<p>图论当中的术语，假设G=(V,E)和G1=(V1，E1)是两个图，如果存在一个双射(即一一映射)m：V→V1，使得对所有的x,y∈V均有xy∈E等价于m(x)m(y)∈E1，则称G和G1是同构的,这样的一个映射m称之为一个同构</p>
</blockquote>
<p>而我对于同构图的理解是，一个同构图，应具有相同的连通性，链/环的个数以及链上/环上的点的个数应相同，点与点、边与边之间的对应关系应相同</p>
<p>比方说，下面的就是一对同构图</p>
<p><img src="https://ae01.alicdn.com/kf/HTB12WwabSWD3KVjSZSgq6ACxVXaa.jpg" alt></p>
<p>左图是一个只由五元环组成的图，而右图看起来和左图很不一样，但实际上也是一个五元环，边、点一一对应，故两者同构</p>
<p>回到这道题目上。要判断两个图是否同构，实际上是一个比较复杂的问题。一个比较简单粗暴的方法是比较两个图的邻接矩阵，若经过有限次的行变换和列变换后两个矩阵相同，则两图同构。也有用搜索的方法做的……具体的就不说了。但因为这道题每个点最多只有两个度，所以问题大大简化，故可以使用并查集来做，即用并查集检查两张图上链与环的数量，同时检查链/环上点的数目，比较一下，如果都相等则为同构，否则不同构。</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> n1,n2,m;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kid</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rcnt;</span><br><span class="line">    <span class="keyword">int</span> ccnt;</span><br><span class="line">    kid():rcnt(<span class="number">0</span>),ccnt(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(kid node1,kid node2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node1.ccnt==node2.ccnt)</span><br><span class="line">        <span class="keyword">return</span> node1.rcnt&lt;node2.rcnt;</span><br><span class="line">    <span class="keyword">return</span> node1.ccnt&lt;node2.ccnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        pre[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==pre[x])        <span class="keyword">return</span> pre[x];</span><br><span class="line">    <span class="keyword">return</span> pre[x]=findr(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        kid k1[maxn];</span><br><span class="line">        kid k2[maxn];</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n1&gt;&gt;m;init(n1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">            <span class="keyword">int</span> fu=findr(u);</span><br><span class="line">            <span class="keyword">int</span> fv=findr(v);</span><br><span class="line">            <span class="keyword">if</span>(fu!=fv)&#123;</span><br><span class="line">                pre[fu]=fv;        <span class="comment">//将fu接到fv上</span></span><br><span class="line">                k1[fv].ccnt+=k1[fu].ccnt;</span><br><span class="line">                k1[fu].ccnt=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k1[fv].rcnt++;        <span class="comment">//以fv为代表元素的环有多少个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n2&gt;&gt;m;init(n2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">            <span class="keyword">int</span> fu=findr(u);</span><br><span class="line">            <span class="keyword">int</span> fv=findr(v);</span><br><span class="line">            <span class="keyword">if</span>(fu!=fv)&#123;</span><br><span class="line">                pre[fu]=fv;</span><br><span class="line">                k2[fv].ccnt+=k2[fu].ccnt;</span><br><span class="line">                k2[fu].ccnt=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k2[fv].rcnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n1!=n2)&#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sort(k1+<span class="number">1</span>,k1+n1+<span class="number">1</span>,cmp);</span><br><span class="line">            sort(k2+<span class="number">1</span>,k2+n2+<span class="number">1</span>,cmp);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k1[i].ccnt!=k2[i].ccnt||k1[i].rcnt!=k2[i].rcnt)&#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: YES\n"</span>,++kase);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: NO\n"</span>,++kase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>同构图</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>同构图</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU4020 - Ads Proposal(The 36th ACM/ICPC Asia Regional Shanghai Site —— Warmup J题)</title>
    <url>/2019/03/24/HDU4020-Ads-Proposal-The-36th-ACM-ICPC-Asia-Regional-Shanghai-Site-%E2%80%94%E2%80%94-Warmup-J%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-4020" rel="external nofollow noopener noreferrer" target="_blank">Ads Proposal</a></p>
<p>网上有用树状数组做的，但我对树状数组非常不熟……所以只能用比较暴力的做法，set+前缀和OTZ<del>(其实也写了一个树状数组的，只不过基本就是在抄题解hhhhhhh)</del></p>
<a id="more"></a>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ad</span>&#123;</span></span><br><span class="line">    ll cli;</span><br><span class="line">    ll len;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ad&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cli&gt;a.cli;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ll sum[maxn*<span class="number">5</span>];</span><br><span class="line"><span class="built_in">set</span>&lt;ad&gt; cus[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m,q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            cus[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            ad tmp;<span class="keyword">int</span> u;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %lld %lld"</span>,&amp;u,&amp;tmp.cli,&amp;tmp.len);</span><br><span class="line">            cus[u].insert(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        mst(sum,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">set</span>&lt;ad&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> idx=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(it=cus[i].<span class="built_in">begin</span>();it!=cus[i].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">                sum[idx++]+=(*it).len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            sum[i]=sum[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++kase);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">            k=<span class="built_in">min</span>(k,m); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较有意思的是计算前缀和的部分，这里解释一下。其实就是对于每一个customer，把他每一个广告的长度加到对应的第i个广告长度和上，然后将这个过程循环起来。最后再在这个基础上求个前缀和即可</p>
]]></content>
  </entry>
  <entry>
    <title>HDU4054-Hexadecimal View</title>
    <url>/2019/02/11/HDU4054-Hexadecimal-View/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4054" rel="external nofollow noopener noreferrer" target="_blank">Hexadecimal View</a></p>
<p><img src="https://pic.superbed.cn/item/5c6147a15f3e509ed92f7690" alt></p>
<p>此题没有考查任何一个算法知识点，只是一道用来练代码熟悉度的题目<br><a id="more"></a><br>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">4100</span>];</span><br><span class="line"><span class="keyword">int</span> addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;<span class="keyword">int</span> postmp=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">conv</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=postmp;i&lt;postmp+<span class="number">16</span>&amp;&amp;i!=len;i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">islower</span>(s[i]))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]-(<span class="string">'a'</span>-<span class="string">'A'</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isupper</span>(s[i]))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]+(<span class="string">'a'</span>-<span class="string">'A'</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">row</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%04x: "</span>,addr);</span><br><span class="line">    <span class="keyword">int</span> idx=pos;<span class="keyword">int</span> cnt=<span class="number">0</span>;<span class="keyword">int</span> cnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> col=<span class="number">0</span>;</span><br><span class="line">    postmp=pos; </span><br><span class="line">    <span class="keyword">for</span>(;cnt&lt;<span class="number">16</span>&amp;&amp;!vis[len<span class="number">-1</span>];idx++)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02x"</span>,s[idx]);col+=<span class="number">2</span>;</span><br><span class="line">        vis[idx]=<span class="number">1</span>;</span><br><span class="line">        cnt2++;cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt2==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);col++;</span><br><span class="line">            cnt2=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">39</span>-col;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    pos=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str))</span><br><span class="line">    &#123;    </span><br><span class="line">        addr=<span class="number">0</span>;pos=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">int</span> len=str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(;!vis[len<span class="number">-1</span>];addr+=<span class="number">16</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            row(str);</span><br><span class="line">            conv(str);</span><br><span class="line">        &#125;</span><br><span class="line">        str=<span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU4133 - StrangeStandard</title>
    <url>/2019/03/02/HDU4133-StrangeStandard/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-4133" rel="external nofollow noopener noreferrer" target="_blank">StrangeStandard</a></p>
<p>&emsp;&emsp;一道反素数的题目，求的是区间内的最大反素数。一开始做我是打表的<del>(而且这表还不是自己打出来的)</del>,代码如下:</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">200</span>]=&#123;<span class="number">2000000001</span>,<span class="number">1396755360</span>,<span class="number">1102701600</span>,<span class="number">735134400</span>,<span class="number">698377680</span>,</span><br><span class="line"><span class="number">551350800</span>,<span class="number">367567200</span>,<span class="number">294053760</span>,<span class="number">245044800</span>,</span><br><span class="line"><span class="number">183783600</span>,<span class="number">147026880</span>,<span class="number">122522400</span>,<span class="number">110270160</span>,</span><br><span class="line"><span class="number">73513440</span>,<span class="number">61261200</span>,<span class="number">43243200</span>,<span class="number">36756720</span>,</span><br><span class="line"><span class="number">32432400</span>,<span class="number">21621600</span>,<span class="number">17297280</span>,<span class="number">14414400</span>,<span class="number">10810800</span>,</span><br><span class="line"><span class="number">8648640</span>,<span class="number">7207200</span>,<span class="number">6486480</span>,<span class="number">4324320</span>,<span class="number">3603600</span>,<span class="number">2882880</span>,</span><br><span class="line"><span class="number">2162160</span>,<span class="number">1441440</span>,<span class="number">1081080</span>,<span class="number">720720</span>,<span class="number">665280</span>,<span class="number">554400</span>,<span class="number">498960</span>,</span><br><span class="line"><span class="number">332640</span>,<span class="number">277200</span>,<span class="number">221760</span>,<span class="number">166320</span>,<span class="number">110880</span>,<span class="number">83160</span>,<span class="number">55440</span>,<span class="number">50400</span>,</span><br><span class="line"><span class="number">45360</span>,<span class="number">27720</span>,<span class="number">25200</span>,<span class="number">20160</span>,<span class="number">15120</span>,<span class="number">10080</span>,<span class="number">7560</span>,<span class="number">5040</span>,<span class="number">2520</span>,<span class="number">1680</span>,</span><br><span class="line"><span class="number">1260</span>,<span class="number">840</span>,<span class="number">720</span>,<span class="number">360</span>,<span class="number">240</span>,<span class="number">180</span>,<span class="number">120</span>,<span class="number">60</span>,<span class="number">48</span>,<span class="number">36</span>,<span class="number">24</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)</span><br><span class="line">            <span class="keyword">if</span>(ans[i]&lt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>,++kase,ans[i]);</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这题非打表的方法是用dfs。具体代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">500005</span>;</span><br><span class="line">ll n,ans;</span><br><span class="line">ll maxi=<span class="number">-1</span>;</span><br><span class="line">ll prime[<span class="number">20</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep,<span class="keyword">int</span> now,<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(dep&gt;=<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(cnt==maxi&amp;&amp;ans&gt;now)</span><br><span class="line">        ans=now;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;maxi)</span><br><span class="line">    &#123;</span><br><span class="line">        maxi=cnt;</span><br><span class="line">        ans=now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span>(now*prime[dep]&gt;n)        <span class="keyword">break</span>;</span><br><span class="line">        now*=prime[dep];</span><br><span class="line">        dfs(dep+<span class="number">1</span>,now,cnt*(i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        ans=<span class="number">0</span>;maxi=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,++kase,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>数论</tag>
        <tag>反素数</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU5922 - Minimum’s Revenge(2016CCPC东北地区大学生程序设计竞赛A题)</title>
    <url>/2019/03/23/HDU5922-Minimum%E2%80%99s-Revenge-2016CCPC%E4%B8%9C%E5%8C%97%E5%9C%B0%E5%8C%BA%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9BA%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-5922" rel="external nofollow noopener noreferrer" target="_blank">Minimum’s Revenge</a></p>
<p>因为边权是两个数之间的lcm，而对于所有的数，1和任意数的lcm都是最小的，故只需要求2 + 3  + 4 + 5 + …… + n即可<br><a id="more"></a></p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    ll n;</span><br><span class="line">    ll kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        ll ans=((n+<span class="number">2</span>)*(n<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%lld: %lld\n"</span>,++kase,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU5924 - Mr. Frog’s Problem( 2016CCPC东北地区大学生程序设计竞赛C题)</title>
    <url>/2019/03/23/HDU5924-Mr-Frog%E2%80%99s-Problem-2016CCPC%E4%B8%9C%E5%8C%97%E5%9C%B0%E5%8C%BA%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9BC%E9%A2%98/</url>
    <content><![CDATA[<p>打表可知，答案就是输入的那两个数，只要按照题目要求的顺序输出即可。<br><a id="more"></a><br>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    ll kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%lld:\n"</span>,++kase);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%lld:\n"</span>,++kase);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="string">" "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU5926 - Mr. Frog’s Game( 2016CCPC东北地区大学生程序设计竞赛E题)</title>
    <url>/2019/03/23/HDU5926-Mr-Frog%E2%80%99s-Game-2016CCPC%E4%B8%9C%E5%8C%97%E5%9C%B0%E5%8C%BA%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9BE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/contest/290420#problem/E" rel="external nofollow noopener noreferrer" target="_blank">Mr. Frog’s Game</a></p>
<p>因为数据量很小，所以直接暴力即可。先检查一下有没有相邻的可以消除，再检查一下同一条边界上可以消除的(根据游戏规则，如果两个方块可以消除且不相邻，只有可能在同一条边界上)<br><a id="more"></a><br>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll gra[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line">ll kase=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll n,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>(gra[i][j]==gra[i<span class="number">-1</span>][j]||gra[i][j]==gra[i+<span class="number">1</span>][j]||gra[i][j]==gra[i][j<span class="number">-1</span>]||gra[i][j]==gra[i][j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Case #%lld: Yes\n"</span>,++kase);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll k=j+<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gra[<span class="number">1</span>][j]==gra[<span class="number">1</span>][k])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Case #%lld: Yes\n"</span>,++kase);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll k=j+<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gra[n][j]==gra[n][k])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Case #%lld: Yes\n"</span>,++kase);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll k=i+<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gra[i][<span class="number">1</span>]==gra[k][<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Case #%lld: Yes\n"</span>,++kase);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll k=i+<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gra[i][m]==gra[k][m])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Case #%lld: Yes\n"</span>,++kase);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%lld: No\n"</span>,++kase);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        mst(gra,<span class="number">0x3f</span>);</span><br><span class="line">        ll n,m;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;gra[i][j];</span><br><span class="line">        solve(n,m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU6608 - Fansblog</title>
    <url>/2019/08/22/HDU6608-Fansblog/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H527f9558b59e43299d761e5671297f57k.jpg" alt></p>
<a id="more"></a>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><a href="https://cn.vjudge.net/problem/HDU-6608" rel="external nofollow noopener noreferrer" target="_blank">Fanblog</a></p>
<p>题意就是给你一个素数$P$，让你找出一个最大的且小于$P$的素数$Q$，求$Q!\ mod\ P$。</p>
<p>emmm数论题一向是弱势，这道题能做出来也是查了大佬博客上的一个结论（链接见附录），简单来说，若要求</p>
<script type="math/tex; mode=display">
Q!\ mod\ P</script><p>只需要求</p>
<script type="math/tex; mode=display">
(-1)^{Q+1}\times inv((P-1-Q)!,P)</script><p>$inv(a,p)$表示的是$a$对$p$的逆元</p>
<p><del>又根据瞎猜结论</del>，$P$和$Q$之间的距离一定不会很大，所以可以直接暴力求$Q$以及$(P-1-Q)!$。套个拓展欧几里得就搞定了。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ll p,q;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll&amp; x,ll&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll pp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    ll d=exgcd(a,pp,x,y);</span><br><span class="line">    <span class="keyword">if</span>(d==<span class="number">1</span>)    <span class="keyword">return</span> (x%pp+pp)%pp;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(ll todo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=todo;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(todo%i==<span class="number">0</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll todo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=todo<span class="number">-1</span>;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chk(i))  <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">frac</span><span class="params">(ll todo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=todo;i++)</span><br><span class="line">        ans=ans%p*i%p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p;</span><br><span class="line">        q=solve(p);</span><br><span class="line">        ll ans=((q+<span class="number">1</span>)&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>)*inv(frac(p<span class="number">-1</span>-q),p);</span><br><span class="line">        ans%p;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul>
<li><p>正文所提到的结论在此处</p>
<p><a href="https://www.cnblogs.com/Judge/p/10755703.html#_label2" rel="external nofollow noopener noreferrer" target="_blank"><a href="https://www.cnblogs.com/Judge/p/10755703.html" rel="external nofollow noopener noreferrer" target="_blank">威尔逊定理小讲解</a></a></p>
</li>
<li><p>对于相邻两个素数的距离，最大可能为无穷大，但在题目数据范围内，这个距离不会很大。可参考以下文章：<a href="https://wenku.baidu.com/view/e5a209acdd3383c4bb4cd2c6.html" rel="external nofollow noopener noreferrer" target="_blank">任意相邻两个素数之间的最大距离公式</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
        <category>威尔逊定理</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C++</tag>
        <tag>数论</tag>
        <tag>威尔逊定理</tag>
      </tags>
  </entry>
  <entry>
    <title>Knapsack Cryptosystem（2019牛客多校第9场  D题）</title>
    <url>/2019/08/16/Knapsack-Cryptosystem/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H65115833a3a8484fbe57a426ff7b309fM.jpg" alt></p>
<p>From <strong>Google Earth</strong></p>
<a id="more"></a>
<p><a href="https://ac.nowcoder.com/acm/contest/889/D" rel="external nofollow noopener noreferrer" target="_blank">Knapsack Cryptosystem</a></p>
<p>题意很简单，是说有一个排好序的升序正整数序列，现在给出总和s，让你从数列中挑出若干个数，使得它们相加后总和为s。</p>
<p>第一反应就是dfs，因为之前做过几乎一模一样的题，且这题数据范围很小，数列最长才36。但事实证明，dfs会T飞……无论怎么剪枝都没用。</p>
<p>正确解法是，将数列折半，对于前一半，状压枚举出每一种选取情况的总和，将它们存入一个map里面。对于后一半，依然是状压枚举每种选取情况的总和，记作$s_i$，在算出$s_i$后，二分lower_bound()在map中找$s-s_i$，如果找到了，就可以输出结果了，答案就是此时后半的选取情况以及$s-s_i$对应的前半选取情况。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ll s,arr[<span class="number">45</span>];</span><br><span class="line"><span class="keyword">int</span> p,q,n;</span><br><span class="line"><span class="built_in">map</span>&lt;ll,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> to[(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msk=<span class="number">2</span>;</span><br><span class="line">    to[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">17</span>;i++)&#123;</span><br><span class="line">        to[msk]=i;</span><br><span class="line">        msk&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> mskp,<span class="keyword">int</span> mskq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">1</span>&amp;(mskp&gt;&gt;i));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">1</span>&amp;(mskq&gt;&gt;i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %lld"</span>,&amp;n,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;arr[i]);</span><br><span class="line">    p=(n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    q=n-p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;p);i++)&#123;</span><br><span class="line">        ll tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j;j-=(lowbit(j)))</span><br><span class="line">            tmp+=arr[to[lowbit(j)]];        </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            lowbit(x)返回x最右端的1所表示的数.</span></span><br><span class="line"><span class="comment">            如,9 = 1001 ,则lowbit(9) = 1 = 1;</span></span><br><span class="line"><span class="comment">            8 = 100 ,则lowbit(8) = 100 = 8. </span></span><br><span class="line"><span class="comment">            */</span> </span><br><span class="line">        mp[tmp]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;q);i++)&#123;</span><br><span class="line">        ll tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j;j-=lowbit(j))</span><br><span class="line">            tmp+=arr[to[lowbit(j)]+p];</span><br><span class="line">        <span class="keyword">auto</span> it=mp.lower_bound(s-tmp);</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;first+tmp==s)&#123;</span><br><span class="line">            show(it-&gt;second,i);flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)    <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>暴力</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C++</tag>
        <tag>牛客多校</tag>
        <tag>状压+暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU6609 - Find the answer</title>
    <url>/2019/08/23/HDU6609-Find-the-answer/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H113a5f2732fe4bb3bd03c7a0516eeb26n.jpg" alt></p>
<a id="more"></a>
<p><a href="https://cn.vjudge.net/problem/HDU-6609" rel="external nofollow noopener noreferrer" target="_blank">Find the answer</a></p>
<p>题意是说，有一个给定的序列$W$与整数$m$，对于$W$的前$k$项，删掉$d_k$项就可以该子序列的前缀和不大于$m$。问对于$W$的所有前缀子序列，其最小的$d$分别是多少。</p>
<p>思路就是通过线段树维护区间和以及区间中数字个数，查询时二分找到符合要求的区间，查询其数字个数，此时的数字个数是需要保留下来的数字的个数，因此答案应该是$i-1-tmp$（$tmp$为查询结果）。另外，该题数据范围比较大，需要做离散化。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll arr[maxn],lisan[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    cnt[rt]=cnt[rt&lt;&lt;<span class="number">1</span>]+cnt[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        sum[rt]=cnt[rt]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        sum[rt]+=lisan[pos];</span><br><span class="line">        cnt[rt]++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">        update(pos,lson);</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        update(pos,rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(ll val,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum[rt]&lt;=val)</span><br><span class="line">        <span class="keyword">return</span> cnt[rt];    </span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[rt]==<span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> val/(sum[rt]/cnt[rt]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum[rt&lt;&lt;<span class="number">1</span>]&gt;val)</span><br><span class="line">        <span class="keyword">return</span> query(val,lson);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> cnt[rt&lt;&lt;<span class="number">1</span>]+query(val-sum[rt&lt;&lt;<span class="number">1</span>],rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        ll m;<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">            lisan[i]=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(lisan+<span class="number">1</span>,lisan+<span class="number">1</span>+n);</span><br><span class="line">        <span class="keyword">int</span> len=unique(lisan+<span class="number">1</span>,lisan+<span class="number">1</span>+n)-lisan<span class="number">-1</span>;</span><br><span class="line">        build(<span class="number">1</span>,len,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> idx=lower_bound(lisan+<span class="number">1</span>,lisan+<span class="number">1</span>+n,arr[i])-lisan;</span><br><span class="line">            <span class="keyword">int</span> tmp=query(m-arr[i],<span class="number">1</span>,len,<span class="number">1</span>);</span><br><span class="line">            update(idx,<span class="number">1</span>,len,<span class="number">1</span>);</span><br><span class="line">            ans[i]=i-tmp<span class="number">-1</span>;     <span class="comment">//tmp是可以保留下来的数的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>一次Hexo博客个性化记录</title>
    <url>/2019/04/19/Hexo%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB14aAXbRWD3KVjSZKPq6yp7FXa9.jpg" alt></p>
<p>&emsp;&emsp;这几天对博客做了一次大更新，换了、添加了挺多东西的，打算做个记录。以下所有更改，都基于NexT主题</p>
<a id="more"></a>
<h5 id="将背景从原本的自动更换的图片背景更改为动态背景。"><a href="#将背景从原本的自动更换的图片背景更改为动态背景。" class="headerlink" title="将背景从原本的自动更换的图片背景更改为动态背景。"></a>将背景从原本的自动更换的图片背景更改为动态背景。</h5><p>方法很简单，只需要在主题配置文件中，找到以下内容，将false改成true即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"> <span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">true</span>    <span class="string">//false-&gt;true</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>同时，对于原本的图片背景，只需这样处理:<br><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- body &#123;</span></span><br><span class="line"><span class="deletion">-     background:url(https://unsplash.it/1600/900?random);</span></span><br><span class="line"><span class="deletion">-     background-repeat: no-repeat;</span></span><br><span class="line"><span class="deletion">-     background-attachment:fixed;</span></span><br><span class="line"><span class="deletion">-     background-position:50% 50%;</span></span><br><span class="line"><span class="deletion">- &#125;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="替换顶部加载进度条"><a href="#替换顶部加载进度条" class="headerlink" title="替换顶部加载进度条"></a>替换顶部加载进度条</h5><p>将原本的进度条替换为NexT自带的进度条。<br>在主题的配置文件中找到下面这一段，将pace改为true，并在pace_theme处选择自己喜欢的进度条样式。<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment">#pace-theme-big-counter</span></span><br><span class="line"><span class="comment">#pace-theme-bounce</span></span><br><span class="line"><span class="comment">#pace-theme-barber-shop</span></span><br><span class="line"><span class="comment">#pace-theme-center-atom</span></span><br><span class="line"><span class="comment">#pace-theme-center-circle</span></span><br><span class="line"><span class="comment">#pace-theme-center-radar</span></span><br><span class="line"><span class="comment">#pace-theme-center-simple</span></span><br><span class="line"><span class="comment">#pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment">#pace-theme-fill-left</span></span><br><span class="line"><span class="comment">#pace-theme-flash</span></span><br><span class="line"><span class="comment">#pace-theme-loading-bar</span></span><br><span class="line"><span class="comment">#pace-theme-mac-osx</span></span><br><span class="line"><span class="comment">#pace-theme-minimal</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment"># pace_theme: pace-theme-center-simple</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-minimal</span></span><br></pre></td></tr></table></figure></p>
<h5 id="加入”fork-me-on-github”的标签"><a href="#加入”fork-me-on-github”的标签" class="headerlink" title="加入”fork me on github”的标签"></a>加入”fork me on github”的标签</h5><p>到<a href="http://tholman.com/github-corners/" rel="external nofollow noopener noreferrer" target="_blank">这个网站</a>上找到自己喜欢的样式，然后<br>粘贴到themes/next/layout/_layout.swig中。具体来说就是</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;div class="&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125;"&gt;</span><br><span class="line">    &lt;div class="headband"&gt;&lt;/div&gt;</span><br><span class="line"><span class="addition">+    &lt;a href="your_github_url" class="github-corner" ...</span></span><br></pre></td></tr></table></figure>
<h5 id="修改鼠标指针样式"><a href="#修改鼠标指针样式" class="headerlink" title="修改鼠标指针样式"></a>修改鼠标指针样式</h5><p>在custom.styl中加入以下代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 鼠标样式</span><br><span class="line">  * &#123;</span><br><span class="line">      <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">"https://0d077ef9e74d8.cdn.sohucs.com/rgaNVxD_png"</span>),auto<span class="meta">!important</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="添加“关于”页面，并使用居中引用来引用句子"><a href="#添加“关于”页面，并使用居中引用来引用句子" class="headerlink" title="添加“关于”页面，并使用居中引用来引用句子"></a>添加“关于”页面，并使用居中引用来引用句子</h5><p>居中引用的HTML使用方法：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">class</span>=<span class="string">"blockquote-center"</span>&gt;</span></span><br><span class="line">    弱小和无知不是生存的障碍，傲慢才是<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>《三体》<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>效果：<br><img src="https://pic.superbed.cn/item/5cb9d2f03a213b04177eb09a" alt></p>
<h5 id="在回到顶部按钮上加入显示当前阅读进度的功能-同时对该按钮的样式进行修改"><a href="#在回到顶部按钮上加入显示当前阅读进度的功能-同时对该按钮的样式进行修改" class="headerlink" title="在回到顶部按钮上加入显示当前阅读进度的功能,同时对该按钮的样式进行修改"></a>在回到顶部按钮上加入显示当前阅读进度的功能,同时对该按钮的样式进行修改</h5><p>在主题配置文件中做如下修改：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span>        <span class="string">//false-&gt;true</span></span><br></pre></td></tr></table></figure></p>
<p>这个按钮原本的形状是方形的，同时里面的三条线是白色的，我将它的形状改成了圆角方形，线的颜色改成了淡蓝色,另外还增加了阴影效果。这也只需要在custom.styl中修改</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">29px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>);</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">2.5px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">2.5px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">10px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.35</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="为文章边框加入阴影效果。"><a href="#为文章边框加入阴影效果。" class="headerlink" title="为文章边框加入阴影效果。"></a>为文章边框加入阴影效果。</h5><p>方法还是修改custom.styl</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">.main-inner &#123; </span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    padding: 60px 60px 60px 60px;</span><br><span class="line">    background: #fff;</span><br><span class="line"><span class="addition">+    box-shadow: 0px 10px 10px 0px rgba(0, 0, 0, 0.35);</span></span><br><span class="line">    opacity: 0.75;</span><br><span class="line">    min-height: 500px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="取消页面上方黑边"><a href="#取消页面上方黑边" class="headerlink" title="取消页面上方黑边"></a>取消页面上方黑边</h5><p>默认情况下，NexT会在页面的上方加一条黑边<del>到底为什么要做这种没用的事</del>，取消黑边的方法是在custom.styl中加入以下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//取消页面上方的黑条</span><br><span class="line"><span class="selector-class">.headband</span> &#123; <span class="attribute">display</span>: none; &#125;</span><br></pre></td></tr></table></figure>
<h5 id="修改侧边滚动条"><a href="#修改侧边滚动条" class="headerlink" title="修改侧边滚动条"></a>修改侧边滚动条</h5><p>在custom.styl中加入以下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//侧边滚动条</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">9px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span><span class="selector-pseudo">:increment</span>,<span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span><span class="selector-pseudo">:decrement</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-corner</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-track</span>,<span class="selector-pseudo">::-webkit-scrollbar-thumb</span> &#123;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-track</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">15px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:start</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">30px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat <span class="number">0</span> -<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">15px</span> -<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-button</span><span class="selector-pseudo">:end</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/scrollbar_arrow.png) no-repeat -<span class="number">30px</span> -<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修改网站标题为-xGeminix-修改网站副标题为-TayE’s-Blog"><a href="#修改网站标题为-xGeminix-修改网站副标题为-TayE’s-Blog" class="headerlink" title="修改网站标题为 -xGeminix- ;修改网站副标题为 TayE’s Blog"></a>修改网站标题为 -xGeminix- ;修改网站副标题为 TayE’s Blog</h5><p>在blog_config.yml中找到title和subtitle修改即可。</p>
<div class="note warning"><p>这两项修改都需要部署后才能看到效果！</p></div>

<h5 id="加入了分享功能"><a href="#加入了分享功能" class="headerlink" title="加入了分享功能"></a>加入了分享功能</h5><p>方法是在主题的配置文件中找到下面这一段，然后把enable的false改为true，再根据自己想要的样式将float或postbottom中的enable改为true</p>
<div class="note info"><p>因为微信分享有点问题(二维码图片无法加载)，而我又不会修复，所以就删掉了这一功能</p></div>

<h5 id="保存当前阅读进度，下次阅读时直接从上次结束阅读的位置开始"><a href="#保存当前阅读进度，下次阅读时直接从上次结束阅读的位置开始" class="headerlink" title="保存当前阅读进度，下次阅读时直接从上次结束阅读的位置开始"></a>保存当前阅读进度，下次阅读时直接从上次结束阅读的位置开始</h5><p>方法是将主题配置文件的save_scroll改为true</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically saving scroll position on each post/page in cookies.</span></span><br><span class="line"><span class="attr">save_scroll:</span> <span class="literal">true</span>    <span class="string">//false-&gt;true</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个性化</tag>
        <tag>美化</tag>
        <tag>不务正业系列</tag>
        <tag>不折腾会死系列</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的展开语法</title>
    <url>/2020/08/04/JS%E4%B8%AD%E7%9A%84%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://pic.downk.cc/item/5f29068a14195aa594529081.jpg" alt><br><a id="more"></a></p>
<p>看代码的时候遇到了下面这样一段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateSkeleton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 文字节点</span></span><br><span class="line">  ;[...document.querySelectorAll(<span class="string">'*'</span>)]</span><br><span class="line">    .filter(</span><br><span class="line">      (node) =&gt;</span><br><span class="line">        ![<span class="string">'script'</span>, <span class="string">'style'</span>, <span class="string">'html'</span>, <span class="string">'body'</span>, <span class="string">'head'</span>, <span class="string">'title'</span>].includes(</span><br><span class="line">          node.tagName.toLowerCase()</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    .map(<span class="function">(<span class="params">node</span>) =&gt;</span> [...node.childNodes].filter(<span class="function">(<span class="params">node</span>) =&gt;</span> node <span class="keyword">instanceof</span> Text))</span><br><span class="line">    .flat(<span class="literal">Infinity</span>)</span><br><span class="line">    .forEach(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> span = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>)</span><br><span class="line">      node.parentNode.insertBefore(span, node)</span><br><span class="line">      span.appendChild(node)</span><br><span class="line">      span.style = <span class="string">`</span></span><br><span class="line"><span class="string">        background: #f2f2f2;</span></span><br><span class="line"><span class="string">        color: transparent !important;</span></span><br><span class="line"><span class="string">      `</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(代码链接：<a href="https://zhuanlan.zhihu.com/p/166009071" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/166009071</a>)</p>
<p>发现有“…”这样的语法。查了一下文档，原来这是js中的展开语法。MDN上的定义为:</p>
<blockquote>
<p><strong>展开语法(Spread syntax),</strong> 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。</p>
</blockquote>
<p>以上面代码中的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...document.querySelectorAll(<span class="string">'*'</span>)</span><br></pre></td></tr></table></figure>
<p>为例，在chrome中的运行结果是：</p>
<p><img src="https://pic.downk.cc/item/5f29032d14195aa59450fba2.jpg" alt></p>
<p>在这里，…把一个nodelist展开来，作为Array的构造参数。</p>
<p>再看一个在String中应用的一个例子</p>
<p><img src="https://pic.downk.cc/item/5f29040c14195aa5945151b3.jpg" alt></p>
<p>不难明白，“…“的作用其实就是把nodelist，string等可迭代的东西展开来。</p>
]]></content>
  </entry>
  <entry>
    <title>POJ - 1330 Nearest Common Ancestors (Tarjan求LCA模板)</title>
    <url>/2019/08/07/POJ-1330-Nearest-Common-Ancestors-Tarjan%E6%B1%82LCA%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/Hefa1fd510a004e5b986687c88e78c004A.jpg" alt></p>
<p>From <strong>Google Earth</strong></p>
<a id="more"></a>
<p><a href="https://cn.vjudge.net/problem/POJ-1330" rel="external nofollow noopener noreferrer" target="_blank">Nearest Common Ancestors</a></p>
<p>其实就是LCA的模板题……屯一下板子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next; </span><br><span class="line">&#125;;</span><br><span class="line">edge es[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    es[cnt].to=v;</span><br><span class="line">    es[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> in[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_fa</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]!=x)    </span><br><span class="line">        fa[x]=find_fa(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find_fa(x);</span><br><span class="line">    <span class="keyword">int</span> fy=find_fa(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        fa[fy]=fx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> qx,qy;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=es[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=es[i].to;</span><br><span class="line">        lca(v);</span><br><span class="line">        join(u,v);</span><br><span class="line">        vis[v]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(qx==u&amp;&amp;vis[qy])</span><br><span class="line">        ans=find_fa(qy);</span><br><span class="line">    <span class="keyword">if</span>(qy==u&amp;&amp;vis[qx])</span><br><span class="line">        ans=find_fa(qx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;;</span><br><span class="line">        mst(vis,<span class="number">0</span>);</span><br><span class="line">        mst(head,<span class="number">-1</span>);mst(in,<span class="number">0</span>);</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        init(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            add(u,v);in[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                rt=i;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;qx&gt;&gt;qy;</span><br><span class="line">        lca(rt);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>POJ - 3734 Block</title>
    <url>/2019/02/22/POJ-3734-Block/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/POJ-3734" rel="external nofollow noopener noreferrer" target="_blank">Block</a></p>
<p>&emsp;&emsp;这是冬训的一道关于矩阵快速幂的题目，但我硬是想不出递推式，于是只好硬推公式(<del>同时部分参考题解</del>)</p>
<a id="more"></a>
<p>推导过程如下图：</p>
<p><img src="https://pic.superbed.cn/item/5c7009045f3e509ed9471ca9" alt></p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ll mod=<span class="number">10007</span>;</span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        ll ans=((fpow(<span class="number">2</span>,n<span class="number">-1</span>)<span class="number">-1</span>)*fpow(<span class="number">2</span>,n<span class="number">-1</span>)+fpow(<span class="number">2</span>,n)+mod)%mod;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1182-食物链</title>
    <url>/2019/01/26/POJ1182-%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1182" rel="external nofollow noopener noreferrer" target="_blank">1182-食物链</a><br><a id="more"></a><br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">int</span> rankrr[<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50000</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findr</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t=pre[x];</span><br><span class="line">    <span class="keyword">if</span>(pre[x]==x)        <span class="keyword">return</span> pre[x];</span><br><span class="line">    r=findr(pre[x]);        <span class="comment">//递归查找根节点 </span></span><br><span class="line">    pre[x]=r;                <span class="comment">//路径压缩 </span></span><br><span class="line">    rankrr[x]=(rankrr[x]+rankrr[t])%<span class="number">3</span>;        <span class="comment">//改变子节点的权值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"find......done\n"</span>); </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"merge......done\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> rx,ry;</span><br><span class="line">    rx=findr(x);</span><br><span class="line">    ry=findr(y);</span><br><span class="line">    pre[rx]=ry;</span><br><span class="line">    rankrr[rx]=(rankrr[y]-rankrr[x]+<span class="number">3</span>+d)%<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fake=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="keyword">int</span> x,y,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">        pre[i]=i;</span><br><span class="line">        rankrr[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;d,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>((x&gt;n||y&gt;n)||(d==<span class="number">2</span>&amp;&amp;x==y))&#123;</span><br><span class="line">            fake++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"fake++\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> fx=findr(x);</span><br><span class="line">            <span class="keyword">int</span> fy=findr(y);</span><br><span class="line">            <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">                merge(x,y,d<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>((rankrr[x]-rankrr[y]+<span class="number">3</span>)%<span class="number">3</span>!=d<span class="number">-1</span>)&#123;</span><br><span class="line">                    fake++;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"fake++\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fake);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先这道题要弄明白的是题目中的“当前的话与前面的某些真的话冲突，就是假话”到底是什么意思。事实上，第一句话肯定是真的，因为假如第一句话是假的，那我们就没有可以判断第二句话真假的依据了。接下来要做的其实只是判断当前的话与上面的话是否冲突。要注意的是，如果当前描述下，x与pre[x]无确定的关系，即fx!=fy，则将当前说法看作是正确的来进行merge。如果有确定的关系，再根据(rankr[x]-rankr[y]+3)%3与d-1的关系来判断对错。如果两者不相等，则为错；否则，对。<br>那么，如何进行集合的划分呢？在这道题里，集合的划分依据不是是否为同类，而是“是否能确定两者之间的关系”。（“ 注意，这里不是根据x与father[x]是否是同类来划分。而是根据“x与father[x]能否确定两者之间的关系”来划分，若能确定x与father[x]的关系，则它们同属一个集合”，摘自题解）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在判断的时候，如果输入的两只动物不是附属于同一个根节点，及不能确定两者的关系，就进行merge，merge的时候还要更新被并入的那个集合（即新的子树）的根节点的权值（即他与新的根节点的关系）。再合并的时候，我们只需要进行根节点的权值更新，被并入的集合的子节点的权值通过findr（）顺带更新（这也是带权并查集的精髓和难点）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这道题中，并查集并不是要体现层级关系。同一棵树中的各个节点之间其实只是平等的几何元素关系，而没有上下级关系（或者说上下级关系对这道题而言没用）</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1328-Radar Installation(贪心)</title>
    <url>/2019/01/26/POJ1328-Radar-Installation-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>&#160; &#160; &#160; &#160;思路：以岛屿为圆心作半径为d的圆，则每个可以被覆盖的岛屿（即y&lt;=d）都可以在x轴上形成一个或两个交点。也就是说，每个岛屿在画圆后都在x轴上形成一个长度大于或等于0的区间。这些区间即为安装雷达的地方。接下来要做的就是将这些区间的相交区间（即交集）找出来并计数。相交区间的数目即为雷达的数目。<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;island;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> L;</span><br><span class="line">    <span class="keyword">double</span> R;</span><br><span class="line">&#125;interval;</span><br><span class="line">island a[<span class="number">1010</span>];</span><br><span class="line">interval b[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> interval &amp;a,<span class="keyword">const</span> interval &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.L&lt;b.L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">int</span> n,test;</span><br><span class="line">    <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">for</span>(test=<span class="number">1</span>,num=<span class="number">0</span>;<span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;n,&amp;d)!=EOF;test++)</span><br><span class="line">    &#123;    </span><br><span class="line">        ans=<span class="number">0</span>;no=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!n&amp;&amp;!d)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">            <span class="keyword">if</span>(a[i].y&gt;d)&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case %d: -1\n"</span>,test);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            b[i].L=a[i].x-<span class="built_in">sqrt</span>(d*d-((a[i].y)*(a[i].y)));</span><br><span class="line">            b[i].R=a[i].x+<span class="built_in">sqrt</span>(d*d-((a[i].y)*(a[i].y)));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>,ans=<span class="number">0</span>;i&lt;=n;i++)&#123;        <span class="comment">//i++：当找到一个相交区间后，查找下一个相交区间的起始左端点值即为上一个相交区间（就是已经被找到了的那个）的左端点值的下一个</span></span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">double</span> right=b[i].R;</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(b[j].L&lt;=right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(b[j].R&lt;right)&#123;</span><br><span class="line">                        right=b[j].R;        <span class="comment">//将右端点左移</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;            <span class="comment">//将左端点右移</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,test,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;找相交区间部分的讲解：找相交区间就是要找到尽可能大的左端点和右端点。先将结构数组b[]按每个区间的左端点大小升序排列，这样是为了找到尽可能大的左端点。每次循环中同时将左端点右移、右端点左移直到左端点大于右端点。因为每一轮循环都必定能找到一个相交区间，故每一轮循环都要ans++。</p>
<p>原做法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;island;</span><br><span class="line">island a[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> island &amp;a,<span class="keyword">const</span> island &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> tag[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">int</span> n,test;</span><br><span class="line">    <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">for</span>(test=<span class="number">1</span>,num=<span class="number">0</span>;<span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;n,&amp;d)!=EOF;test++)</span><br><span class="line">    &#123;    </span><br><span class="line">        no=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">if</span>(!n&amp;&amp;!d)        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">            <span class="keyword">if</span>(a[i].y&gt;d)</span><br><span class="line">                no=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(no)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case %d: -1\n"</span>,test);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="comment">//每次都以最左边的为被圈入圆圈中的岛屿为参考来确定安装点的坐标，直到全部都被覆盖完</span></span><br><span class="line">        sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">        <span class="keyword">int</span> st=<span class="number">1</span>,cov;</span><br><span class="line">        <span class="keyword">double</span> xtmp;</span><br><span class="line">        <span class="keyword">for</span>(cov=<span class="number">0</span>;cov!=n;)&#123;</span><br><span class="line">                xtmp=a[st].x+<span class="built_in">sqrt</span>(d*d-(a[st].y)*(a[st].y));</span><br><span class="line">                <span class="keyword">for</span>(i=st;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(((xtmp-a[i].x)*(xtmp-a[i].x)+(a[i].y)*(a[i].y))&gt;d*d)&#123;</span><br><span class="line">                    st=i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tag[i]=<span class="literal">true</span>;</span><br><span class="line">                cov++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,test,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个做法的思路是每次都以最左边的未被覆盖的岛屿来确定雷达的坐标（即刚好能覆盖最左边的这个岛屿），循环地去做，直到所有的岛屿都被覆盖。但这样做的问题在于，并不一定能尽可能多地覆盖岛屿。比如说这组数据：</p>
<p>2 3<br>0 2<br>1 3</p>
<p>&#160; &#160; &#160; &#160;正确输出是1，但用这种方法做出来的答案是2。以最左边的未被覆盖的点(0,2)为基准确定雷达坐标后，雷达并不能把(1,3)覆盖。但实际上，只需要一个在x=1上的雷达就可以将两个岛屿覆盖。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1015 - Jury Compromise</title>
    <url>/2019/07/22/POJ1015-Jury-Compromise/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1zWoua1T2gK0jSZFvq6xnFXXaO.jpg" alt></p>
<p>Photo by Johannes Plenio from Pexels<br><a id="more"></a><br><a href="https://cn.vjudge.net/problem/POJ-1015" rel="external nofollow noopener noreferrer" target="_blank">Jury Compromise</a></p>
<p>一道dp题，感觉有一定的难度。</p>
<p>一开始的时候发现它很像是01背包，将每个人看作是一件物品，需要取的人数看作是背包的总容量，求要怎样取物品(选人)才能使得$\sum p_i-\sum d_i$最小；同时，如果存在$\sum p_i-\sum d_i$相同的情况，则取$\sum p_i+\sum d_i$较大的那一种方案。</p>
<p>一开始尝试了这样的写法，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> last=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((dp1[j<span class="number">-1</span>]+abs_(d[i]-p[i])&lt;dp1[j])||(dp1[j<span class="number">-1</span>]+abs_(d[i]-p[i])==dp1[j]&amp;&amp;dp2[j<span class="number">-1</span>]+d[i]+p[i]&gt;dp2[j]))&#123;</span><br><span class="line">            dp1[j]=dp1[j<span class="number">-1</span>]+abs_(d[i]-p[i]);</span><br><span class="line">            dp2[j]=dp2[j<span class="number">-1</span>]+(d[i]+p[i]);</span><br><span class="line">            pre[i]=last;</span><br><span class="line">            last=i;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emmmmm很明显是不行的OTZ</p>
<p>后来又尝试了另一种写法，即是使用一个二维dp数组，参照<a href="https://www.luogu.org/problemnew/show/P1855" rel="external nofollow noopener noreferrer" target="_blank">洛谷P1555</a>的做法来写，将$\sum p_i+\sum d_i$固定并对它进行枚举，代码大致长这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">800</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=dp[i][j];</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i-d[k]-p[k]][j<span class="number">-1</span>]+abs_(d[k]-p[k]));</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]!=temp)&#123;</span><br><span class="line">                pre[k]=last;</span><br><span class="line">                last=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种做法也不可……但至少固定住一个这一想法是正确的。</p>
<p>正确的做法应该是固定住差，然后求能使和最大的方案。dp[j][k]表示在取j人，差为k的所有方案中，和最大的那个方案的和。对于方案dp[j][k]我们不难发现它是由某个方案dp[j-1][x]递推而来的。我们要找的是这样的一个候选人i：此人在方案dp[j-1][x]中没有被选中，且此人满足$x+p[i]-d[j]=k$。找出这个人，并在所有满足要求的dp[j-1][x]中，找到和最大的那一个，从而转移的到dp[j][k]。这题还需要输出被选的人，其实就是记录路径。只需要记录下转移得到dp[j][k]时的候选人i即可。另外，由于计算差的时候可能会产生负数从而影响数组操作，所以要做一定的偏移，保证不会产生负数。因为差值的绝对值不会超过20*m，所以将整个差值可能出现的区间向右偏移20*m即可。还有一点，在计算prosecution sum和defence sum时，因为dp求得的时$\sum p_i+\sum d_i$，所以要做一定的处理得到$\sum p_i$和$\sum d_i$。具体做法是：</p>
<script type="math/tex; mode=display">
\sum p_i = \frac{\sum (p_i+d_i) + (\sum p_i - \sum d_i)}{2}\\
\sum d_i = \frac{\sum (p_i+d_i) - (\sum p_i - \sum d_i)}{2}</script><p>实际操作时还要记得减去偏移把区间移回来</p>
<p>更详细的见注释</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">300</span>],p[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">30</span>][<span class="number">1000</span>];        </span><br><span class="line"><span class="keyword">int</span> path[<span class="number">30</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="comment">//dp[j][k]表示在取j人,差为k的所有方案中,和最大的那个方案的和 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF&amp;&amp;n&amp;&amp;m)&#123;</span><br><span class="line">        <span class="keyword">int</span> sumd=<span class="number">0</span>;<span class="keyword">int</span> sump=<span class="number">0</span>;</span><br><span class="line">        mst(dp,<span class="number">-1</span>);</span><br><span class="line">        mst(path,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;p[i],&amp;d[i]);</span><br><span class="line">        <span class="keyword">int</span> offset=<span class="number">20</span>*m;        <span class="comment">//因为差所在的区间为[-20*m,20*m],所以偏移为20*m </span></span><br><span class="line">        dp[<span class="number">0</span>][offset]=<span class="number">0</span>;        <span class="comment">//相当于dp[0][0]=0 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;    <span class="comment">//从1个人推到m个人 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=offset*<span class="number">2</span>;k++)&#123;    <span class="comment">//偏移后,差出现的区间在[0,20*m] </span></span><br><span class="line">                <span class="keyword">if</span>(dp[j][k]&gt;=<span class="number">0</span>)&#123;        <span class="comment">//如果该方案存在 </span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;    <span class="comment">//枚举n个人 </span></span><br><span class="line">                        <span class="keyword">if</span>(dp[j][k]+d[i]+p[i]&gt;dp[j+<span class="number">1</span>][k+p[i]-d[i]])&#123;</span><br><span class="line">                            <span class="keyword">int</span> tmp1=j;</span><br><span class="line">                            <span class="keyword">int</span> tmp2=k;</span><br><span class="line">                            <span class="keyword">while</span>(tmp1&gt;<span class="number">0</span>&amp;&amp;path[tmp1][tmp2]!=i)&#123;        <span class="comment">//检查之前i这个人之前是否出现过 </span></span><br><span class="line">                                tmp2-=p[path[tmp1][tmp2]]-d[path[tmp1][tmp2]];</span><br><span class="line">                                tmp1--;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(tmp1==<span class="number">0</span>)&#123;        <span class="comment">//i没有出现过 </span></span><br><span class="line">                                dp[j+<span class="number">1</span>][k+p[i]-d[i]]=dp[j][k]+d[i]+p[i];</span><br><span class="line">                                path[j+<span class="number">1</span>][k+p[i]-d[i]]=i;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp1,tmp2;</span><br><span class="line">        tmp1=offset;</span><br><span class="line">        tmp2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxi=-INF;<span class="keyword">int</span> tag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dp[m][tmp1+tmp2]&lt;<span class="number">0</span>&amp;&amp;dp[m][tmp1-tmp2]&lt;<span class="number">0</span>)        </span><br><span class="line">            tmp2++;</span><br><span class="line">        <span class="keyword">int</span> sub;</span><br><span class="line">        <span class="keyword">if</span>(dp[m][tmp1+tmp2]&gt;dp[m][tmp1-tmp2])</span><br><span class="line">            sub=tmp1+tmp2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sub=tmp1-tmp2;</span><br><span class="line">        <span class="comment">//从中间开始找第一个可用的方案,对应的差值就是所求最小差值</span></span><br><span class="line">        <span class="comment">//然而这是为什么呢...... </span></span><br><span class="line">        sump=(dp[m][sub]+(sub-offset))/<span class="number">2</span>;</span><br><span class="line">        sumd=(dp[m][sub]-(sub-offset))/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Jury #%d\n"</span>,++kase);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Best jury has value %d for prosecution and value %d for defence:\n"</span>,sump,sumd);</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">int</span> j;<span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>,j=m;i&lt;=m;i++,j--)&#123;        <span class="comment">//根据路径找答案 </span></span><br><span class="line">            <span class="keyword">int</span> now=path[j][sub];</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">            sub-=p[now]-d[now];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>,ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>有难度的DP</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1384 - Piggy Bank</title>
    <url>/2019/02/17/POJ1384-Piggy-Bank/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/POJ-1384" rel="external nofollow noopener noreferrer" target="_blank">Piggy Bank</a></p>
<p>&emsp;&emsp;完全背包的经典问题，只要把状态转移方程的max改为min，同时将dp[0]设为0，其余则设为INF即可( 因为要求是否能装满 )</p>
<a id="more"></a>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10010</span>;i++)</span><br><span class="line">        dp[i]=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        init();dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        mst(val,<span class="number">0</span>);mst(w,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> empty,with_coin;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;empty&gt;&gt;with_coin;</span><br><span class="line">        <span class="keyword">int</span> vtot=with_coin-empty;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;val[i]&gt;&gt;w[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=vtot;j++)</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j-w[i]]+val[i]);</span><br><span class="line">        <span class="keyword">if</span>(dp[vtot]==INF)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is impossible."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"The minimum amount of money in the piggy-bank is "</span>&lt;&lt;dp[vtot]&lt;&lt;<span class="string">"."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>完全背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1087 A plug for UNIX</title>
    <url>/2019/04/24/POJ1087-A-plug-for-UNIX/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1Wy3ASBLoK1RjSZFuq6xn0XXab.jpg" alt></p>
<p>(图文无关)</p>
<a id="more"></a>
<p><a href="https://cn.vjudge.net/problem/POJ-1087" rel="external nofollow noopener noreferrer" target="_blank">A plug for UNIX</a></p>
<h4 id="正题开始前的吐槽"><a href="#正题开始前的吐槽" class="headerlink" title="正题开始前的吐槽"></a>正题开始前的吐槽</h4><ul>
<li>这强行UNIX我给满分……</li>
<li>输入真恶心，建图真麻烦……</li>
</ul>
<h4 id="正题开始"><a href="#正题开始" class="headerlink" title="正题开始"></a>正题开始</h4><p>这是一道最大流的问题，题目大意就是说有若干个设备，每个设备都对应一种插头类型；有若干种插座类型，同时还有若干种插头类型转换器，转换器的数量是无限的，问不能成功配对(即插头插到对应类型的插座上)的设备最少是多少。</p>
<p>思路的话其实不难想：可以建立一个超级源点和一个超级汇点，从源点到每种设备之间各连一条容量为1的边；从插座到汇点之间各连一条容量为1的边。对于转换器，很容易想到将所有转换关系转换为一张有向图。我们可以使用floyd求该图上任意两点间的最长路，以此来计算两点之间是否连通，即两种插头之间是否可以转化。如果插头A可以转换为插头B，在网络上将插头类型为A的设备与插座类型为B的插座间连一条边，容量为1(其实只要&gt;=1即可)。最后Dinic求一下最大流，最大流对应的就是最多可以匹配的设备。</p>
<div class="note warning">
    <p>floyd求最长路时最好把点数调大一点，500比较合适！否则会WA！</p>
</div>

<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> con[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">string</span> type;</span><br><span class="line">    node(<span class="keyword">int</span> id,<span class="built_in">string</span> type):id(id),type(type)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    ull rev;</span><br><span class="line">    edge(<span class="keyword">int</span> to,<span class="keyword">int</span> cap,ull rev):to(to),cap(cap),rev(rev)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;    </span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; rec;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; plug;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; gra[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> cur[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> nn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=nn;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nn;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=nn;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(con[i][k]&amp;&amp;con[k][j])</span><br><span class="line">                    con[i][j]=<span class="built_in">max</span>(con[i][j],con[i][k]+con[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//mp用于floyd时求连通性</span></span><br><span class="line"><span class="keyword">int</span> dep[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">    dep[s]=<span class="number">0</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;gra[now].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gra[now][i].cap&gt;<span class="number">0</span>&amp;&amp;dep[gra[now][i].to]==<span class="number">-1</span>)&#123;</span><br><span class="line">                dep[gra[now][i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line">                que.push(gra[now][i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> t,<span class="keyword">int</span> mini)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st==t)</span><br><span class="line">        <span class="keyword">return</span> mini;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>&amp; i=cur[st];i&lt;gra[st].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        edge&amp; now=gra[st][i];</span><br><span class="line">        <span class="keyword">if</span>(now.cap&gt;<span class="number">0</span>&amp;&amp;dep[now.to]==dep[st]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> d=dfs(now.to,t,<span class="built_in">min</span>(now.cap,mini));</span><br><span class="line">            <span class="keyword">if</span>(d&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                now.cap-=d;</span><br><span class="line">                gra[now.to][now.rev].cap+=d;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span>(bfs(st,e))&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur,<span class="number">0</span>,<span class="keyword">sizeof</span>(cur));</span><br><span class="line">        <span class="keyword">while</span>((tmp=dfs(st,e,INF))&gt;<span class="number">0</span>)</span><br><span class="line">            ans+=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gra[from].push_back(edge(to,wei,gra[to].<span class="built_in">size</span>()));</span><br><span class="line">    gra[to].push_back(edge(from,<span class="number">0</span>,gra[from].<span class="built_in">size</span>()<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(con,<span class="number">0</span>,<span class="keyword">sizeof</span>(con));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;<span class="keyword">int</span> idx=<span class="number">1</span>;<span class="keyword">int</span> idx1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">        rec.push_back(node(idx1,str));</span><br><span class="line">        idx1++;</span><br><span class="line">        mp[str]=idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">string</span> str1,str2;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;str2;</span><br><span class="line">        plug.push_back(node(idx1,str2));</span><br><span class="line">        idx1++;</span><br><span class="line">        <span class="keyword">if</span>(!mp.count(str2))</span><br><span class="line">            mp[str2]=idx++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">string</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(!mp.count(a))</span><br><span class="line">            mp[a]=idx++;</span><br><span class="line">        <span class="keyword">if</span>(!mp.count(b))</span><br><span class="line">            mp[b]=idx++;</span><br><span class="line">        con[mp[a]][mp[b]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    floyd(idx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;plug.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;rec.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            node&amp; n1=plug[i];</span><br><span class="line">            node&amp; n2=rec[j];</span><br><span class="line">            <span class="keyword">if</span>(con[mp[n1.type]][mp[n2.type]]||n1.type==n2.type)&#123;        <span class="comment">//转换器之间连边</span></span><br><span class="line">                add(n1.id,n2.id,<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;plug.<span class="built_in">size</span>();i++)</span><br><span class="line">        add(<span class="number">0</span>,plug[i].id,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rec.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        add(rec[i].id,<span class="number">500</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxi_flow=Dinic(<span class="number">0</span>,<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m-maxi_flow&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>因为这题用到了最短(长)路，所以顺便复习以下最短路常用的三种算法：</p>
<h5 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h5><p>可用于求单个点到图上其他点的最短路；基于贪心思想；不可用于有负权边的图</p>
<h5 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h5><p>可用于求图上任意两个点之间的最短路；基于动态规划思想；可以处理有负权边的图，但不能处理有负环的图</p>
<h5 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h5><p>队列优化版的Bellmon-Ford，可用于求单个点到图上其他点的最短路；可以处理有负权边的图；还可以用于判断一个图是否有负环，即判断某个点的入队次数是否大于n(图上点的总数)，如果是就说明存在负环。要注意的是，SPFA可能会被恶意数据卡掉，谨慎使用</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>网络流</category>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>难建图</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1833 - 排列</title>
    <url>/2019/02/24/POJ1833-%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/POJ-1833" rel="external nofollow noopener noreferrer" target="_blank">排列</a></p>
<p>&emsp;&emsp;题意是输出给定排列的后第k个排列。这里用的是<algorithm>里的next_permutation()，比较方便。</algorithm></p>
<a id="more"></a>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1025</span>],tmp[<span class="number">1025</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pr==<span class="number">0</span>)&#123;</span><br><span class="line">            pr++; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,arr[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        mst(arr,<span class="number">0</span>);mst(tmp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">        <span class="keyword">bool</span> flag;</span><br><span class="line">        <span class="keyword">while</span>(k)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=next_permutation(arr,arr+n);</span><br><span class="line">            <span class="keyword">if</span>(flag=<span class="number">0</span>)        </span><br><span class="line">            &#123;</span><br><span class="line">                sort(arr,arr+n);</span><br><span class="line">                next_permutation(arr,arr+n);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">/*原本的想法是如果当前序列是字典序最大的序列时，后面不会再有序列，也就是说next_permutation不会再排列，所以要把序列排一下序，使它回到字典序最小的状态，重新开始；可是后来发现这个函数很智能，如果没有下一个排列的话，它会自动倒回到字典序最小的情况。也就是说，这个if其实是可以不要的*/</span></span><br><span class="line">            k-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(arr,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1985 &amp; HDU2196 求树的直径模板</title>
    <url>/2019/07/31/POJ1985-HDU2196-%E6%B1%82%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H3f36fb9928484479b586fc1764a50805L.jpg" alt></p>
<p>Photo by <strong>Nick Kwan</strong> from <strong>Pexels</strong></p>
<a id="more"></a>
<p>这篇文章的主要目的是为了屯模板……</p>
<p><a href="https://cn.vjudge.net/problem/POJ-1985" rel="external nofollow noopener noreferrer" target="_blank">POJ1985 Cow Marathon</a><br>裸题，直接两边dfs求出直径即可（输入里面的那个方向是没用的……）<br>代码如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50000</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">    ll wei;</span><br><span class="line">&#125;;</span><br><span class="line">node es[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line">ll dis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    es[cnt].to=v;</span><br><span class="line">    es[cnt].wei=wei;</span><br><span class="line">    es[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    dis[st]=dis[fa]+es[fa].wei;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[st];i!=<span class="number">-1</span>;i=es[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=es[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)    <span class="keyword">continue</span>;</span><br><span class="line">        dis[to]=dis[st]+es[i].wei;</span><br><span class="line">        dfs(to,st);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        mst(head,<span class="number">-1</span>);cnt=<span class="number">0</span>;</span><br><span class="line">        mst(dis,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,L;<span class="keyword">char</span> dir;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;L&gt;&gt;dir;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)    start=a;</span><br><span class="line">            add(a,b,L);add(b,a,L);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> end_;ll ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i]&gt;ans)&#123;</span><br><span class="line">                ans=dis[i];</span><br><span class="line">                end_=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;"end = "&lt;&lt;end_&lt;&lt;endl;</span></span><br><span class="line">        mst(dis,<span class="number">0</span>);</span><br><span class="line">        dfs(end_,<span class="number">0</span>);</span><br><span class="line">        ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dis[i]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://cn.vjudge.net/problem/HDU-2196" rel="external nofollow noopener noreferrer" target="_blank">HDU2196 Computer</a></p>
<p>对于每一个点，其最大距离即为直径的两个端点到该点的距离的较大值。</p>
<p>做法是跑三次bfs。第一次用于求出直径的一个端点；第二次从该端点出发找另一个端点，同时算出从该端点到其他点的距离；第三次从找出来的另一个端点出发算出它到其他点的距离。</p>
<p>代码如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next,wei;</span><br><span class="line">&#125;;</span><br><span class="line">node es[<span class="number">80005</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">40005</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    es[cnt].to=v;</span><br><span class="line">    es[cnt].wei=wei;</span><br><span class="line">    es[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis1[<span class="number">40005</span>];</span><br><span class="line"><span class="keyword">int</span> dis2[<span class="number">40005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">40005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs1</span><span class="params">(<span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(st);</span><br><span class="line">    mst(vis,<span class="number">0</span>);mst(dis1,<span class="number">0</span>);</span><br><span class="line">    dis1[st]=<span class="number">0</span>;vis[st]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxi_len=dis1[st];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">point</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i!=<span class="number">-1</span>;i=es[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=es[i].to;</span><br><span class="line">            <span class="keyword">if</span>(vis[to]==<span class="number">0</span>)&#123;</span><br><span class="line">                vis[to]=<span class="number">1</span>;</span><br><span class="line">                dis1[to]=dis1[now]+es[i].wei;</span><br><span class="line">                que.push(to);</span><br><span class="line">                <span class="keyword">if</span>(maxi_len&lt;dis1[to])&#123;</span><br><span class="line">                    maxi_len=dis1[to];</span><br><span class="line">                    <span class="built_in">point</span>=to;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">point</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs2</span><span class="params">(<span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(st);</span><br><span class="line">    mst(vis,<span class="number">0</span>);mst(dis2,<span class="number">0</span>);</span><br><span class="line">    dis2[st]=<span class="number">0</span>;vis[st]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxi_len=dis2[st];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">point</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i!=<span class="number">-1</span>;i=es[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=es[i].to;</span><br><span class="line">            <span class="keyword">if</span>(vis[to]==<span class="number">0</span>)&#123;</span><br><span class="line">                vis[to]=<span class="number">1</span>;</span><br><span class="line">                dis2[to]=dis2[now]+es[i].wei;</span><br><span class="line">                que.push(to);</span><br><span class="line">                <span class="keyword">if</span>(maxi_len&lt;dis2[to])&#123;</span><br><span class="line">                    maxi_len=dis2[to];</span><br><span class="line">                    <span class="built_in">point</span>=to;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">point</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">//    freopen("data_generator.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("computer.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        mst(head,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v,wei;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;v,&amp;wei);</span><br><span class="line">            add(i,v,wei);</span><br><span class="line">            add(v,i,wei);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1=bfs1(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> p2=bfs2(p1);            <span class="comment">//得到端点1到其他点的距离 </span></span><br><span class="line">        bfs1(p2);                <span class="comment">//得到端点2到其他点的距离 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">max</span>(dis1[i],dis2[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2063 - Investment</title>
    <url>/2019/02/22/POJ2063-Investment/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/POJ-2063" rel="external nofollow noopener noreferrer" target="_blank">Investment</a></p>
<p>&emsp;&emsp;其实就是做若干次的完全背包，每做一次都更新一下钱的总数。需要注意的是，因为钱的总数可能会很大，所以需要进行缩小，以免MLE。缩小方法是，因为每一种证券的价钱都是1000的倍数，故我们可以将它们的价钱都缩小为原来的1/1000(而利息不变)。</p>
<a id="more"></a>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bond</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,inte;</span><br><span class="line">&#125;;</span><br><span class="line">bond arr[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">begin</span>;<span class="keyword">int</span> year;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;<span class="built_in">begin</span>&gt;&gt;year;</span><br><span class="line">        <span class="keyword">int</span> vtot=<span class="built_in">begin</span>/<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=d;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i].val&gt;&gt;arr[i].inte;</span><br><span class="line">            arr[i].val/=<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="built_in">begin</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;year;y++)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">int</span> maxi=<span class="number">-1</span>;mst(dp,<span class="number">0</span>);</span><br><span class="line">            vtot=ans/<span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=d;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=arr[i].val;j&lt;=vtot;j++)</span><br><span class="line">                &#123;    </span><br><span class="line">                    <span class="keyword">int</span> tmp=arr[i].inte;</span><br><span class="line">                    dp[j]=<span class="built_in">max</span>(dp[j],dp[j-arr[i].val]+tmp);</span><br><span class="line">                    maxi=<span class="built_in">max</span>(maxi,dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=dp[vtot];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>完全背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2159-Ancient Cipher</title>
    <url>/2019/01/26/POJ2159-Ancient-Cipher/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2159" rel="external nofollow noopener noreferrer" target="_blank">Ancient Cipher</a><br><a id="more"></a><br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> ori[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">char</span> sec[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> na[<span class="number">30</span>],nb[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> len1,len2;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,sec,ori)!=EOF)</span><br><span class="line">    &#123;    </span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        len1=<span class="built_in">strlen</span>(ori);</span><br><span class="line">        len2=<span class="built_in">strlen</span>(sec);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len1;i++)</span><br><span class="line">            na[ori[i]-<span class="string">'A'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len2;i++)</span><br><span class="line">            nb[sec[i]-<span class="string">'A'</span>]++;</span><br><span class="line">        sort(na,na+<span class="number">26</span>);sort(nb,nb+<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(na[i]!=nb[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题是真的坑！因为题目并没有说置换密码一定就是将某个单词的下一个单词用来置换这一个单词，它完全有可能是乱来的！比如说A-C,B-E,C-D,D-F,E-G,F-H,然后从I开始，后面的字母又按照“用下一个字母置换该字母”的方法来置换当前字母。应该注意到的是，无论是题目中的那种加密方式（置换、排列），都无法改变字母的出现频度。因此，只需要比较输入的两个字符串的字母出现频度即可。这里的所说的“比较字母出现频度”，并不是说比较某一个字母在第一个字符串中的出现频度以及在第二个字符串中的出现频度；而是比较“是不是都有某个字母出现了若干次”，比如说，假如字符串A的字母出现频度列表为</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字母</th>
<th>频度</th>
</tr>
</thead>
<tbody>
<tr>
<td>D</td>
<td>2次</td>
</tr>
<tr>
<td>E</td>
<td>3次</td>
</tr>
<tr>
<td>R</td>
<td>8次</td>
</tr>
</tbody>
</table>
</div>
<p>而另一个字符串B的字母出现频度列表为</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字母</th>
<th>频度</th>
</tr>
</thead>
<tbody>
<tr>
<td>Q</td>
<td>2次</td>
</tr>
<tr>
<td>U</td>
<td>3次</td>
</tr>
<tr>
<td>P</td>
<td>8次</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那这两个字符串也是相互匹配的！为什么？因为我不知道置换加密的规则到底是怎样的，但我知道它是一一对应的，也就是说不会改变字母出现频度的。有可能它的规则就是D-Q，E-U，R-P，这样也是可能的！所以说只需要比较两个字符串的字母出现频度即可</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>入门</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2236 - Wireless Network</title>
    <url>/2019/02/27/POJ2236-Wireless-Netword/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/POJ-2236" rel="external nofollow noopener noreferrer" target="_blank">Wireless Network</a></p>
<p>一道并查集模板题。</p>
<a id="more"></a>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> posx[<span class="number">1200</span>],posy[<span class="number">1200</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1200</span>];</span><br><span class="line"><span class="keyword">int</span> been[<span class="number">1200</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==pre[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> pre[x]=findr(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> ax,<span class="keyword">int</span> ay,<span class="keyword">int</span> bx,<span class="keyword">int</span> by)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ax-bx)*(ax-bx)+(ay-by)*(ay-by);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rep</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x,<span class="keyword">int</span> n,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> ri=findr(i);</span><br><span class="line">    <span class="keyword">int</span> rx=findr(x);</span><br><span class="line">    <span class="keyword">if</span>(dist(posx[x],posy[x],posx[i],posy[i])&lt;=d*d)    </span><br><span class="line">        pre[rx]=ri;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> ra=findr(a);</span><br><span class="line">    <span class="keyword">int</span> rb=findr(b);</span><br><span class="line">    <span class="keyword">if</span>(ra==rb)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> d;<span class="keyword">int</span> p,q;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;d)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;posx[i],&amp;posy[i]);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            pre[i]=i;</span><br><span class="line">        mst(been,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'O'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">                been[p]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(been[i])</span><br><span class="line">                        rep(i,p,n,d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'S'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;p,&amp;q);</span><br><span class="line">                <span class="keyword">if</span>(check(p,q))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"SUCCESS\n"</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"FAIL\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2249 - Binomial Showdown </title>
    <url>/2019/02/24/POJ2249-Binomial-Showdown/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/POJ-2249" rel="external nofollow noopener noreferrer" target="_blank">Binomial Showdown</a></p>
<p>&emsp;&emsp;使用C(n,k)与C(n,k-1)的递推关系来求组合数。</p>
<a id="more"></a>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">ll ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    mst(ans,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n)&#123;</span><br><span class="line">        ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n-m&lt;m)</span><br><span class="line">            m=n-m;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">                ans[i]=(n-i+<span class="number">1</span>)*ans[i<span class="number">-1</span>]/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2449 - Remmarguts&#39; Date</title>
    <url>/2019/08/20/POJ2449-Remmarguts-Date/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H9cd98d6e6a1347cfb0327ada94690b69u.jpg" alt></p>
<a id="more"></a>
<p><a href="https://cn.vjudge.net/problem/POJ-2449" rel="external nofollow noopener noreferrer" target="_blank">Remmarguts’s Date</a></p>
<p>第一场区域赛选拔赛的题目，虽然是板子题，但这个板子我是第一次敲……不仅板子是第一次敲，k短路也是第一次敲……</p>
<p>题意就是让你求一张图上从起点S到终点T的k短路。这里我们使用A*来进行求解。构造一个函数$h[x] = f[x] + g[x]$，其中f[x]表示当前搜索时的代价,也就是边权；g[x]表示的是从当前点到终点的最短路,这可以通过以T为起点反向dijkstra得到。对于终点T，当它第k次从队首中被拿出来时，说明此时已经找到了k短路。事实上这里的A*只是使用估价函数优化了的BFS，是简化了的A*，真正的A*还需要维护OpenList和CloseList两个集合。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v,c;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">    <span class="keyword">int</span> nxt1;</span><br><span class="line">    edge()&#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span><br><span class="line">        :u(u),v(v),c(c)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">edge es[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> head1[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> tot_e;        <span class="comment">//总边数 </span></span><br><span class="line"><span class="keyword">int</span> st,ed,k;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pro</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,c;</span><br><span class="line">    pro()&#123;&#125;</span><br><span class="line">    pro(<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span><br><span class="line">        :v(v),c(c)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    h[x] = f[x] + g[x]</span></span><br><span class="line"><span class="comment">    其中f[x]表示当前搜索时的代价,也就是边权</span></span><br><span class="line"><span class="comment">    g[x]表示的是从当前点到终点的最短路,可以</span></span><br><span class="line"><span class="comment">    反向跑一遍dij得到 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> pro&amp; pa) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c+dis[v]&gt;pa.c+dis[pa.v];        <span class="comment">//估价函数 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mst(head,<span class="number">-1</span>);mst(head1,<span class="number">-1</span>);</span><br><span class="line">    tot_e=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//链式前向星加边</span></span><br><span class="line">    es[tot_e]=edge(u,v,c);</span><br><span class="line">    es[tot_e].nxt=head[u];head[u]=tot_e;</span><br><span class="line">    es[tot_e].nxt1=head1[v];head1[v]=tot_e++;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pro&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mst(vis,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    dis[i]=INF;</span><br><span class="line">    dis[start]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())    que.pop();</span><br><span class="line">    que.push(pro(start,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        pro cur=que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[cur.v])    <span class="keyword">continue</span>;</span><br><span class="line">        vis[cur.v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head1[cur.v];i!=<span class="number">-1</span>;i=es[i].nxt1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[es[i].u]&gt;dis[cur.v]+es[i].c)&#123;</span><br><span class="line">                dis[es[i].u]=dis[cur.v]+es[i].c;</span><br><span class="line">                que.push(pro(es[i].u,<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Astar</span><span class="params">(<span class="keyword">int</span> start)</span>        <span class="comment">//其实这里只是经过了启发式优化的BFS </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())    que.pop();</span><br><span class="line">    que.push(pro(start,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        pro cur=que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span>(cur.v==ed)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">1</span>)    k--;        <span class="comment">//终点第k次入队时,说明找到了k短路 </span></span><br><span class="line">            <span class="keyword">else</span>    <span class="keyword">return</span> cur.c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[cur.v];i!=<span class="number">-1</span>;i=es[i].nxt)</span><br><span class="line">            que.push(pro(es[i].v,cur.c+es[i].c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u,v,c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;c);</span><br><span class="line">            add(u,v,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;st,&amp;ed,&amp;k);</span><br><span class="line">        dijkstra(ed);</span><br><span class="line">        <span class="keyword">if</span>(dis[st]==INF)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(st==ed)    k++;</span><br><span class="line">            <span class="keyword">int</span> ans=Astar(st);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>A*</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>k短路</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2528 - Mayor&#39;s poster</title>
    <url>/2019/05/18/POJ2528-Mayor-s-poster/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1HHj9bLWG3KVjSZFgq6zTspXaO.jpg" alt></p>
<p>Photo by Kellie Churchman from Pexels<br><a id="more"></a></p>
<p><a href="https://cn.vjudge.net/problem/POJ-2528" rel="external nofollow noopener noreferrer" target="_blank">Mayor’s poster</a></p>
<p>题意说的是，有一面非常非常长的墙，现在要向这面墙上贴上若干张宽度不等的海报，问贴完后有多少张海报能看得到(也就是有多少张海报没有被完全覆盖)。</p>
<p>抽象一下问题就是，有一段无限长的线段，现在要对线段上的某一段染色，问经过若干次染色后，线段上一共有多少种颜色。</p>
<p>因为涉及到了区间修改(贴海报),所以很自然想到用线段树去维护。一开始我的想法是写个线段树去维护墙壁上的海报，“贴海报”对应将某个区间上的值设置为当前要贴的海报对应的id，然后再搞个查询区间和的操作，通过区间和来判断当前要贴的海报的状态(一共三种状态：1.完全不会覆盖当前区间已经存在的海报，此时对应区间和为0；2.会部分覆盖当前区间已经存在的海报；3.会完全覆盖当前区间已经存在的海报)……但这样做其实很不好实现，最明显的问题就是要怎么判断会完全覆盖这种情况？还有就是如果当前区间存在不止一张海报，那又怎么搞？</p>
<p>然后后来发现完全不用这么麻烦OTZ，直接搞个set操作(将当前区间的值设为某一个特定的id)，然后query的时候看一下当前区间有没有被贴海报，同时如果有被贴海报的话，海报对应的id是否已经被访问过了(这里要另外用个vis数组维护一下)，同时满足上面这两个条件的话，就说明有一张海报能被看见，所以ans++……</p>
<p>然后还有就是要做一下离散化，因为本题数据范围很大，直接搞的话感觉是要MLE的。这里再简单说一下离散化，毕竟这是蒟蒻第二次做有关离散化的题OTZ，就当作是一个笔记。</p>
<p>所谓的离散化，就是将一个范围很大的数，转化为数据范围更小的数，从而大大减少内存使用。使用离散化的其中一个场景是，有时候序列中的数的范围很大，且不是连续的，但我们只关心这些数字之间的相对大小，不关心它们的具体数值。这时就可以使用离散化处理，将它们映射到一组连续且数据范围小得多的数字上。离散化的大致步骤是</p>
<ul>
<li>排序，这是为了后面的去重和二分</li>
<li>去重，这里使用的是C++的unique()函数。这个函数的功能是对于一段连续的数，只保留它们中的第一个，比方说2，2，2，4，5，6，2，使用unique()后，会变成2，4，5，6，2，最后一个2因为不是连续的，所以不会被删除。因此，在使用unique()去重时，必须要保证序列是有序的，这个用sort()处理一下即可</li>
<li>去重完毕后，使用lower_bound将原序列中的数映射到一个更小的数字上。</li>
</ul>
<p>以这道题的样例为例子：<br>1 4<br>2 6<br>8 10<br>3 4<br>7 10<br>这是五张海报的左右端点。我们首先对它们进行排序和去重。处理后可以得到这样的一个序列：</p>
<center>1,2,3,4,6,7,8,10</center>

<p>我们现在将这些只进行映射，具体来说就是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">原数值</th>
<th style="text-align:center">映射值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
</div>
<p>关于映射，再举一个例子：对于序列1、1000、100000000，我们可以将他们映射到1、2、3上，这样一来，就能将数据范围大大减小。</p>
<p><div class="note info"><p>看了下题解，发现这道题不能这么简单的离散化，但这题的数据比较弱，所以依然能AC...emmmm，蒟蒻不懂OTZ</p></div><br>具体AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">10000</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> lazy[maxn&lt;&lt;<span class="number">3</span>];        <span class="comment">//这里最好开大一点，仅仅是四倍空间的话会WA</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lef;</span><br><span class="line">    <span class="keyword">int</span> rig;</span><br><span class="line">&#125;;</span><br><span class="line">node ps[<span class="number">20000</span>+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt]!=<span class="number">0</span>)&#123;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]=lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=lazy[rt];</span><br><span class="line">        lazy[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> todo,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;toR&gt;=rig)&#123;</span><br><span class="line">        lazy[rt]=todo;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        update(toL,toR,todo,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        update(toL,toR,todo,rson);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[lazy[rt]])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            vis[lazy[rt]]=<span class="number">1</span>;    <span class="comment">//防止同一张海报重复统计</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef&lt;=mid)</span><br><span class="line">        query(lson);</span><br><span class="line">    <span class="keyword">if</span>(rig&gt;mid)</span><br><span class="line">        query(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lsh[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        mst(lsh,<span class="number">0</span>);</span><br><span class="line">        mst(lazy,<span class="number">0</span>);mst(vis,<span class="number">0</span>);</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;ps[i].lef,&amp;ps[i].rig);</span><br><span class="line">            lsh[idx++]=ps[i].lef;lsh[idx++]=ps[i].rig;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(lsh,lsh+idx);</span><br><span class="line">        <span class="keyword">int</span> cnt=unique(lsh,lsh+idx)-lsh;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> L=lower_bound(lsh,lsh+cnt,ps[i].lef)-lsh+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R=lower_bound(lsh,lsh+cnt,ps[i].rig)-lsh+<span class="number">1</span>;</span><br><span class="line">            update(L,R,i+<span class="number">1</span>,<span class="number">1</span>,cnt+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        query(<span class="number">1</span>,cnt+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2891 - Strange Way to Express Integers</title>
    <url>/2019/03/02/POJ2891-Strange-Way-to-Express-Integers/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/POJ-2891" rel="external nofollow noopener noreferrer" target="_blank">Strange Way to Express Integers</a></p>
<p>&emsp;&emsp;拓展中国剩余定理的模板题，但我并看不懂模板OTZ(过段时间会补上个人理解，先把代码放这)</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll&amp; x,ll&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r=exgcd(b,a%b,x,y);</span><br><span class="line">    ll tmp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=tmp-(a/b)*y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">ll a[maxn],m[maxn];</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll M=m[<span class="number">1</span>];</span><br><span class="line">    ll ans=a[<span class="number">1</span>];</span><br><span class="line">    ll x,y;ll r;ll tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r=exgcd(M,m[i],x,y);</span><br><span class="line">        <span class="keyword">if</span>((a[i]-ans)%r)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        x*=(a[i]-ans)/r;</span><br><span class="line">        tmp=m[i]/r;</span><br><span class="line">        x=(x%tmp+tmp)%tmp;</span><br><span class="line">        ans=M*x+ans;</span><br><span class="line">        M=M/r*m[i];</span><br><span class="line">        ans%=M;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=(ans%M+M)%M;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ll k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m[i]&gt;&gt;a[i];</span><br><span class="line">        ll ans=solve(k);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>数论</tag>
        <tag>拓展中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2955 - Brackets</title>
    <url>/2019/07/30/POJ2955-Brackets/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/Ha88250073cd84aa58e53c0aa2f48effdV.jpg" alt></p>
<p>From <strong>Google Earth</strong><br><a id="more"></a></p>
<p><a href="POJ - 2955">Brackets</a></p>
<p>题目大意是说，对于一个给定的括号序列$S$，找出其最长的子序列，该子序列应该是括号匹配的，输出其长度。</p>
<p>大概是最基础的区间dp了。</p>
<p>$dp[i][j]$表示的是在区间$[i,j]$内，最长的满足要求的子序列的长度。如果$S_i$与$S_j$配对，则有</p>
<script type="math/tex; mode=display">
dp[i][j]=max(dp[i][j],dp[i+1][j-1]+2)</script><p>但这样得到的$dp[i][j]$并不一定是最大的。以第二个样例为例：</p>
<p>对于区间$[1,6]$，$S_1$和$S_6$是配对的，所以有$dp[1][6]=max(dp[1][6],dp[2][5]+2)$，而$dp[2][5]$为2，如果只是从$dp[2][5]+2$转移过来，就会忽略掉$S_1S_2$以及$S_5S_6$这两对配对括号。故我们还需要枚举区间$[i,j]$内的断点$k$，从$dp[i][k]+dp[k+1][j]$转移得到$dp[i][j]$。</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">105</span>]; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> ca,<span class="keyword">char</span> cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((ca==<span class="string">'('</span>&amp;&amp;cb==<span class="string">')'</span>)||(ca==<span class="string">'['</span>&amp;&amp;cb==<span class="string">']'</span>))    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">1</span>]==<span class="string">'e'</span>)    <span class="keyword">break</span>;</span><br><span class="line">        mst(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">            dp[i][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(check(str[i],str[j]))&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][len]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>区间DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3624 - Charm Bracelet</title>
    <url>/2019/02/17/POJ3624-Charm-Bracelet/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/POJ-3624" rel="external nofollow noopener noreferrer" target="_blank">Charm Bracelet</a></p>
<p>&emsp;&emsp;一道01背包模板题，套模板即可。</p>
<a id="more"></a>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">3500</span>],d[<span class="number">3500</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="keyword">sizeof</span>(w));<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;d[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w[i];j--)</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+d[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3687 - Labelling Balls</title>
    <url>/2019/03/27/POJ3687-Labelling-Balls/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/POJ-3687" rel="external nofollow noopener noreferrer" target="_blank">Labeling Balls</a></p>
<p>一道拓补排序的题，虽然a了但是是看题解过的……存在的疑问已在注释中标明<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> gra[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> deg[<span class="number">40005</span>];        <span class="comment">//记录入度 </span></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">40005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tag;<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;        <span class="comment">//这样反向循环的原理到底是什么？</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(deg[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                tag=j;</span><br><span class="line">                deg[j]--;</span><br><span class="line">                ans[j]=i;        <span class="comment">//???</span></span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gra[tag][j]&gt;<span class="number">0</span>)</span><br><span class="line">                deg[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        mst(deg,<span class="number">0</span>);mst(gra,<span class="number">0</span>);mst(ans,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span>(!gra[b][a])        <span class="comment">//???这里删去以后就会RE</span></span><br><span class="line">                deg[a]++;</span><br><span class="line">            gra[b][a]=<span class="number">1</span>;        <span class="comment">//为什么要反向建图？？？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!topo())</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> pr=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!pr)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" %d"</span>,ans[i]);</span><br><span class="line">                pr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>存疑</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>拓补排序</tag>
        <tag>存疑</tag>
      </tags>
  </entry>
  <entry>
    <title>URAL - 1244 Gentlemen(01背包+记录路径)</title>
    <url>/2019/02/17/URAL-1244-Gentlemen/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/contest/43653#problem/C" rel="external nofollow noopener noreferrer" target="_blank">URAL - 1244 Gentlemen</a></p>
<p>&emsp;&emsp;一道01背包的题目，只不过这一次不是用01背包来求最大值或最小值，而是将背包填满。这只需要将数组dp[]的dp[0]设为0，将其他设为 -∞即可（原因：这是为什么呢？可以这样理解：初始化的 F 数组事实上就是在没有任何物品可以放 入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什 么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于 未定义的状态，应该被赋值为 -∞ 了。如果背包并非必须被装满，那么任何容量的背包 都有一个合法解“什么都不装”，这个解的价值为 0，所以初始时状态的值也就全部为 0 了。）</p>
<p>&emsp;&emsp;难点在于记录路径，同时处理多个解的情况。一开始我也想不到要怎么处理多个解的情况(总不能做两次dp吧)，无奈去看题解，恍然大悟。具体见代码中的注释。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF -0x3fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">bool</span> rec[<span class="number">105</span>][<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">100005</span>;i++)        dp[i]=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(rec,<span class="number">0</span>,<span class="keyword">sizeof</span>(rec));<span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="keyword">sizeof</span>(w));</span><br><span class="line">    <span class="keyword">int</span> wei;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;wei;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> vtot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=wei;j&gt;=w[i];j--)</span><br><span class="line">            dp[j]+=dp[j-w[i]];        <span class="comment">//用动态规划求解解的个数，因为状态是从</span></span><br><span class="line">                                     <span class="comment">//dp[j-w[i]]转移过来的，故每出现一个解                                        </span></span><br><span class="line">                                    <span class="comment">//都会+1，若dp[wei]&gt;1，则说明在wei时有两个解，</span></span><br><span class="line">                                    <span class="comment">//即问题有两个解</span></span><br><span class="line">    <span class="keyword">if</span>(dp[wei]&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dp[wei]==<span class="number">0</span>)            <span class="comment">//如果仍然为0，则说明无解</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>                          <span class="comment">//从这里开始，就是普通的01背包了</span></span><br><span class="line">    &#123;    </span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=wei;j&gt;=w[i];j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=dp[j-w[i]]+w[i];</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+w[i]);</span><br><span class="line">                <span class="keyword">if</span>(dp[j]==tmp)</span><br><span class="line">                    rec[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=n<span class="number">-1</span>;<span class="keyword">int</span> j=wei;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rec[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                j-=w[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pr=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ans[k])&#123;</span><br><span class="line">                <span class="keyword">if</span>(pr)</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;k;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;k;</span><br><span class="line">                pr=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>TayE &#39; s Collection</title>
    <url>/2019/04/11/TayE&#39;s-Collection/</url>
    <content><![CDATA[<p>&emsp;&emsp;因为本人在看到一些有意思或者有用的东西时总喜欢加入到APP的收藏夹里，<del>但一旦收藏了就意味着以后很有可能再也不会看了</del>,所以抱着“换个收藏的地方大概就会看了吧”的侥幸想法，同时也是为了对自己的收藏夹做个整理，写下这篇文章。目前打算只放链接和相应的标题(图大概是不会有的，<del>因为我懒</del>).</p>
<h4 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h4><ul>
<li><a href="https://zhuanlan.zhihu.com/p/24362823" rel="external nofollow noopener noreferrer" target="_blank">2016年不可错过的21个深度学习视频、教程和课程</a></li>
<li><a href="https://www.zhihu.com/question/267330211" rel="external nofollow noopener noreferrer" target="_blank">高中生进入大学，有哪些必须知道的东西或常见错误？</a></li>
<li><a href="https://www.zhihu.com/question/263525664" rel="external nofollow noopener noreferrer" target="_blank">有哪些「985 学生知道了会流泪，211 学生知道了会沉默」 的残酷现实？</a></li>
<li><a href="https://www.zhihu.com/question/281438440" rel="external nofollow noopener noreferrer" target="_blank">进入大学的你想对准大一说什么？</a></li>
<li><a href="https://www.zhihu.com/question/52157612" rel="external nofollow noopener noreferrer" target="_blank">最良心的软件可以良心到什么程度？</a></li>
<li><a href="https://www.zhihu.com/question/36546814" rel="external nofollow noopener noreferrer" target="_blank">有哪些堪称「神器」，却鲜为人知的软件/网站/互联网服务？</a></li>
<li><a href="https://www.zhihu.com/question/275251667" rel="external nofollow noopener noreferrer" target="_blank">国内哪些大学宿舍条件差？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/36829236" rel="external nofollow noopener noreferrer" target="_blank">20 种最奇怪的编程语言</a></li>
<li><a href="https://www.zhihu.com/question/64244262" rel="external nofollow noopener noreferrer" target="_blank">计算机专业学生在大学四年内可以做些什么来丰富简历？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29558221" rel="external nofollow noopener noreferrer" target="_blank">浙大北大上交复旦保研经历与心得</a></li>
<li><a href="https://www.zhihu.com/question/50343728" rel="external nofollow noopener noreferrer" target="_blank">你有什么值得分享的高效学习方法？</a></li>
<li><a href="https://www.zhihu.com/question/51134718" rel="external nofollow noopener noreferrer" target="_blank">为了考研，我们能努力到什么程度？</a></li>
<li><a href="https://www.zhihu.com/question/24363994" rel="external nofollow noopener noreferrer" target="_blank">在上海交通大学就读是怎样一番体验？</a></li>
<li><a href="https://www.zhihu.com/question/24399025" rel="external nofollow noopener noreferrer" target="_blank">在清华大学就读是什么体验？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37858020" rel="external nofollow noopener noreferrer" target="_blank">科学家使用 Reddit 上最恐怖的图片训练了一个反人类魔鬼 AI</a></li>
<li><a href="https://www.zhihu.com/question/68788879" rel="external nofollow noopener noreferrer" target="_blank">淘气包马小跳里面的桃子宴，真的可以做出来吗？</a></li>
<li><a href="https://www.zhihu.com/question/287421003" rel="external nofollow noopener noreferrer" target="_blank">大家都见过哪些让你虎躯一震的代码？</a></li>
<li><a href="https://www.zhihu.com/question/36766890" rel="external nofollow noopener noreferrer" target="_blank">如何不虚度大学的时光？</a></li>
<li><a href="https://www.zhihu.com/question/57767264" rel="external nofollow noopener noreferrer" target="_blank">为什么现在有很多人，甚至大学授课还在坚持 VC 6？</a></li>
<li><a href="https://www.zhihu.com/question/30196513" rel="external nofollow noopener noreferrer" target="_blank">C++ 有多难？</a></li>
<li><a href="https://www.zhihu.com/question/302772589" rel="external nofollow noopener noreferrer" target="_blank">大一为acm准备，感觉学习过程中很吃力？</a></li>
<li><a href="https://www.zhihu.com/question/61624754" rel="external nofollow noopener noreferrer" target="_blank">正在工作的程序员，生活状态什么样？</a></li>
<li><a href="https://www.zhihu.com/question/25715002" rel="external nofollow noopener noreferrer" target="_blank">清华大学计算机系与普通大学计算机系有什么区别？</a></li>
<li><a href="https://www.zhihu.com/question/38452044" rel="external nofollow noopener noreferrer" target="_blank">清华大学计算机系组成结构课三星期造台计算机究竟是怎么造的？</a></li>
<li><a href="https://www.zhihu.com/question/302440083" rel="external nofollow noopener noreferrer" target="_blank">free()函数如何知道要释放的空间大小？</a></li>
<li><a href="https://www.zhihu.com/question/27837191" rel="external nofollow noopener noreferrer" target="_blank">如何评价 《欢迎加入NHK》?</a></li>
<li><a href="https://www.zhihu.com/question/304844787" rel="external nofollow noopener noreferrer" target="_blank">如果让你重新上一次大学，你会怎么度过？为什么？</a></li>
<li><a href="https://www.zhihu.com/question/51727516" rel="external nofollow noopener noreferrer" target="_blank">ACM 的正确入门方式是什么？</a></li>
<li><a href="https://www.zhihu.com/question/19719698" rel="external nofollow noopener noreferrer" target="_blank">ACM 中常用的算法有哪些？</a></li>
<li><a href="https://www.zhihu.com/question/31034164" rel="external nofollow noopener noreferrer" target="_blank">什么才算是真正的编程能力？</a></li>
<li><a href="https://www.zhihu.com/question/57532048" rel="external nofollow noopener noreferrer" target="_blank">美国计算机名校例如MIT ，CMU ，有哪些公认的好课并且有课程讲义的，适合国内学生自学的？</a></li>
<li><a href="https://www.zhihu.com/question/51560126" rel="external nofollow noopener noreferrer" target="_blank">如何高效的学习C++？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/54783053" rel="external nofollow noopener noreferrer" target="_blank">漫画：什么是Bitmap算法？</a></li>
<li><a href="https://www.zhihu.com/question/20402534" rel="external nofollow noopener noreferrer" target="_blank">如何阅读《深入理解计算机系统》这本书？</a></li>
<li><a href="https://www.zhihu.com/question/51134387" rel="external nofollow noopener noreferrer" target="_blank">你工作中最推荐的 C/C++ 程序库有哪些，为什么？</a></li>
<li><a href="https://www.zhihu.com/question/23498424" rel="external nofollow noopener noreferrer" target="_blank">你在 GitHub 上看到过的最有意思的项目是什么？</a></li>
<li><a href="https://www.zhihu.com/question/266995763" rel="external nofollow noopener noreferrer" target="_blank">为什么 C 语言没有被 C++ 取代？</a></li>
<li><a href="https://www.zhihu.com/question/310052411" rel="external nofollow noopener noreferrer" target="_blank">你有过哪些被 C++ 摧残的经历？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/58567627" rel="external nofollow noopener noreferrer" target="_blank">可以说是70%的 C++ 程序员成长经历</a></li>
<li><a href="https://www.zhihu.com/question/60911582" rel="external nofollow noopener noreferrer" target="_blank">你遇到过哪些高质量的 C++ 面试？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/56253982" rel="external nofollow noopener noreferrer" target="_blank">Linux玩家必备：Ubuntu完全配置指南</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/57512786" rel="external nofollow noopener noreferrer" target="_blank">为何程序员喜欢将INF设置为0x3f3f3f3f (转载)</a></li>
<li><a href="https://www.zhihu.com/question/22913650" rel="external nofollow noopener noreferrer" target="_blank">人这一生为什么要努力？</a></li>
<li><a href="https://www.zhihu.com/question/28543312" rel="external nofollow noopener noreferrer" target="_blank">如何用 C++ 在 10 行内写出八皇后？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/61036249" rel="external nofollow noopener noreferrer" target="_blank">AI“复活”张国荣，逝去16年哥哥又重生</a></li>
<li><a href="https://www.zhihu.com/question/316844185" rel="external nofollow noopener noreferrer" target="_blank">有什么在线的编程游戏？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27692913" rel="external nofollow noopener noreferrer" target="_blank">ACM算法分类、推荐学习资料和配套习题（转）</a></li>
<li><a href="https://www.zhihu.com/question/27940474" rel="external nofollow noopener noreferrer" target="_blank">有什么理论复杂但是实现简单的算法？</a></li>
<li><a href="https://www.zhihu.com/question/56297876" rel="external nofollow noopener noreferrer" target="_blank">有哪些「高级感」的中文/英文/日文字体 ？</a></li>
<li><a href="https://www.zhihu.com/question/51920544/answer/618254238" rel="external nofollow noopener noreferrer" target="_blank">有没有简单一点的Python小例子小项目？</a></li>
<li><a href="https://www.zhihu.com/question/28661987/answer/619341354" rel="external nofollow noopener noreferrer" target="_blank">你用 Python 写过哪些有趣的脚本？</a></li>
<li><a href="https://www.zhihu.com/question/27386361/answer/560891895" rel="external nofollow noopener noreferrer" target="_blank">Python 学习完基础语法知识后，如何进一步提高？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/57382703" rel="external nofollow noopener noreferrer" target="_blank">【攻略】量身定做自己的保研方案</a></li>
<li><a href="https://zhuanlan.zhihu.com/c_176544314" rel="external nofollow noopener noreferrer" target="_blank">一亩三分(一个保研相关的知乎专栏)</a></li>
</ul>
<h4 id="B站"><a href="#B站" class="headerlink" title="B站"></a>B站</h4><ul>
<li><a href="https://www.bilibili.com/video/av10813947" rel="external nofollow noopener noreferrer" target="_blank">【全程】ACM ICPC World Finals 2017 国际大学生程序设计竞赛全球总决赛 以及相关视频全程】ACM ICPC World Finals 2017 国际大学生程序设计竞赛全球总决赛以及相关视频</a></li>
<li><a href="https://www.bilibili.com/video/av45038361" rel="external nofollow noopener noreferrer" target="_blank">【计算机科学 | 人物 | 陈丹琦】清华姚班，斯坦福博士毕业，高中时发明插头DP</a></li>
<li><a href="https://www.bilibili.com/video/av42286396" rel="external nofollow noopener noreferrer" target="_blank">每年700本+笔记700份，10年读书经验大公开</a></li>
<li><a href="https://space.bilibili.com/611212?spm_id_from=333.788.b_765f7570696e666f.2" rel="external nofollow noopener noreferrer" target="_blank">卿学姐的b站空间(算法讲座)</a></li>
<li><a href="https://www.bilibili.com/video/av48420057" rel="external nofollow noopener noreferrer" target="_blank">【AI自动绘画黑科技？】最新 PI-REC 论文解读+代码实战 图像翻译课程 手残党福音 深度学习教程</a></li>
<li><a href="https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1" rel="external nofollow noopener noreferrer" target="_blank">3Blue1Brown的B站空间(各种数学视频)</a></li>
</ul>
<h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><ul>
<li><a href="https://github.com/QSCTech/zju-icicles" rel="external nofollow noopener noreferrer" target="_blank">浙江大学课程攻略共享计划</a></li>
<li><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT" rel="external nofollow noopener noreferrer" target="_blank">清华大学计算机系课程攻略</a></li>
<li><a href="https://github.com/lib-pku/libpku" rel="external nofollow noopener noreferrer" target="_blank">pku课程资料</a></li>
<li><a href="https://github.com/CoolPhilChen/SJTU-Courses" rel="external nofollow noopener noreferrer" target="_blank">上海交大课程资料</a></li>
</ul>
<h4 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h4><ul>
<li><a href="https://www.jianshu.com/p/f7434bb2ce09?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" rel="external nofollow noopener noreferrer" target="_blank">汇编入门（长文多图，流量慎入！！！）(超多干货)</a></li>
<li><a href="https://kb.cnblogs.com/page/179578/" rel="external nofollow noopener noreferrer" target="_blank">CPU流水线的探秘之旅</a><br></li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><a href="https://lib-pku.github.io/" rel="external nofollow noopener noreferrer" target="_blank">libpku - 贵校课程资料民间整理(还是pku的资料)</a></li>
<li><a href="http://www.mdtr2pdf.com/index_en.html" rel="external nofollow noopener noreferrer" target="_blank">一个将Markdown转为PDF的Web应用</a></li>
<li><a href="https://pymlovelyq.github.io/" rel="external nofollow noopener noreferrer" target="_blank">极客侠栈(一个专业书资源网站)</a></li>
</ul>
<h4 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h4><ul>
<li>2019/4/11 创建文章</li>
<li>2019/4/11 创建分类：知乎、B站、Github、其他</li>
<li>2019/4/11 添加内容</li>
<li>2019/4/12 添加分类：简书</li>
<li>2019/4/12 添加内容</li>
<li>2019/5/1    添加内容</li>
<li>2019/5/8    添加内容</li>
<li>2019/7/2 删除部分不恰当的内容</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>杂</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA - 12563 Jin Ge Jin Qu hao</title>
    <url>/2019/02/24/UVA-12563-Jin-Ge-Jin-Qu-hao/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/UVA-12563" rel="external nofollow noopener noreferrer" target="_blank">Jin Ge Jin Qu hao</a></p>
<p>&emsp;&emsp;一道01背包，虽然t&lt;=1e9，但实际上t不会超过180 * n + 678。</p>
<a id="more"></a>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JIN 678</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> time_[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x8f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;    </span><br><span class="line">        mst(time_,<span class="number">0</span>);init();</span><br><span class="line">        <span class="keyword">int</span> n,t_lef;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;t_lef;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)        <span class="built_in">cin</span>&gt;&gt;time_[i];</span><br><span class="line">        <span class="keyword">int</span> vtot=t_lef<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=vtot;j&gt;=time_[i];j--)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-time_[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=t_lef<span class="number">-1</span>;        <span class="comment">//留一秒来唱劲歌金曲</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=vtot;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=cnt;</span><br><span class="line">            cnt=<span class="built_in">max</span>(cnt,dp[i]);</span><br><span class="line">            <span class="keyword">if</span>(cnt!=tmp)</span><br><span class="line">                len=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d %d\n"</span>,++kase,cnt+<span class="number">1</span>,len+JIN);        </span><br><span class="line">        <span class="comment">//加上劲歌金曲         </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa101-The Blocks Problem</title>
    <url>/2019/01/26/UVa101-The-Blocks-Problem/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=37" rel="external nofollow noopener noreferrer" target="_blank">Uva101</a><br>也可以在这看：<a href="https://cn.vjudge.net/problem/UVA-101" rel="external nofollow noopener noreferrer" target="_blank">Vjudge</a><br><a id="more"></a><br>先上代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pile[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function">P <span class="title">find_block</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; pile[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pile[i][j] == num) &#123;</span><br><span class="line">                pos.first = i;</span><br><span class="line">                pos.second = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_pile</span><span class="params">(<span class="keyword">int</span> num)</span>        <span class="comment">//p表示哪一堆，h表示高度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P pos = find_block(num);</span><br><span class="line">    <span class="keyword">int</span> p = pos.first; <span class="keyword">int</span> h = pos.second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h + <span class="number">1</span>; i &lt; pile[p].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> b = pile[p][i];</span><br><span class="line">        pile[b].push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line">    pile[p].resize(h + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">string</span> com1, com2;</span><br><span class="line">    P des;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pile[i].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; com1;</span><br><span class="line">        <span class="keyword">if</span> (com1 == <span class="string">"quit"</span>)        <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; com2 &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (find_block(a).first == find_block(b).first)        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (com1 == <span class="string">"move"</span>&amp;&amp;com2 == <span class="string">"onto"</span>) &#123;</span><br><span class="line">            clear_pile(a);</span><br><span class="line">            clear_pile(b);</span><br><span class="line">            <span class="keyword">int</span> bpile = find_block(b).first;</span><br><span class="line">            <span class="keyword">int</span> apile = find_block(a).first;</span><br><span class="line">            pile[bpile].push_back(a);</span><br><span class="line">            <span class="keyword">int</span> si = pile[apile].<span class="built_in">size</span>();</span><br><span class="line">            pile[apile].resize(si - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (com1 == <span class="string">"move"</span>&amp;&amp;com2 == <span class="string">"over"</span>) &#123;                <span class="comment">//这段有问题 </span></span><br><span class="line">            clear_pile(a);</span><br><span class="line">            <span class="keyword">int</span> apile = find_block(a).first;</span><br><span class="line">            <span class="keyword">int</span> bpile = find_block(b).first;</span><br><span class="line">            <span class="keyword">int</span> si = pile[apile].<span class="built_in">size</span>();</span><br><span class="line">            pile[bpile].push_back(a);</span><br><span class="line">            pile[apile].resize(si - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (com1 == <span class="string">"pile"</span>&amp;&amp;com2 == <span class="string">"onto"</span>) &#123;        <span class="comment">//这个操作是先将b上方的方块归位，然后将a以及a上方的方块整体移动到b的上方</span></span><br><span class="line">            <span class="keyword">int</span> apile = find_block(a).first;</span><br><span class="line">            <span class="keyword">int</span> bpile = find_block(b).first;</span><br><span class="line">            <span class="keyword">int</span> h = find_block(a).second;</span><br><span class="line">            <span class="keyword">int</span> ori_a_size = pile[apile].<span class="built_in">size</span>();</span><br><span class="line">            clear_pile(b);                                <span class="comment">//将b上方的方块归位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = find_block(a).second; i &lt; ori_a_size; i++) &#123;        <span class="comment">//循环从b的高度开始（这里是否要+1？）</span></span><br><span class="line">                pile[bpile].push_back(pile[apile][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            pile[apile].resize(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (com1 == <span class="string">"pile"</span>&amp;&amp;com2 == <span class="string">"over"</span>) &#123;                <span class="comment">//这段有问题</span></span><br><span class="line">            <span class="keyword">int</span> bpile = find_block(b).first;</span><br><span class="line">            <span class="keyword">int</span> apile = find_block(a).first;</span><br><span class="line">            <span class="keyword">int</span> ori_a_si = pile[apile].<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> h = find_block(a).second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = find_block(a).second; i &lt; ori_a_si; i++) &#123;</span><br><span class="line">                pile[bpile].push_back(pile[apile][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            pile[apile].resize(h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d:"</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pile[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, pile[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路上其实很直接，就是用vector来模拟方块堆，然后用一个数组将这些vector存起来。放方块的操作用push_back即可。原本是写了一个move函数用来进行放方块的操作的，但后来发现这样做容易出错而且自己也写得不好……..<br>下面是我写的超丑move函数qwq：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> obj, <span class="keyword">int</span> des, <span class="keyword">int</span> h)</span>        <span class="comment">//obj表示要移动的方块，des表示目的地方块，h表示要移动的方块在移动前所处的高度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> desp = find_block(des).first;        <span class="comment">//找到目的地方块处于哪一堆</span></span><br><span class="line">    <span class="keyword">int</span> objp = find_block(obj).first;        <span class="comment">//找到要移动的方块处于哪一堆</span></span><br><span class="line">    <span class="keyword">int</span> ori_hei=pile[find_block(obj).first].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; pile[objp].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        pile[desp].push_back(pile[objp][i]);        <span class="comment">//将要移动的方块以及要移动的方块上面的方块（如果有的话）移动到目的地方块的上面</span></span><br><span class="line">    &#125;</span><br><span class="line">    pile[objp].resize(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际使用的时候很不好用，主要是参数设计的不好。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA294 - Divisors</title>
    <url>/2019/03/02/UVA294-Divisors/</url>
    <content><![CDATA[<p><a href="https://cn.vjudge.net/problem/UVA-294" rel="external nofollow noopener noreferrer" target="_blank">Divisors</a></p>
<p>&emsp;&emsp;题意是说算一个区间内的因子数最大的数。网上题解大都是用的dfs，但我又不想写dfs······然后看了一下，区间长度最长才1e4，用质因数分解求出区间内每一个数的因子数然后用最朴素的方法找出答案应该也能过吧······事实证明真的可以，而且只用了40ms 2333333。</p>
<p>&emsp;&emsp;这里做个笔记，所谓质因数分解求因子数，指的是，对于一个数x,必定存在以下式子:</p>
<pre><code>        x = (a1^p1)*(a2^p2)*(a3^p3)*(a4^p4)*···*(an^pn)(其中,a1,a2,···，an均为质数)
</code></pre><p>&emsp;&emsp;那么,x的因子个数则为:</p>
<pre><code>                    sum(x) = (1+p1)*(1+p2)*(1+p3)*(1+p4)*···*(1+pn)
</code></pre><p>&emsp;&emsp;比如说，对于12，有12 = (2^2) * (3^1) , 所以sum(12) = (1+2) * (1+1) = 6</p>
<p>此题的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_cnt</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>)        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>)        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    ll ans=<span class="number">1</span>;ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            x/=i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans*=(<span class="number">1</span>+cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x&gt;<span class="number">1</span>?<span class="number">2</span>*ans:ans;</span><br><span class="line">&#125;</span><br><span class="line">ll maxi,pos;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(ll lef,ll rig)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    maxi=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=lef;i&lt;=rig;i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        ll tmp=get_cnt(i);</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;maxi)&#123;</span><br><span class="line">            maxi=tmp;</span><br><span class="line">            pos=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll lef,rig;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;lef&gt;&gt;rig;</span><br><span class="line">        get_ans(lef,rig);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Between %lld and %lld, %lld has a maximum of %lld divisors.\n"</span>,lef,rig,pos,maxi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Between 1 and 10, 6 has a maximum of 4 divisors.</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>数论</tag>
        <tag>求因子个数</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10下安装C++ linear algebra library Armadillo</title>
    <url>/2019/08/03/Windows10%E4%B8%8B%E5%AE%89%E8%A3%85C-linear-algebra-library-Armadillo/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H628e81e21f2f4cd6994afcb0bc0d008ap.jpg" alt></p>
<a id="more"></a>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>装这个库的原因是因为昨天写题写得有点自闭，所以就去复习一下很久之前学过的numpy，打算调整一下思维。复习着复习着，就想C++下有没有像numpy这种这么好用的矩阵库呢？上某乎找了一下，果然有，便打算配一个玩玩<del>（一句话概括，原因就是想要找个合适的理由划水）</del></p>
<h4 id="Armadill简介"><a href="#Armadill简介" class="headerlink" title="Armadill简介"></a>Armadill简介</h4><p>以下摘自官网</p>
<blockquote>
<ul>
<li><p>Armadillo is a high quality linear algebra library (matrix maths) for the C++ language, aiming towards a good balance between speed and ease of use </p>
</li>
<li><p>Provides high-level syntax and <a href="http://arma.sourceforge.net/docs.html" rel="external nofollow noopener noreferrer" target="_blank">functionality</a> deliberately similar to Matlab </p>
</li>
<li><p>Useful for algorithm development directly in C++, or quick conversion of research code into production environments (eg. software &amp; hardware products) </p>
</li>
<li><p>Provides efficient classes for vectors, matrices and cubes (1st, 2nd and 3rd order tensors); dense and sparse matrices are supported </p>
</li>
<li><p>Integer, floating point and complex numbers are supported </p>
</li>
<li><p>Various matrix decompositions are provided through integration with <a href="http://www.netlib.org/lapack/" rel="external nofollow noopener noreferrer" target="_blank">LAPACK</a>, or one of its high performance drop-in replacements (eg. multi-threaded <a href="http://software.intel.com/en-us/intel-mkl/" rel="external nofollow noopener noreferrer" target="_blank">Intel MKL</a>, or <a href="https://github.com/xianyi/OpenBLAS/releases" rel="external nofollow noopener noreferrer" target="_blank">OpenBLAS</a>) </p>
</li>
<li><p>A sophisticated expression evaluator (based on template meta-programming) automatically combines several operations to increase speed and efficiency </p>
</li>
<li><p>Can automatically use OpenMP multi-threading (parallelisation) to speed up computationally expensive operations </p>
</li>
<li><p>Available under a <a href="http://arma.sourceforge.net/license.html" rel="external nofollow noopener noreferrer" target="_blank">permissive license</a>, useful for both open-source and proprietary (closed-source) software </p>
</li>
<li><p>Can be used for machine learning, pattern recognition, computer vision, signal processing, bioinformatics, statistics, finance, etc </p>
</li>
</ul>
</blockquote>
<p>翻译一下就是</p>
<ul>
<li>Armadillo是一个高质量的C++线性代数库，目的是实现速度与易用性的良好平衡。</li>
<li>提供与Matlab相似的高阶语法及功能。</li>
<li>对于C++算法开发或代码在生产环境中的快速转换很有帮助。</li>
<li>提供高效的vectors，matrices与cubes（一阶、二阶和三阶张量）的类实现；同时支持密集矩阵和稀疏矩阵</li>
<li>支持整数、浮点数和复数。</li>
<li>通过与LAPACK或其高性能替换（如多线程的 Intel MKL，或OpenBLAS），提供多种矩阵分解。</li>
<li>复杂表达式评估程序（基于模板元编程）会自动地将多个操作组合以提高速度和效率</li>
<li>可以自动使用OpenMP的多线程来加速计算耗时较大的操作</li>
<li>在许可下可用，对于开源与闭源软件都是可用的。</li>
<li>可用于机器学习、模式识别、计算机视觉、信号处理、生物信息学、统计学、金融学等等。</li>
</ul>
<p><del>辣鸡英语水平，有些地方翻译得很生硬</del></p>
<p><del>一句话概括就是这个库很nb</del></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="首先当然是去下载这个库"><a href="#首先当然是去下载这个库" class="headerlink" title="首先当然是去下载这个库"></a>首先当然是去下载这个库</h5><p>点击下面👇这个链接即可</p>
<p><a href="http://arma.sourceforge.net/download.html" rel="external nofollow noopener noreferrer" target="_blank">Armadillo Download</a></p>
<p>进去之后是这样的</p>
<p><img src="https://ae01.alicdn.com/kf/H65ff87aeecba45f98168ccb69b43be582.jpg" alt></p>
<p>推荐下载Stable Version</p>
<p>下载之后，将文件解压到任意目录。比方说我就把它解压到了D盘根目录下的Armadillo目录。</p>
<p>打开文件夹，其中内容如下。</p>
<p><img src="https://ae01.alicdn.com/kf/H2dfea56dc4234694a8fe40ae51bc7d3dx.jpg" alt></p>
<h5 id="配置目录"><a href="#配置目录" class="headerlink" title="配置目录"></a>配置目录</h5><p>打开Visual Studio，我这里用的是2017的版本。新建一个项目，配置如下图</p>
<p><img src="https://ae01.alicdn.com/kf/Hdf2647655d364e549a34f68f4f272312l.jpg" alt></p>
<p>进入项目后，在“调试”一栏找到项目属性，然后进行目录配置。具体配置过程如下：</p>
<ul>
<li><p>修改“配置”与“平台”</p>
<p>在我这是要这样配置</p>
<p><img src="https://ae01.alicdn.com/kf/H0c0177cf0f9143ceaa8daa4a82ca6bdcW.jpg" alt></p>
</li>
</ul>
<div class="note warning"><p>注意！“平台”处不一定是像我这样选，网上有很多文章选的是x64，但由于我这里是建立了一个Win32项目，所以要选择Win32。</p></div>

<p>此处的设置很重要，错误的话可能会导致找不到头文件</p>
<ul>
<li><p>配置包含目录</p>
<p>所谓包含目录就是头文件的目录。在“配置属性”中选择“VC++目录”，然后在“包含目录”一栏选择你的Armadillo的include目录。如下图。</p>
<p><img src="https://ae01.alicdn.com/kf/Hb9c8bdce83b248b6b01db5caa1255144w.jpg" alt></p>
</li>
<li><p>配置附加依赖项</p>
<p>选择“链接器”的“输入”，在“附加依赖项”一栏，添加Armadillo中example\lib_win64目录下的lapack_win64_MT.lib和blas_win64_MT.lib。</p>
</li>
</ul>
<div class="note warning"><p>注意！实际需要的并不一定是这两个lib，这两个都是win64的，如果你是win32的项目，请使用win32的lib文件！下载地址见附录</p></div>

<h5 id="配置完成，开始使用吧！"><a href="#配置完成，开始使用吧！" class="headerlink" title="配置完成，开始使用吧！"></a>配置完成，开始使用吧！</h5><p>运行一下附带的example1.cpp</p>
<p><img src="https://ae01.alicdn.com/kf/H5ef973a92ae94889938ff2ad18d34a95S.jpg" alt></p>
<p>另外，还需要将labpack和blas对应的.dll文件放到编译生成的.exe所在目录处。否则.exe会无法运行。</p>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><ul>
<li><p>labpack和blas的下载地址，内含32位版和64位版</p>
<p><a href="https://icl.cs.utk.edu/lapack-for-windows/lapack/" rel="external nofollow noopener noreferrer" target="_blank">Download labpack and blas</a></p>
</li>
<li><p><del>不要尝试用Devcpp配置任何第三方库</del></p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>第三方库</category>
        <category>Armadillo</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>第三方库</tag>
        <tag>Armadillo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客中加入B站视频与网易云歌单</title>
    <url>/2019/08/01/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5B%E7%AB%99%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>没有封面图，懒得找了……</p>
<a id="more"></a>
<h3 id="添加B站视频"><a href="#添加B站视频" class="headerlink" title="添加B站视频"></a>添加B站视频</h3><p>在文章中添加如下代码:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative; width: 100%; height: 0; padding-bottom: 75%;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=57933879&amp;cid=101052438&amp;page=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span> <span class="attr">style</span>=<span class="string">"position: absolute; width: 100%; height: 100%; left: 0; top: 0;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure></p>
<p>在b站视频分享处可以得到视频对应&lt; iframe &gt;标签</p>
<p>效果如下:</p>


<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=57933879&cid=101052438&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe>
</div>


<h3 id="添加网易云歌单"><a href="#添加网易云歌单" class="headerlink" title="添加网易云歌单"></a>添加网易云歌单</h3><h4 id="获取外链"><a href="#获取外链" class="headerlink" title="获取外链"></a>获取外链</h4><p>首先打开网易云音乐网页版，找到要生成外链的歌单。然后点击“分享”。</p>
<p><img src="https://ae01.alicdn.com/kf/Ha0f6cd7fae4e4b1e8fade6891b755091r.jpg" alt></p>
<p>分享成功后，返回首页，进入个人动态，可以看到之前的分享。</p>
<p><img src="https://ae01.alicdn.com/kf/Hbb20fa711df74bc480e5f97a249ed77d7.jpg" alt></p>
<p>点击分享链接，就可以看到生成外链播放器的选项</p>
<p><img src="https://ae01.alicdn.com/kf/H47884c7176254ed8be7cfb2b1c11d7ddD.jpg" alt></p>
<h4 id="插入播放器"><a href="#插入播放器" class="headerlink" title="插入播放器"></a>插入播放器</h4><p>获取外链后，直接在文章中将其插入即可。最好加上。</p>
<p><br><br><br></p>
<div align="center">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="400" height="450" src="//music.163.com/outchain/player?type=0&id=648450046&auto=1&height=430"></iframe>
</div>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>succeed!</title>
    <url>/2018/12/10/succeed-1/</url>
    <content><![CDATA[<div class="note success"><p>success</p></div>]]></content>
      <categories>
        <category>hexo-test</category>
      </categories>
  </entry>
  <entry>
    <title>【OpenGL学习笔记】一、VBO，VAO与EBO</title>
    <url>/2020/07/25/%E3%80%90OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81VBO%EF%BC%8CVAO%E4%B8%8EEBO/</url>
    <content><![CDATA[<p><img src="https://pic.downk.cc/item/5f1b8a4e14195aa594516bd0.png" alt><br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>VBO、VAO和EBO是OpenGL中三个很基础的概念，但一开始时总是分不清他们的区别与联系。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><ul>
<li><p>VBO：顶点缓冲对象</p>
<ul>
<li><p>是在显卡存储空间中开辟的一块内存缓存区，用于存储顶点的各类属性（顶点坐标、顶点法向量、顶点颜色等）</p>
</li>
<li><p>渲染时，可以直接从VBO中取出顶点的各类属性数据</p>
</li>
<li><p>每个VBO都有其唯一标识ID</p>
</li>
<li><p>使用glGenBuffers开辟VBO并分配id</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>,&amp;VBO);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>通过glBindBuffer将某种类型的顶点数据绑定到某个VBO上（可以暂时理解为告诉该VBO它要存储的数据的类型，当然这是不准确的，因为同一类型的顶点数据一次只能绑定一个VBO）。绑定的类型必须是以下几种中的一种</p>
<ul>
<li>GL_ARRAY_BUFFER</li>
<li>GL_ELEMENT_ARRAY_BUFFER</li>
<li>GL_PIXEL_PACK_BUFFER</li>
<li>GL_PIXEL_UNPACK_BUFFER</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>,&amp;VBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER,VBO);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过glBufferData将数据传送到绑定的VBO中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glBufferData(GL_ARRAY_BUFFER,<span class="keyword">sizeof</span>(vertices),vertices,GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用glVertexAttribPointer告知OpenGL如何处理某个VBO中的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>,<span class="number">4</span>,GL_FLOAT,GL_FALSE,<span class="number">0</span>,(<span class="keyword">void</span>*)<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数指定顶点属性位置，与顶点着色器中的layout(location=0)对应</li>
<li>第二个参数指定一个顶点属性组的大小（数据元素个数）</li>
<li>第三个参数指定顶点属性数据类型</li>
<li>第四个参数指定数据是否要被标准化</li>
<li>第五个参数是步长，指定连续顶点属性组之间的间隔。比方说三个GL_FLOAT数据表示一个坐标点，那就把他们作为一个属性组，步长就是3*sizeof(float)</li>
<li>第六个参数是数据起始位置距离缓冲区中起始位置的偏移量</li>
</ul>
</li>
<li><p>使用glEnableVertexAttribArray开启glVertexAttribPointer。由于glVertexAttribPointer默认是关闭的，所以使用时要用顶点属性位置的值为参数，通过glEnableVertexAttribArray来开启这一功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glEnableVertexAttribArray(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>VAO：顶点数组对象</p>
<ul>
<li><p>保存了很多VBO的引用，相当于把很多VBO统一到一个对象中进行管理</p>
</li>
<li><p>使用glGenVertexArrays得到一个VAO，并分配id</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glGenVertexArrays(<span class="number">1</span>,&amp;VAO);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用glBindVertexArray绑定VAO。绑定后，后面所有VBO的引用都会被保存在这一个VAO中。</p>
</li>
<li><p>VAO的存在意义是减少绑定的工作量。因为每次绘制某些之前都需要绑定顶点的所有信息到对应的VBO中。这样做未免有点太麻烦，尤其是数据量很大的情况下。使用VAO，可以把所有顶点信息都绑定到VBO后，再通过VAO把所有顶点信息绑定到一个对象上(VAO)，后面只需要绑定VAO这一个对象即可。</p>
</li>
</ul>
</li>
<li><p>EBO：索引缓存对象</p>
<ul>
<li>存储顶点的索引，避免因为某些点重复存储导致的空间浪费</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>OpenGL学习笔记</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>OpenGL</tag>
        <tag>OpenGL学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++学习笔记】关于继承，基类与派生类</title>
    <url>/2019/03/11/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%85%B3%E4%BA%8E%E5%9F%BA%E7%B1%BB%E4%B8%8E%E6%B4%BE%E7%94%9F%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p>&emsp;&emsp;继承：继承是C++中的一种机制，通过这种机制，我们可以基于已有的旧的数据类型创建出新的数据类型。在C++中，继承分三种:公有继承(public)，私有继承(private)，保护继承(protected)。不同的继承类型在在访问权限上会有区别。</p>
<p>&emsp;&emsp;基类：即被继承的类。</p>
<p>&emsp;&emsp;派生类：即由一个已有的类派生过来的新的类。</p>
<h4 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h4><h5 id="1-公有继承-public"><a href="#1-公有继承-public" class="headerlink" title="1)公有继承(public)"></a>1)公有继承(public)</h5><p>&emsp;&emsp;公有继承指的是基类的公有成员和保护成员保持不变，但派生类无法直接访问私有成员，需要通过基类的公有成员函数或友元函数访问。</p>
<h5 id="2-私有继承-private"><a href="#2-私有继承-private" class="headerlink" title="2)私有继承(private)"></a>2)私有继承(private)</h5><p>&emsp;&emsp;私有继承指的是，在派生类中，基类的公有成员和保护成员都成为了派生类的私有成员，且这个派生类的派生类(子类)无法访问。</p>
<h5 id="3-保护继承-protected"><a href="#3-保护继承-protected" class="headerlink" title="3)保护继承(protected)"></a>3)保护继承(protected)</h5><p>&emsp;&emsp;保护继承是指基类的公有成员和保护成员都成为了派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。</p>
<h5 id="4-用表格汇总一下就是……"><a href="#4-用表格汇总一下就是……" class="headerlink" title="4)用表格汇总一下就是……"></a>4)用表格汇总一下就是……</h5><p><img src="https://ae01.alicdn.com/kf/HTB1Ap.ESwHqK1RjSZFgq6y7JXXaP.jpg" alt></p>
<p>(图片来自→<a href="https://www.cnblogs.com/ktao/p/8579115.html" rel="external nofollow noopener noreferrer" target="_blank">C++ 中私有继承、保护继承与公有继承</a>)</p>
<h5 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h5><p>(一段继承的入门辣鸡代码OTZ)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2019.3.11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Point()&#123;&#125;;</span><br><span class="line">        Point(<span class="keyword">double</span> xx,<span class="keyword">double</span> yy);</span><br><span class="line">        ~Point()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">get_x</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">get_y</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">double</span> y;</span><br><span class="line">        <span class="keyword">double</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Point::get_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Point::get_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">Point::Point(<span class="keyword">double</span> xx,<span class="keyword">double</span> yy)</span><br><span class="line">&#123;</span><br><span class="line">    x=xx;y=yy;</span><br><span class="line">    len=<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodPoint</span>:</span><span class="keyword">public</span> Point&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        GoodPoint()&#123;&#125;;</span><br><span class="line">        GoodPoint(<span class="keyword">double</span> xx,<span class="keyword">double</span> yy);</span><br><span class="line">        ~GoodPoint()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isGoodPoint</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_point</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_point</span><span class="params">(<span class="keyword">bool</span> todo)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">bool</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GoodPoint::isGoodPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">double</span> x_get=<span class="keyword">this</span>-&gt;get_x();</span><br><span class="line">    <span class="keyword">double</span> y_get=<span class="keyword">this</span>-&gt;get_y();</span><br><span class="line">    <span class="keyword">if</span>((x_get==<span class="number">0</span>&amp;&amp;y_get==<span class="number">0</span>)||flag)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GoodPoint::set_point</span><span class="params">(<span class="keyword">bool</span> todo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flag=todo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    GoodPoint gp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,gp.isGoodPoint());</span><br><span class="line">    gp.set_point(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,gp.isGoodPoint());</span><br><span class="line">    <span class="function">Point <span class="title">poi</span><span class="params">(<span class="number">1</span>,<span class="number">23.2</span>)</span></span>;</span><br><span class="line">    poi.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;未完待续……</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>继承</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++学习笔记】虚函数(虚方法)</title>
    <url>/2019/03/17/%E3%80%90C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%99%9A%E5%87%BD%E6%95%B0-%E8%99%9A%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>对于一个派生类以及他的基类，若两者都有一个相同名字的方法，但这两个方法的实际行为并不相同，那应将这个方法声明为虚方法(virtual)。原因在于，如果方法是通过引用或指针调用的，在不声明位虚方法的情况下，程序将根据引用类型或指针类型确定使用的是具体哪个方法。而声明为虚方法，程序将根据引用或指针具体所指向的对象的类型来调用方法</li>
<li>e.g.</li>
</ul>
<p>&emsp;&emsp;使用引用来调用方法</p>
<p>&emsp;&emsp;首先是不使用虚函数的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">show_hei</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">show_wei</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_hei</span><span class="params">(<span class="keyword">double</span> thei)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_wei</span><span class="params">(<span class="keyword">double</span> twei)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">        Human(<span class="keyword">int</span> hei,<span class="keyword">int</span> wei):hei(hei),wei(wei)&#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~Human()&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> hei;</span><br><span class="line">        <span class="keyword">int</span> wei;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Human::show_hei</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hei="</span>&lt;&lt;hei&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> hei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Human::show_wei</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"wei"</span>&lt;&lt;wei&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> wei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Human::set_hei</span><span class="params">(<span class="keyword">double</span> thei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hei=thei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Human::set_wei</span><span class="params">(<span class="keyword">double</span> twei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wei=twei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Human::say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am a Human object"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teen</span>:</span><span class="keyword">public</span> Human&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Teen(<span class="keyword">int</span> hei,<span class="keyword">int</span> wei,<span class="keyword">bool</span> good):Human(hei,wei),isgood(good)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">bool</span> isgood;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teen::say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am a Teen object"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Teen <span class="title">teen</span><span class="params">(<span class="number">12.33</span>,<span class="number">123.5</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">Human <span class="title">human</span><span class="params">(<span class="number">23.12</span>,<span class="number">234.3</span>)</span></span>;</span><br><span class="line">    Human&amp; teen_r=teen;</span><br><span class="line">    Human&amp; human_r=human;</span><br><span class="line">    teen_r.say();</span><br><span class="line">    human_r.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;结果如下：</p>
<center>

  ![](https://ae01.alicdn.com/kf/HTB1tNIFSpzqK1RjSZFoq6zfcXXaB.jpg)

</center>


<p>&emsp;&emsp;然后是使用了虚函数的情况:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">show_hei</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">show_wei</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_hei</span><span class="params">(<span class="keyword">double</span> thei)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_wei</span><span class="params">(<span class="keyword">double</span> twei)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">        Human(<span class="keyword">int</span> hei,<span class="keyword">int</span> wei):hei(hei),wei(wei)&#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~Human()&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> hei;</span><br><span class="line">        <span class="keyword">int</span> wei;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Human::show_hei</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hei="</span>&lt;&lt;hei&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> hei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Human::show_wei</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"wei"</span>&lt;&lt;wei&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> wei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Human::set_hei</span><span class="params">(<span class="keyword">double</span> thei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hei=thei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Human::set_wei</span><span class="params">(<span class="keyword">double</span> twei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wei=twei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Human::say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am a Human object"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teen</span>:</span><span class="keyword">public</span> Human&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Teen(<span class="keyword">int</span> hei,<span class="keyword">int</span> wei,<span class="keyword">bool</span> good):Human(hei,wei),isgood(good)&#123;&#125;;        <span class="comment">//派生类构造函数在初始化基类私有函数时，通过初始化列表的语法使用基类构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">bool</span> isgood;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teen::say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am a Teen object"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Teen <span class="title">teen</span><span class="params">(<span class="number">12.33</span>,<span class="number">123.5</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">Human <span class="title">human</span><span class="params">(<span class="number">23.12</span>,<span class="number">234.3</span>)</span></span>;</span><br><span class="line">    Human&amp; teen_r=teen;</span><br><span class="line">    Human&amp; human_r=human;</span><br><span class="line">    teen_r.say();</span><br><span class="line">    human_r.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;结果如下：</p>
<center>

  ![](https://ae01.alicdn.com/kf/HTB1WbFCfK3tHKVjSZSgq6x4QFXaG.jpg)

</center> 

<ul>
<li>另外，在一个具有派生类的基类中，惯例是将析构函数声明为虚函数，这可以保证释放派生类对象时按照正确的顺序释放。</li>
</ul>
<h3 id="与派生类有关的的指针和引用类型的兼容性"><a href="#与派生类有关的的指针和引用类型的兼容性" class="headerlink" title="与派生类有关的的指针和引用类型的兼容性"></a>与派生类有关的的指针和引用类型的兼容性</h3><ul>
<li>一个基类指针或引用可以引用派生类对象，而不必进行显式类型转换。其内部逻辑是，公有继承建立的是is-a关系，即派生类也是基类，派生类只不过是基类的一个特例而已(比如说，基类”人”和派生类”中国人”，中国人也是人，所以一个指向”人”的指针或引用也可以指向”中国人”对象)。</li>
</ul>
<h3 id="静态联编与动态联编"><a href="#静态联编与动态联编" class="headerlink" title="静态联编与动态联编"></a>静态联编与动态联编</h3><ul>
<li>联编：通常来说联编就是将模块或者函数合并在一起生成可执行代码的处理过程，同时对每个模块或者函数调用分配内存地址，并且对外部访问也分配正确的内存地址，它是计算机程序彼此关联的过程。</li>
<li>静态联编：静态联编是指在编译阶段就将函数实现和函数调用关联起来，因此静态联编也叫早绑定，在编译阶段就必须了解所有的函数或模块执行所需要检测的信息</li>
<li><p>动态联编：动态联编是指在程序执行的时候才将函数实现和函数调用关联，因此也叫运行时绑定或者晚绑定。</p>
</li>
<li><p>C中的联编都是静态联编</p>
</li>
<li>C++中的联编一般是静态联编，在涉及模板、虚函数时则是动态联编</li>
</ul>
<h4 id="动态联编、静态联编与继承有何关系？"><a href="#动态联编、静态联编与继承有何关系？" class="headerlink" title="动态联编、静态联编与继承有何关系？"></a>动态联编、静态联编与继承有何关系？</h4><ul>
<li>这主要与上面说到的虚函数(虚方法)有关。虚函数使得在编译过程中并不知道哪一个函数会被调用，这就要求在程序执行时才将函数实现和函数调用关联，即动态联编。</li>
</ul>
<h4 id="一些关于动态联编的问题"><a href="#一些关于动态联编的问题" class="headerlink" title="一些关于动态联编的问题"></a>一些关于动态联编的问题</h4><ul>
<li><p>Q：静态联编能解决的问题，动态联编也能解决，为什么不摒弃静态联编或将动态联编设为默认？</p>
<p>A：动态联编虽好，但它需要在程序运行时采取一些方法跟踪基类指针或引用指向的对象类型，这导致了额外的处理开销。</p>
</li>
<li><p>Q：动态联编是怎么实现的？</p>
<p>A：在C++中，动态联编的体现就是虚函数。故这个问题可以看作是:”虚函数是怎么实现的”。通常，编译器是这么处理虚函数的：对于一个具有虚函数的对象，为其添加一个隐藏成员。<br>该成员是一个指针变量，指向一个函数地址数组。数组中的内容是为类对象声明的虚函数的地址。这个数组被称为虚函数表(vtbl)。一个基类对象中的该指针指向基类中的所有虚函数的地址表。<br>而一个派生类对象的该指针则指向另一个独立的虚函数表。对于一个在基类与派生类中都存在的虚函数(指同名)，若派生类中该函数没有被重新定义，则派生类虚函数表中，该函数的地址<br>与基类中该函数的地址相同。若重新定义了，则派生类的虚函数表将保存该函数的新地址。另外，如果在派生类中生命了一个基类中没有的虚函数，其地址也会被加入派生类的虚函数表中。<br>&lt;/br&gt;&lt;/br&gt;<br>贴一张C++ Primer Plus上的图<br>&lt;/br&gt;&lt;/br&gt;</p>
<center>


</center></li>
</ul>
<p>  <img src="https://ae01.alicdn.com/kf/HTB18EkCSxTpK1RjSZFKq6y2wXXav.jpg" alt></p>
<p>&lt;/center&gt;</p>
<p>  &lt;/br&gt;</p>
<p>  在调用虚函数的时候，程序首先查看引用或指针指向的对象的虚函数表的地址，然后再访问相应的虚函数表，再根据实际调用的函数，访问虚函数表中相应的函数的地址。</p>
<p>  正是因为这种实现机制，虚函数会带来更大的空间与时间消耗，因为:&lt;/br&gt;&lt;/br&gt;<br>  1.对于每一个具有虚函数的对象，都要增加一个指针变量&lt;/br&gt;<br>  2.对于每一个具有虚函数的类，都要生成一个虚函数表&lt;/br&gt;<br>  3.执行过程中还要进行到虚函数表中查找虚函数地址的操作&lt;/br&gt;</p>
<h4 id="有关虚函数的注意事项"><a href="#有关虚函数的注意事项" class="headerlink" title="有关虚函数的注意事项"></a>有关虚函数的注意事项</h4><ul>
<li>构造函数不可以是虚函数</li>
<li>析构函数最好是虚函数，除非该类没有派生类</li>
<li>友元函数不能是虚函数，因为友元不是成员函数，而只有成员函数才能成为虚函数</li>
<li>在派生类中重新定义虚函数时，应保持函数原型与基类中的相同(至少参数列表要相同)&lt;/br&gt;<br>这是因为,在派生类中重新定义虚函数时，并不会生成该函数的两个重载版本，而是在派生类中隐藏掉基类中所有同名的虚函数。<br>以下代码是一个错误示范。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">show_hei</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">show_wei</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_hei</span><span class="params">(<span class="keyword">double</span> thei)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_wei</span><span class="params">(<span class="keyword">double</span> twei)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">        Human(<span class="keyword">int</span> hei,<span class="keyword">int</span> wei):hei(hei),wei(wei)&#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~Human()&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> hei;</span><br><span class="line">        <span class="keyword">int</span> wei;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Human::show_hei</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hei="</span>&lt;&lt;hei&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> hei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Human::show_wei</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"wei"</span>&lt;&lt;wei&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> wei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Human::set_hei</span><span class="params">(<span class="keyword">double</span> thei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hei=thei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Human::set_wei</span><span class="params">(<span class="keyword">double</span> twei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wei=twei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Human::say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am a Human object"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teen</span>:</span><span class="keyword">public</span> Human&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Teen(<span class="keyword">int</span> hei,<span class="keyword">int</span> wei,<span class="keyword">bool</span> good):Human(hei,wei),isgood(good)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">bool</span> isgood;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teen::say</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am a Teen object"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am "</span>&lt;&lt;a&lt;&lt;<span class="string">" year(s) old."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Teen <span class="title">teen</span><span class="params">(<span class="number">12.33</span>,<span class="number">123.5</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">Human <span class="title">human</span><span class="params">(<span class="number">23.12</span>,<span class="number">234.3</span>)</span></span>;</span><br><span class="line">    teen.say();        <span class="comment">//这里会报错，因为基类的say()在派生类中被隐藏了</span></span><br><span class="line">    teen.say(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="纯虚函数与抽象基类"><a href="#纯虚函数与抽象基类" class="headerlink" title="纯虚函数与抽象基类"></a>纯虚函数与抽象基类</h3><ul>
<li><p>使用抽象基类来进行类的设计是一种更系统化、更有序的类设计方法。抽象基类指的是对于要创建的多个类，提取其公有特征，将这些特征整合成一个基类。抽象基类与普通的类的区别在于，抽象基类中包含有至少一个纯虚函数，而纯虚函数只提供接口不提供实现，也就是只需要声明，不需要实现，具体的实现在派生类中进行。要申明一个纯虚函数，只需要在虚函数的声明后面加上一个=0即可。另一个不同在于，抽象基类无法实例化。对于一个继承自抽象基类的派生类，若在这个类中给出了纯虚函数的实现，则这个派生类将转化为具体类，可以实例化。如果没有实现，则仍是抽象类，不能实例化。</p>
</li>
<li><p>抽象基类的意义是什么？</p>
</li>
</ul>
<blockquote>
<p>1.最重要的原因是，可以将接口与实现分离。接口是软件产品最有价值的资源，设计接口比实现接口需要耗费更昂贵的成本。因此，要将接口保护起来，以免在针对客户需求修改实现的时候，程序员不小心把接口破坏掉。<br><br>2.引入抽象基类和纯虚函数方便实现C++的多态特性。可以用抽象基类的指针去调用子类对象的方法。<br><br>3.很多时候，许多基类被实例化是不合理的。例如“形状”这个基类，被实例化之后反而会让人相当费解，所以干脆将“形状”这个类定义为抽象类，由它派生出正方形，三角形等子类。</p>
</blockquote>
<p>(引用自<a href="https://blog.csdn.net/zz56z56/article/details/84177250" rel="external nofollow noopener noreferrer" target="_blank">C++为什么要定义抽象基类</a>)</p>
<p>来一段代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Human()&#123;&#125;</span><br><span class="line">        Human(<span class="keyword">int</span> age,<span class="keyword">int</span> sex):age(age),sex(sex)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~Human()&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adult</span>:</span><span class="keyword">public</span> Human&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">        Adult(<span class="keyword">int</span> age,<span class="keyword">int</span> sex,<span class="built_in">string</span> str):Human(age,sex),job(str)&#123;&#125;</span><br><span class="line">        Adult()&#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~Adult()&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> job;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Adult::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am a "</span>&lt;&lt;job&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teen</span>:</span><span class="keyword">public</span> Human&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">        Teen(<span class="keyword">int</span> age,<span class="keyword">int</span> sex,<span class="keyword">int</span> sco):Human(age,sex),score(sco)&#123;&#125;</span><br><span class="line">        Teen()&#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~Teen()&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teen::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"my score is "</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Teen <span class="title">teen</span><span class="params">(<span class="number">12</span>,<span class="number">0</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> Job;</span><br><span class="line">    Job=<span class="string">"teacher"</span>;</span><br><span class="line">    <span class="function">Adult <span class="title">adult</span><span class="params">(<span class="number">1</span>,<span class="number">45</span>,Job)</span></span>;</span><br><span class="line">    Human* tp=&amp;teen;</span><br><span class="line">    Human* ap=&amp;adult;</span><br><span class="line">    tp-&gt;show();</span><br><span class="line">    ap-&gt;show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>继承</tag>
        <tag>学习笔记</tag>
        <tag>虚函数</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>【瞎搞】如何只用顺序结构实现三个数的排序</title>
    <url>/2019/01/26/%E3%80%90%E7%9E%8E%E6%90%9E%E3%80%91%E5%A6%82%E4%BD%95%E5%8F%AA%E7%94%A8%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>RT，如何在不用循环、不用判断、不用三目运算符的条件下，实现三个数字的排序？代码如下<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;a,&amp;b,&amp;c); </span><br><span class="line">    <span class="keyword">int</span> d=a*(a&lt;b)+b*(b&lt;=a);        <span class="comment">//求出a，b中的最小值，d即为这个最小值 </span></span><br><span class="line">    <span class="keyword">int</span> e=d*(d&lt;c)+c*(c&lt;=d);        <span class="comment">//求出三个中的最小; </span></span><br><span class="line">    d=(a+b-d)*(a+b-d&gt;c)+c*(c&gt;=a+b-d);    </span><br><span class="line">    <span class="comment">//d是a，b中的最小值，故a+b-d为a，b中的最大值，再通过上面这条式子选出a+b-d与c两者之间的较大值，即可得到三个数中的最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,e,a+b+c-e-d,d);        </span><br><span class="line">    <span class="comment">//e，d分别为最小值和最大值，三个数的总和减去最大值和最小值即得中间值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>想法来自：诸君有哪些有关排序的奇技淫巧？ - rsa的回答 - 知乎<br><a href="https://www.zhihu.com/question/269128251/answer/345732846" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/269128251/answer/345732846</a></p>
]]></content>
      <categories>
        <category>瞎搞</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>瞎搞</tag>
      </tags>
  </entry>
  <entry>
    <title>【求最小生成树】Prim算法&amp;Kruskal算法</title>
    <url>/2019/02/27/%E3%80%90%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E3%80%91Prim%E7%AE%97%E6%B3%95-Kruskal%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="一、概念解释"><a href="#一、概念解释" class="headerlink" title="一、概念解释"></a>一、概念解释</h4><p>首先解释几个概念：</p>
<p><ul></ul></p>
<p><li>连通图：在无向图中，若任意两个顶点vi与vj都有路径相通，则称该无向图为连通图。</li></p>
<p><li>强连通图：在有向图中，若任意两个顶点vi与vj都有路径相通，则称该有向图为强连通图。</li></p>
<p><li>连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</li></p>
<p><li>生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</li></p>
<p><li>最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。<br>&lt;/ul&gt;<br>(转自<a href="http://blog.csdn.net/luoshixian099/article/details/51908175" rel="external nofollow noopener noreferrer" target="_blank">勿在浮沙筑高台</a>)</li></p>
<p>&emsp;&emsp;简单来说，最小生成树就是在连通图中找出一颗树，这棵树满足这样的要求：1、可以将图中的所有顶点都连通；2、这颗树的边的权重和是最小的(具体到实际问题上，边的权重可能是成本、路程等)</p>
<p>&emsp;&emsp;求最小生成树一般有两种算法，一种是Prim算法，另一种则是Kruskal算法。</p>
<h4 id="二、Prim算法"><a href="#二、Prim算法" class="headerlink" title="二、Prim算法"></a>二、Prim算法</h4><p>&emsp;&emsp;Prim使用的是贪心的思想，与Dijkstra有异曲同工之处。它的原理是，先从图中任意选择一个起点，并记录下与这个点直接相连的点对应的边的权值，然后找到这些边中权值最小的，并将这个权值加到最终结果中，同时在vis数组里将选定的起点标记。然后然后我们将“起点”转移到刚才选择的权值最小边所对应的另一个顶点，重复上述过程，再找出一条与新起点直接相连的权值最小边，把它的权值加到最终结果中……不断重复以上过程共n-1次，即可找出最小生成树。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//low[]用来记录最小权值,vis[]为标记数组，标记已经走过的点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> mini; </span><br><span class="line">    <span class="keyword">int</span> rsl=<span class="number">0</span>;</span><br><span class="line">    mst(vis,<span class="number">0</span>);</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">int</span> pos=<span class="number">1</span>;        <span class="comment">//先以1为起点 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        low[i]=gra[pos][i];        <span class="comment">//存储与1相连的边的权值 </span></span><br><span class="line">    low[pos]=<span class="number">0</span>;vis[pos]=<span class="number">1</span>;        <span class="comment">//1到1的距离为0；1作为起点，可认为已在树里 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mini=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;mini&gt;low[j])&#123;        <span class="comment">//查找与1相连的权值最小的边， </span></span><br><span class="line">                mini=low[j];                <span class="comment">//将这一条边的另一个顶点加入树中， </span></span><br><span class="line">                pos=j;                        <span class="comment">//同时，将pos改为这条边的另一个顶点， </span></span><br><span class="line">            &#125;                                <span class="comment">//下一次找权值最小的边时从这一个点开始 </span></span><br><span class="line">        vis[pos]=<span class="number">1</span>;                            <span class="comment">//因为被找到的点已经加入了树中，所以vis[pos]=1； </span></span><br><span class="line">        <span class="keyword">if</span>(mini!=INF)         </span><br><span class="line">            rsl+=mini;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;low[j]&gt;gra[pos][j])</span><br><span class="line">                low[j]=gra[pos][j];        <span class="comment">////计算、更新与已经加入树中的点相连的边的最小权值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Prim与Dijkstra的相同之处在于，两者都用到了贪心思想，且都有点与点之间的转移。但不同之处在于，Dijkstra是求从一个点到另一个点的最短路，而Prim是求最小权值的树。这就决定了两者之间的一个区别，即Dijkstra的dis[]数组用于存放起点到每一个点的最短距离，而Prim的dis[]数组用于存放当前点到与它直接相连的点的最小权值。<del>(我怎么觉得我在说废话)</del></p>
<p>&emsp;&emsp;再来一道Prim的模板题→<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1233" rel="external nofollow noopener noreferrer" target="_blank">HDU1233 还是畅通工程</a></p>
<p>&emsp;&emsp;这题只需要直接套用模板即可，没什么需要注意的地方。可以通过这道题感受一下Prim怎么用。</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> gra[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> low[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> mini; </span><br><span class="line">    <span class="keyword">int</span> rsl=<span class="number">0</span>;</span><br><span class="line">    mst(vis,<span class="number">0</span>);</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">int</span> pos=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        low[i]=gra[pos][i];</span><br><span class="line">    low[pos]=<span class="number">0</span>;vis[pos]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mini=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;mini&gt;low[j])&#123;</span><br><span class="line">                mini=low[j];</span><br><span class="line">                pos=j;</span><br><span class="line">            &#125;</span><br><span class="line">        vis[pos]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mini!=INF)</span><br><span class="line">            rsl+=mini;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;low[j]&gt;gra[pos][j])</span><br><span class="line">                low[j]=gra[pos][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rsl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF&amp;&amp;n)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            gra[i][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tot=(n*(n<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            <span class="keyword">int</span> u,v,len;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;len);</span><br><span class="line">            gra[u][v]=gra[v][u]=len; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=prim();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三、Kruskal算法"><a href="#三、Kruskal算法" class="headerlink" title="三、Kruskal算法"></a>三、Kruskal算法</h4><p>&emsp;&emsp;与Prim的基于顶点不同，Kruskal是一种基于边的算法。它的原理是，首先将一个连通图的所有边存起来，然后根据权值从小到大对这些边进行排序。然后每次按权值从小到大的顺序取出一条边，检查这条边的两个顶点是否在同一个集合内，若是，则这条边弃之不用且永远不会被使用(否则会产生闭环)；否则，选用这条边，作为最小生成树的其中一条边(即将两个这条边对应的两个顶点合并入一个集合中)。而在检查与合并的过程中，为了保证效率，我们可以使用并查集来实现。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,wei;</span><br><span class="line">&#125;edge;        <span class="comment">//y用一个结构体表示边</span></span><br><span class="line">edge arr[<span class="number">5000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span>        <span class="comment">//用于边的排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.wei&lt;b.wei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==pre[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> pre[x]=findr(pre[x]);        <span class="comment">//找根节点同时进行压缩，提高往后查询时的效率</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rsl=<span class="number">0</span>;<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fx=findr(arr[i].from);</span><br><span class="line">        <span class="keyword">int</span> fy=findr(arr[i].to);        <span class="comment">//找根节点</span></span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)        <span class="comment">//如果不在一个集合内，则合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre[fx]=fy;</span><br><span class="line">            rsl+=arr[i].wei;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> rsl;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来一道Kruskal的模板题→<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1875" rel="external nofollow noopener noreferrer" target="_blank">HDU1875畅通工程再续</a></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> n,m,idx1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to;</span><br><span class="line">    <span class="keyword">double</span> len;</span><br><span class="line">&#125;edge;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;<span class="built_in">point</span>;</span><br><span class="line"><span class="built_in">point</span> p[<span class="number">105</span>];</span><br><span class="line">edge e[<span class="number">5000</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_len</span><span class="params">(<span class="built_in">point</span> pa,<span class="built_in">point</span> pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((pa.x-pb.x)*(pa.x-pb.x)+(pa.y-pb.y)*(pa.y-pb.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge e1,edge e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.len&lt;e2.len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=i;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==pre[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> pre[x]=findr(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> rsl=<span class="number">0</span>;<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=idx1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fx=findr(e[i].from);</span><br><span class="line">        <span class="keyword">int</span> fy=findr(e[i].to);</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[fx]=fy;</span><br><span class="line">            rsl+=e[i].len;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> rsl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">double</span> x,y;<span class="built_in">point</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;x,&amp;y);</span><br><span class="line">            tmp.x=x;tmp.y=y;</span><br><span class="line">            p[i]=tmp; </span><br><span class="line">        &#125;</span><br><span class="line">        idx1=<span class="number">1</span>;</span><br><span class="line">        m=(n*(n<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                edge temp;</span><br><span class="line">                temp.from=i;</span><br><span class="line">                temp.to=j;</span><br><span class="line">                temp.len=get_len(p[i],p[j]);</span><br><span class="line">                <span class="keyword">if</span>(temp.len&lt;=<span class="number">1000</span>&amp;&amp;temp.len&gt;=<span class="number">10</span>)</span><br><span class="line">                    e[idx1++]=temp; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(e,e+idx1,cmp);</span><br><span class="line">        <span class="keyword">double</span> ans=kruskal();</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"oh!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>,ans*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种算法的图解，可参考此文章→<a href="https://www.jianshu.com/p/efcd21494dff" rel="external nofollow noopener noreferrer" target="_blank">图的基本算法（最小生成树</a></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>Kruskal</tag>
        <tag>最小生成树</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title>几道水题(Gym101502A,Gym101502B,Gym - 101502E,Gym101502K)</title>
    <url>/2019/03/10/%E5%87%A0%E9%81%93%E6%B0%B4%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/101502/problem/A" rel="external nofollow noopener noreferrer" target="_blank">Gym101502A</a></p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> y;<span class="keyword">double</span> x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;y&gt;&gt;x;</span><br><span class="line">        <span class="keyword">double</span> ans=y/(<span class="number">1</span>+(x/<span class="number">100.0</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.0lf\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codeforces.com/gym/101502/problem/B" rel="external nofollow noopener noreferrer" target="_blank">Gym101502B</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll col[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">map</span>&lt;ll,ll&gt; rows;        <span class="comment">//数字，次数 </span></span><br><span class="line">        rows.erase(rows.<span class="built_in">begin</span>(),rows.<span class="built_in">end</span>());</span><br><span class="line">        ll n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ll row;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;row);</span><br><span class="line">            rows[row]++;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;col[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            sum+=rows[col[i]];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codeforces.com/gym/101502/problem/E" rel="external nofollow noopener noreferrer" target="_blank">Gym101502E</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">int</span> kit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> living=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bed=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'k'</span>)</span><br><span class="line">                kit++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'b'</span>)</span><br><span class="line">                bed++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'l'</span>)</span><br><span class="line">                living++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="built_in">min</span>(kit,<span class="built_in">min</span>(bed/<span class="number">2</span>,living));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codeforces.com/gym/101502/problem/K" rel="external nofollow noopener noreferrer" target="_blank">Gym101502K</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n;<span class="keyword">double</span> m;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        ll tmp;ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">            sum+=tmp&gt;=<span class="number">50</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> success=<span class="built_in">ceil</span>(m*n);</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=success)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces思维题（更新中）</title>
    <url>/2019/05/29/%E5%87%A0%E9%81%93CF%E6%B0%B4%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1DNhkXfxj_uVjSZFqq6yboFXaE.jpg" alt></p>
<p>Photo by NO NAME from Pixels<br><a id="more"></a></p>
<p><a href="https://cn.vjudge.net/problem/CodeForces-1141A" rel="external nofollow noopener noreferrer" target="_blank">Game 23</a></p>
<p>对m/n不断除以3，再除以2即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==m)&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m%n!=<span class="number">0</span>)&#123;</span><br><span class="line">        ans=<span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=m/n;</span><br><span class="line">        <span class="keyword">while</span>(tmp%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            tmp/=<span class="number">3</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span>(tmp%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            tmp/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp!=<span class="number">1</span>)</span><br><span class="line">            ans=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/CodeForces-1141B" rel="external nofollow noopener noreferrer" target="_blank">Maximal Continuous Rest</a></p>
<p>对于一个序列，设从左端开始的最长1序列的长度为len1，从右端开始的最长1序列的长度为len2，处于序列中间的最长1序列的长度为len3,最长的连续1序列的长度只可能是len3或len1+len2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">int</span> len1,len2;<span class="keyword">int</span> len3;</span><br><span class="line">    len1=len2=len3=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        len1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        len2++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    int beg,end;</span></span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            tmp=<span class="number">0</span>;</span><br><span class="line">            len3=<span class="built_in">max</span>(len3,tmp);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp++;</span><br><span class="line">        len3=<span class="built_in">max</span>(len3,tmp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;"len3="&lt;&lt;len3&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">max</span>(len3,len1+len2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/CodeForces-1141C" rel="external nofollow noopener noreferrer" target="_blank">Polycarp Restores Permutation</a></p>
<p>题意是说，存在一个序列$p$和序列$q$，且p是一个$1~n$的排列（就是说$1~n$这n个数都必须出现且只能出现一次），对于$q<em>i$，有$q_i=p</em>{i+1}-p<em>i$，即$p_i+q_i=p</em>{i+1}$。现在只给出q，让我们求出p。</p>
<p>分析后不难得出以下思路：我们可以先假设$p<em>1=1$，并根据$q_i=p</em>{i+1}-p_i$得出一段q序列，并找到该序列的最小值。该最小值正好对应的就是我们要求的$p$序列中的1，因此我们可以将现在的得到的p序列中的每一个值都加上1到当前最小值的差值，最后再用一个vis数组判断以下每个数的出现次数，即可得到答案。（转化为图像的话会更好理解）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> arr[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> seq[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("data_generator.txt","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mini=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    seq[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        seq[i+<span class="number">1</span>]=tmp=seq[i]+arr[i];</span><br><span class="line">        <span class="keyword">if</span>(vis.count(tmp))&#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[tmp]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;mini)&#123;</span><br><span class="line">            mini=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">int</span> raise=(mini&lt;=<span class="number">1</span>?<span class="number">1</span>-mini:mini<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans[i]=seq[i]+raise;</span><br><span class="line">        vis[ans[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]!=<span class="number">1</span>)&#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,ans[i],i==n?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/CodeForces-1141D" rel="external nofollow noopener noreferrer" target="_blank">Colored Boots</a></p>
<p>题意是说对于两个字符串，每个字母代表一种颜色，两个相同的字母可以凑成一对，问如果从字符串一中挑出一个字符、再从字符串二中挑出一个字符（挑出后不放回），最多能凑出多少对。如果字符为’?’，说明该字符可以与任何字符配对（包括’?’）</p>
<p>暴力贪心即可😀</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">150000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lef[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rig[<span class="number">128</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lef_boot;</span><br><span class="line">    <span class="keyword">int</span> rig_boot;</span><br><span class="line">&#125;;</span><br><span class="line">node ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> l,r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        lef[l[i]].push_back(i+<span class="number">1</span>);</span><br><span class="line">        rig[r[i]].push_back(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">97</span>;i&lt;=<span class="number">122</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!lef[i].empty()&amp;&amp;!rig[i].empty())&#123;</span><br><span class="line">            ans[cnt++]=node&#123;lef[i].back(),rig[i].back()&#125;;</span><br><span class="line">            lef[i].pop_back();</span><br><span class="line">            rig[i].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">97</span>;i&lt;=<span class="number">122</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!lef[<span class="string">'?'</span>].empty()&amp;&amp;!rig[i].empty())&#123;</span><br><span class="line">            ans[cnt++]=node&#123;lef[<span class="string">'?'</span>].back(),rig[i].back()&#125;;</span><br><span class="line">            lef[<span class="string">'?'</span>].pop_back();rig[i].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lef[<span class="string">'?'</span>].empty())        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">97</span>;i&lt;=<span class="number">122</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!rig[<span class="string">'?'</span>].empty()&amp;&amp;!lef[i].empty())&#123;</span><br><span class="line">            ans[cnt++]=node&#123;lef[i].back(),rig[<span class="string">'?'</span>].back()&#125;;</span><br><span class="line">            rig[<span class="string">'?'</span>].pop_back();lef[i].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rig[<span class="string">'?'</span>].empty())        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!lef[<span class="string">'?'</span>].empty()&amp;&amp;!rig[<span class="string">'?'</span>].empty())&#123;</span><br><span class="line">        ans[cnt++]=node&#123;lef[<span class="string">'?'</span>].back(),rig[<span class="string">'?'</span>].back()&#125;;</span><br><span class="line">        lef[<span class="string">'?'</span>].pop_back();rig[<span class="string">'?'</span>].pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans[i].lef_boot,ans[i].rig_boot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/CodeForces-1140C" rel="external nofollow noopener noreferrer" target="_blank">Playlist</a></p>
<p>题意是说，对于一个序列，每一个元素都包含$t_i$和$b_i$两个值，现在要求一个长度不超过$k$的子序列，使得该序列中的值满足$\Sigma\ t_i\times \ min(b_i)$的值最大。</p>
<p>emmmmmm一开始我是用的dp，因为感觉这题很像01背包，如果把k看作是背包总容量，每个元素的体积是1的话……但事实是我搞不出来OTZ……然后就去看题解了OTZ</p>
<p>正确做法是贪心。因为我们要求的是$\Sigma\ t_i\times \ min(b_i)$的最大值，而要让该值最大，我们应该贪心地选择更大的$t_i$。具体来说就是，先对所有元素按照$b$值从小到大排个序，然后从左到右扫描这些元素（排序的目的是为了保证扫过去时取到的$b_i$一定不大于上一次取到的$b_i$，也就是保证取得最小的$b_i$），然后在这个过程中，用优先队列维护$t$值前k大的元素。在选择元素的过程中，如果当前被选元素的个数大于$k$，就把队列中$t$值最小的pop出去，并更新答案。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,b;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; nb)&#123;</span><br><span class="line">        <span class="keyword">return</span> b&lt;nb.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node ns[<span class="number">3</span>*maxn];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ns[i].t&gt;&gt;ns[i].b;</span><br><span class="line">    sort(ns+<span class="number">1</span>,ns+n+<span class="number">1</span>);</span><br><span class="line">    ll ans=<span class="number">-1</span>;ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        sum+=ns[i].t;</span><br><span class="line">        que.push(ns[i].t);</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()&gt;k)&#123;</span><br><span class="line">            sum-=que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sum*ns[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(或许这题确实能用dp吧……)</p>
<p><a href="https://cn.vjudge.net/problem/CodeForces-1140D" rel="external nofollow noopener noreferrer" target="_blank">Minimum Triangulation</a></p>
<p>题意是说，对于一个多边形，首先按顺时针顺序从1开始对顶点进行排序。然后我们将他分割成若干个不重叠的三角形，并规定，对于每个三角形，其权重为三个顶点的序号的乘积。问如何分割该多边形可以使得其三角形权重和最小。</p>
<p>emmmmm……大水题<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">        ans=<span class="number">6</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">4</span>)&#123;</span><br><span class="line">        ans=<span class="number">18</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">            ans+=i*(i+<span class="number">1</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://cn.vjudge.net/problem/CodeForces-1139A" rel="external nofollow noopener noreferrer" target="_blank">Even Substrings</a></p>
<p>emmmmm也是大水题<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=str[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            ans+=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://cn.vjudge.net/problem/CodeForces-1139B" rel="external nofollow noopener noreferrer" target="_blank">Chocolates</a></p>
<p>题意是说对于一个序列$a_n$,可以从第i个位置取出$x_i(x_i&lt;=a_i)$，从而形成一个新的序列$x_n$，该序列必须满足以下两个条件中至少一个:</p>
<ul>
<li>$x_i=0$</li>
<li>若$i&lt;j$，则$x_i&lt;x_j$</li>
</ul>
<p>依然是大水题……</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ll arr[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    ll n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ans+=arr[n];ll tmp=arr[n];</span><br><span class="line">    <span class="keyword">for</span>(ll i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;tmp)&#123;</span><br><span class="line">            tmp=arr[i];</span><br><span class="line">            ans+=arr[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp<span class="number">-1</span>&gt;<span class="number">0</span>)</span><br><span class="line">                tmp--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp=<span class="number">0</span>;</span><br><span class="line">            ans+=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>水题</tag>
        <tag>思维题</tag>
        <tag>水题不水</tag>
      </tags>
  </entry>
  <entry>
    <title>基础dp专题总结 Part 1</title>
    <url>/2019/07/28/%E5%9F%BA%E7%A1%80dp%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93-Part-1/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H814b65cf7389427c925e1c64354420a29.jpg" alt></p>
<p>Photo by Suvan Chowdhury from Pexels<br><a id="more"></a></p>
<h4 id="HDU1024-Max-Sum-Plus-Plus"><a href="#HDU1024-Max-Sum-Plus-Plus" class="headerlink" title="HDU1024 Max Sum Plus Plus"></a><a href="https://cn.vjudge.net/problem/HDU-1024" rel="external nofollow noopener noreferrer" target="_blank">HDU1024 Max Sum Plus Plus</a></h4><p>题意是说，对于一个序列$S$，找出$m$个数对$(i_1,j_1)$，$(i_2,j_2)$，$(i_3,j_3)$，······,$(i_m,j_m)$，使得这些数对对应的区间和的和最大，也就是让$Sum=sum(i_1,j_1)+sum(i_2,j_2)+sum(i_3,j_3)+…+sum(i_m,j_m)$最大。输出该最大和。</p>
<p>首先，状态转移方程为</p>
<script type="math/tex; mode=display">
dp[i][j]=max(dp[i][j-1]+arr[j],max(dp[i-1][k])+arr[j])\\
0<k<j</script><p>$dp[i][j]$表示将前$j$个数分成$i$组，$dp[i][j-1]+arr[j]$表示前j个数分成$i$组，第$j$个数放在第$i$组里面；$max(dp[i-1][k])+arr[j]$表示从前$j-1$个数中取出$k$个数，将他们分成$i-1$组，然后第$j$个数自成一组，总共$i$组。</p>
<p>但如果只是单纯这样做的话，由于数据范围比较大$(1 ≤ x ≤ n ≤ 1000000)$，这种$O(n^3)$的做法肯定会超时，因此要做一定的优化。</p>
<p>方法是，另外开一个$maxi_[]$数组，用来存放$dp[i-1]$中的最大值。$maxi_[j-1]$标识的就是当前$dp[i-1]$中的最大值。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout&lt;&lt;<span class="meta-string">"debug"</span>&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> maxi_[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;m,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=-INF;</span><br><span class="line">        mst(dp,<span class="number">0</span>);mst(maxi_,<span class="number">0</span>);</span><br><span class="line">        mst(arr,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            ans=-INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j<span class="number">-1</span>]+arr[j],maxi_[j<span class="number">-1</span>]+arr[j]);</span><br><span class="line">                maxi_[j<span class="number">-1</span>]=ans;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HDU1029-lgnatius-and-the-Princess-IV"><a href="#HDU1029-lgnatius-and-the-Princess-IV" class="headerlink" title="HDU1029 lgnatius and the Princess IV"></a><a href="https://cn.vjudge.net/problem/HDU-1029" rel="external nofollow noopener noreferrer" target="_blank">HDU1029 lgnatius and the Princess IV</a></h4><p>题意是说，给出一个奇数N，以及一个长度为N的整数序列，问序列中出现次数至少为$\frac{N+1}{2}$的数是什么</p>
<ul>
<li>可以直接用map做</li>
<li>但既然是dp专题，肯定要用dp来做🦆</li>
</ul>
<p>dp做法涉及到了一个叫做摩尔投票算法的东西。事实上这道题就是该算法的板子题。下面先上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout&lt;&lt;<span class="meta-string">"debug"</span>&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;<span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">                ans=arr[i];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans==arr[i])</span><br><span class="line">                    cnt++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一种非常通俗易懂的方法解释该算法：将每一种数想象成是一个阵营的士兵，当一个阵营的士兵遇到另一个阵营的士兵时，双方会发生战斗，且结果一定是同归于尽。$cnt$其实就是在统计一个阵营的士兵数目。当所有士兵都战斗过一次后（也就是序列被遍历完了），剩下的士兵就是我们要求的数。</p>
<h4 id="HDU1069-Monkey-and-Banana"><a href="#HDU1069-Monkey-and-Banana" class="headerlink" title="HDU1069 Monkey and Banana"></a><a href="https://cn.vjudge.net/problem/HDU-1069" rel="external nofollow noopener noreferrer" target="_blank">HDU1069 Monkey and Banana</a></h4><p>题目大意是说，有若干种方块，对于每一种方块，可以以它的任意一个面为底面。现在要求使用这若干种方块堆成一座塔，要求是每一个方块正上方的那个方块的底面长和宽必须严格小于当前方块顶面的长和宽。</p>
<p>emmmmmmmm这题就是Uva的那道巴比伦塔啊……就改了一下题目描述，连样例都没改hhhhh。</p>
<p>做法就是求DAG上的最长路，dfs+记忆化即可。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> bs[<span class="number">35</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">35</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> idx,<span class="keyword">int</span> hidx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=hidx)&#123;</span><br><span class="line">            arr[cnt++]=bs[idx][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> hidx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; ans=dp[idx][hidx];</span><br><span class="line">    <span class="keyword">if</span>(ans!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b1[<span class="number">2</span>],b2[<span class="number">2</span>];</span><br><span class="line">    get_(b1,idx,hidx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">            get_(b2,i,j);</span><br><span class="line">            <span class="keyword">if</span>((b2[<span class="number">0</span>]&lt;b1[<span class="number">0</span>]&amp;&amp;b2[<span class="number">1</span>]&lt;b1[<span class="number">1</span>])||(b2[<span class="number">1</span>]&lt;b1[<span class="number">0</span>]&amp;&amp;b2[<span class="number">0</span>]&lt;b1[<span class="number">1</span>]))</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,solve(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=bs[idx][hidx];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n)&#123;</span><br><span class="line">        mst(bs,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;bs[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            sort(bs[i]+<span class="number">1</span>,bs[i]+<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mst(dp,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,solve(i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;++kase&lt;&lt;<span class="string">": maximum height = "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//Case 1: maximum height = 40</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HDU1074-Doing-Homework"><a href="#HDU1074-Doing-Homework" class="headerlink" title="HDU1074 Doing Homework"></a><a href="https://cn.vjudge.net/problem/HDU-1074" rel="external nofollow noopener noreferrer" target="_blank">HDU1074 Doing Homework</a></h4><p>一道状压dp的题目，刚看到题目的时候真的没有想到是状压dp……因为当时我还不会状压……看了题解，才知道这题要用状压。于是去学了一波，做了几道入门题，然后才来做这道题。</p>
<p>这题的题解已经在之前的一篇文章中有写到了，故贴出链接，不再赘述</p>
<p><a href="https://xtayex.github.io/2019/07/22/%E7%8A%B6%E5%8E%8Bdp%E6%80%BB%E7%BB%93-%E6%9B%B4%E6%96%B0%E4%B8%AD/" rel="external nofollow noopener noreferrer" target="_blank">状压dp总结</a></p>
<h4 id="HDU1087-Super-Jumping-Jumping-Jumping"><a href="#HDU1087-Super-Jumping-Jumping-Jumping" class="headerlink" title="HDU1087 Super Jumping! Jumping! Jumping!"></a><a href="https://cn.vjudge.net/problem/HDU-1087" rel="external nofollow noopener noreferrer" target="_blank">HDU1087 Super Jumping! Jumping! Jumping!</a></h4><p>其实就是求最大和上升子序列，也就是对于给定的序列，找出一个子序列，使得该子序列的总和最大。输出该最大和。</p>
<p>状态转移方程为:</p>
<script type="math/tex; mode=display">
dp[i]=max(dp[j]+arr[i],dp[i]),\ 0 ≤j<i</script><p>$dp[i]$表示由前$i$个数组成的序列的最大和上升子序列和为多少。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n)&#123;</span><br><span class="line">        mst(arr,<span class="number">0</span>);mst(dp,-INF);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=arr[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=arr[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;arr[i])&#123;</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans=<span class="built_in">max</span>(dp[i],ans);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HDU1114-Piggy-Bank"><a href="#HDU1114-Piggy-Bank" class="headerlink" title="HDU1114 Piggy-Bank"></a><a href="https://cn.vjudge.net/problem/HDU-1114" rel="external nofollow noopener noreferrer" target="_blank">HDU1114 Piggy-Bank</a></h4><p>完全背包模板题，之前的题解中已有提及到此题，不在赘述。</p>
<p><a href="https://xtayex.github.io/2019/02/17/POJ1384-Piggy-Bank/" rel="external nofollow noopener noreferrer" target="_blank">POJ1384 - Piggy Bank</a></p>
<h4 id="HDU1176-免费馅饼"><a href="#HDU1176-免费馅饼" class="headerlink" title="HDU1176 免费馅饼"></a><a href="https://cn.vjudge.net/problem/HDU-1176" rel="external nofollow noopener noreferrer" target="_blank">HDU1176 免费馅饼</a></h4><p>题意是说，有若干个馅饼掉落，馅饼$p_i$会在时间$t_i$掉落到位置$x_i$处。初始时你位于位置5，每秒钟你只可以往左或往右移动一个单位，问能够接到的馅饼数目是多少。</p>
<script type="math/tex; mode=display">
dp[i][j]=max(dp[i+1][j],max(dp[i+1][j-1],dp[i+1][j+1]))+bs[i][j]</script><p>$dp[i][j]$表示在时间$i$、位置$j$接到的最多馅饼数；$bs[i][j]$表示在时间$i$，位置$j$掉到地上的馅饼的数目。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> bs[maxn][<span class="number">15</span>];        <span class="comment">//时间,位置 </span></span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">15</span>];        <span class="comment">//时间,位置 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF&amp;&amp;n)&#123;</span><br><span class="line">        <span class="keyword">int</span> ubt=-INF;mst(bs,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,t;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;t);</span><br><span class="line">            bs[t][x]++;</span><br><span class="line">            ubt=<span class="built_in">max</span>(ubt,t);</span><br><span class="line">        &#125;</span><br><span class="line">        mst(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=ubt;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>],dp[i+<span class="number">1</span>][j+<span class="number">1</span>]))+bs[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=dp[<span class="number">0</span>][<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HDU1260-Tickets"><a href="#HDU1260-Tickets" class="headerlink" title="HDU1260 Tickets"></a><a href="https://cn.vjudge.net/problem/HDU-1260" rel="external nofollow noopener noreferrer" target="_blank">HDU1260 Tickets</a></h4><p>题意是说，对于一个整数序列，有两种操作，一种是删除当前的一个数，一种是删除相邻的两个数，两种操作都对应一定的费用。现在要求从左到右进行操作，问将所有数删除掉所需要的最小费用是多少。</p>
<p>直接转移即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> t1[maxn],t2[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time</span><span class="params">(<span class="keyword">int</span> todo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=todo;</span><br><span class="line">    <span class="keyword">int</span> mins=todo/<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> hr=<span class="number">8</span>+mins/<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> sec=todo%<span class="number">60</span>%<span class="number">60</span>;</span><br><span class="line">    mins%=<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> htmp=hr;</span><br><span class="line">    <span class="keyword">if</span>(hr&gt;<span class="number">12</span>)        hr-=<span class="number">12</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d "</span>,hr,mins,sec);</span><br><span class="line">    <span class="keyword">if</span>(htmp&lt;<span class="number">12</span>)        <span class="built_in">printf</span>(<span class="string">"am\n"</span>);</span><br><span class="line">    <span class="keyword">else</span>        <span class="built_in">printf</span>(<span class="string">"pm\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(t1,<span class="number">0</span>,<span class="keyword">sizeof</span>(t1));</span><br><span class="line">        <span class="built_in">memset</span>(t2,<span class="number">0</span>,<span class="keyword">sizeof</span>(t2));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t1[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k<span class="number">-1</span>;i++)        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t2[i]);</span><br><span class="line">        dp[<span class="number">1</span>]=t1[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="built_in">min</span>(t1[<span class="number">1</span>]+t1[<span class="number">2</span>],t2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>]+t1[i],dp[i<span class="number">-2</span>]+t2[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=dp[k];</span><br><span class="line">        Time(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HDU1257-最少拦截系统"><a href="#HDU1257-最少拦截系统" class="headerlink" title="HDU1257 最少拦截系统"></a><a href="https://cn.vjudge.net/problem/HDU-1257" rel="external nofollow noopener noreferrer" target="_blank">HDU1257 最少拦截系统</a></h4><p>题目是说，对于一连串导弹，一套拦截系统所能拦截的导弹的高度不能大于该系统上一次拦截的导弹的高度。问要拦截所有的导弹，最少要多少套拦截系统。</p>
<p>这题直接贪心模拟即可，对于每一发导弹，检查当前存在的拦截系统是否可以将其拦截。如果存在一套拦截系统可以将该导弹拦截，就将此系统的高度改为该导弹的高度；如果不存在，就添加一套系统，并将其高度设为当前导弹的高度。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> sys[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;sys[cnt++]=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sys[j]&gt;=arr[i])&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;sys[j]=arr[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">                sys[cnt++]=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，因为sys数组是单调不减的，所以也可以将内层循环优化为二分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> sys[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;sys[cnt++]=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>* pos=lower_bound(sys,sys+cnt,arr[i]);</span><br><span class="line">            <span class="keyword">int</span> idx=pos-sys;</span><br><span class="line">            <span class="keyword">if</span>(pos==sys+cnt)</span><br><span class="line">                sys[cnt++]=arr[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sys[idx]=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>基础DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>基础DP</tag>
      </tags>
  </entry>
  <entry>
    <title>卢卡斯定理与中国剩余定理</title>
    <url>/2019/01/28/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%E4%B8%8E%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h4 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h4><p>&emsp;&emsp;卢卡斯定理主要是用来求组合数取模，即C(n,m)%p。其适用范围是:组合数很大，但p又不是很大且p是素数的情况(10^6+3也算是“不很大”) 。卢卡斯定理可以表达为:<br><a id="more"></a><br><img src="https://pic.superbed.cn/item/5c4ea00b5f3e509ed97ce0f6" alt></p>
<p>在写代码时，可以用递归实现:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">lucas</span><span class="params">(LL a,LL b,LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b?<span class="number">1</span>:lucas(a/p,b/p,p)*comb(a%p,b%p,p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么可以转化为lucas(a/p,b/p,p) * comb(a%p,b%p,p)%p这个递归呢？看这里👇<br><img src="https://pic.superbed.cn/item/5c4ea0d75f3e509ed97ce5e1" alt><br><img src="https://pic.superbed.cn/item/5c4ea0f25f3e509ed97ce666" alt></p>
<p>因此，可以利用这样的一个递归实现。<br>在这里，comb()是求组合数取模的函数(适用于小组合数)，代码为<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">LL comb(LL n,LL m,LL p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m||m&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL up=<span class="number">1</span>;</span><br><span class="line">    LL down=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL <span class="built_in">i</span>=n-m+<span class="number">1</span>;<span class="built_in">i</span>&lt;=n;<span class="built_in">i</span>++)</span><br><span class="line">        up=(up*<span class="built_in">i</span>)<span class="comment">%p;</span></span><br><span class="line">    <span class="keyword">for</span>(LL <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=m;<span class="built_in">i</span>++)</span><br><span class="line">        down=(down*<span class="built_in">i</span>)<span class="comment">%p;</span></span><br><span class="line">    <span class="keyword">return</span> up*inv(down,p)<span class="comment">%p;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而inv()是求down的逆元的函数，原理是利用快速幂求a^(p-2)。</p>
<h4 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4><p>&emsp;&emsp;中国剩余定理又被称为孙子定理，它来自于一个耳熟能详的数学问题：今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？。转换为数学式子，即为以下这个一元线性同余方程组<br><img src="https://pic.superbed.cn/item/5c4ea2b05f3e509ed97cf145" alt><br>那么，要如何求解这个方程组呢？<br><img src="https://pic.superbed.cn/item/5c4ea3675f3e509ed97cf50c" alt><br>(我自己至今还是不太懂怎么求解OTZ)<br>因此，只需要求kM+∑(i=1,n)ai x ti x Mi即可</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">china</span><span class="params">(<span class="keyword">int</span> k,LL a[],LL m[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL M=<span class="number">1</span>;LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        M*=m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL tmp=M/m[i];        <span class="comment">//tmp==&gt;mi        </span></span><br><span class="line">        ans=(ans+mulq(tmp*inv(tmp,m[i]),a[i],M))%M;        <span class="comment">//ti==&gt;ti*mi=1 (mod mi)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans+M)%M;            <span class="comment">//通解为kM+∑(i=0,k)(ai*ti*Mi) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>快速乘算法</title>
    <url>/2019/01/28/%E5%BF%AB%E9%80%9F%E4%B9%98%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>&emsp;&emsp;原理与快速幂相似，利用二进制将两个数的乘法运算转化为加法运算。具体代码如下:<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans+=a;</span><br><span class="line">        a+=a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加上取模的话是这样:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=(ans+a)%p;</span><br><span class="line">        a=(a+a)%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;快速乘其实是利用了二进制与乘法分配律。以 2 x 7 为例，因为 7(10) = 111(2) = 100(2)+ 010(2) + 001(2) = 4(10)+2(10)+1(10)，也就是 2 x 7 = 2 x ( 4 + 2 + 1 ) = 8 + 4 + 2，从而将乘法转化为加法(对于计算机而言，算加法要比算乘法快得多) </p>
<p>&emsp;&emsp;我们再将快速幂与快速乘对比一下:<br>快速幂:<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> fpow(<span class="built_in">int</span> a,<span class="built_in">int</span> b)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans*=a;</span><br><span class="line">        a*=a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>快速乘:<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> mul(<span class="built_in">int</span> a,<span class="built_in">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans+=a;</span><br><span class="line">        a+=a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现，两者之间的差别只有加号与乘号的差别。这是因为，乘法就是若干次加法，而求幂就是若干次乘法。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>基础dp专题总结 Part 2</title>
    <url>/2019/07/28/%E5%9F%BA%E7%A1%80dp%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93-Part-2/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H7073915b94cb45789270cb9ac2829fb6e.jpg" alt><br><a id="more"></a></p>
<h4 id="HDU1160-FatMouse’s-Speed"><a href="#HDU1160-FatMouse’s-Speed" class="headerlink" title="HDU1160 FatMouse’s Speed"></a><a href="https://cn.vjudge.net/problem/HDU-1160" rel="external nofollow noopener noreferrer" target="_blank">HDU1160 FatMouse’s Speed</a></h4><p>题意是说，有两个整数序列$W$和$S$，要求找出一组下标$m_1,m_2,m_3,···,m_n$，使得<script type="math/tex">W[m_1]<W[m_2]<W[m_3]<···<W[m_n]</script>且<script type="math/tex">S[m_1]>S[m_2]>S[m_3]>···>S[m_n]</script>。下标的个数应尽可能地多。要求输出下标的个数以及被选出的下标。</p>
<p>对所有的$W-S$对进行排序，排序规则是按$W$为第一关键字从小到大排序，按$S$为第二关键字从大到小排序。而dp的方法其实跟LIS或者最大上升子序列和是很像的。关于输出被选取的下标，其实就是记录路径，只需要用一个pre数组记录下每一个下标的前驱，然后递归回去即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> wei;</span><br><span class="line">    <span class="keyword">int</span> speed;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; nn)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(wei!=nn.wei)</span><br><span class="line">            <span class="keyword">return</span> wei&lt;nn.wei;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> speed&gt;nn.speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node ns[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> todo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[todo]==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ns[todo].id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    show(pre[todo]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ns[todo].id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> w,s;<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ID=<span class="number">0</span>;</span><br><span class="line">    mst(pre,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;w&gt;&gt;s)&#123;</span><br><span class="line">        ns[cnt].wei=w;</span><br><span class="line">        ns[cnt].id=++ID;</span><br><span class="line">        ns[cnt++].speed=s;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ns,ns+cnt);</span><br><span class="line">    <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ns[j].wei&lt;ns[i].wei&amp;&amp;ns[j].speed&gt;ns[i].speed)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i]&lt;dp[j]+<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">                    pre[i]=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp=ans;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">        <span class="keyword">if</span>(ans!=tmp)</span><br><span class="line">            last=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    show(last);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="POJ1015-Jury-Compromise"><a href="#POJ1015-Jury-Compromise" class="headerlink" title="POJ1015 Jury Compromise"></a><a href="https://cn.vjudge.net/problem/POJ-1015" rel="external nofollow noopener noreferrer" target="_blank">POJ1015 Jury Compromise</a></h4><p>已有题解，不再赘述（确实是道好题）</p>
<p><a href="https://xtayex.github.io/2019/07/22/POJ1015-Jury-Compromise/" rel="external nofollow noopener noreferrer" target="_blank">POJ1015 - Jury Compromise</a></p>
<h4 id="POJ1458-Common-Subsequence"><a href="#POJ1458-Common-Subsequence" class="headerlink" title="POJ1458 Common Subsequence"></a><a href="https://cn.vjudge.net/problem/POJ-1458" rel="external nofollow noopener noreferrer" target="_blank">POJ1458 Common Subsequence</a></h4><p>题如其名，最长公共子序列。直接写就可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> sa,sb;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;sa&gt;&gt;sb)&#123;</span><br><span class="line">        mst(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> lena=sa.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> lenb=sb.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sa[i<span class="number">-1</span>]==sb[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[lena][lenb]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="POJ1661-Help-Jimmy"><a href="#POJ1661-Help-Jimmy" class="headerlink" title="POJ1661 Help Jimmy"></a><a href="https://cn.vjudge.net/problem/POJ-1661" rel="external nofollow noopener noreferrer" target="_blank">POJ1661 Help Jimmy</a></h4><p>题目大意不知道怎么描述……</p>
<p>思路就是从最下面的平台往上dp，$dp[i][0]$表示的是从当前平台往左走一直到下一个平台的边缘（左边缘或右边缘）所需要的最小时间。$dp[i][1]$表示的是从当前平台往右走一直到下一个平台的边缘（左边缘或右边缘）所需要的最小时间。此处的最小时间指的是从最下面的平台一直递推到当前平台的总时间。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lef,rig;</span><br><span class="line">    <span class="keyword">int</span> hei;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; nn)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hei&gt;nn.hei;        <span class="comment">//从大到小 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node ns[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,x,y,maxi;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left_</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;=n+<span class="number">1</span>;k++)&#123;        <span class="comment">//k在i下面 </span></span><br><span class="line">        <span class="keyword">if</span>(ns[k].lef&lt;=ns[i].lef</span><br><span class="line">        &amp;&amp;ns[k].rig&gt;=ns[i].lef</span><br><span class="line">        &amp;&amp;ns[i].hei-ns[k].hei&lt;=maxi)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k==n+<span class="number">1</span>)</span><br><span class="line">                dp[i][<span class="number">0</span>]=ns[i].hei-ns[k].hei;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                dp[i][<span class="number">0</span>]=ns[i].hei-ns[k].hei+<span class="built_in">min</span>(dp[k][<span class="number">0</span>]+ns[i].lef-ns[k].lef,dp[k][<span class="number">1</span>]+ns[k].rig-ns[i].lef);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ns[i].hei-ns[k].hei&gt;maxi)</span><br><span class="line">        dp[i][<span class="number">0</span>]=INF;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">right_</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;=n+<span class="number">1</span>;k++)&#123;        <span class="comment">//k在i下面 </span></span><br><span class="line">        <span class="keyword">if</span>(ns[k].lef&lt;=ns[i].rig</span><br><span class="line">        &amp;&amp;ns[k].rig&gt;=ns[i].rig</span><br><span class="line">        &amp;&amp;ns[i].hei-ns[k].hei&lt;=maxi)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k==n+<span class="number">1</span>)</span><br><span class="line">                dp[i][<span class="number">1</span>]=ns[i].hei-ns[k].hei;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                dp[i][<span class="number">1</span>]=ns[i].hei-ns[k].hei+<span class="built_in">min</span>(dp[k][<span class="number">0</span>]+ns[i].rig-ns[k].lef,dp[k][<span class="number">1</span>]+ns[k].rig-ns[i].rig);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ns[i].hei-ns[k].hei&gt;maxi)</span><br><span class="line">        dp[i][<span class="number">1</span>]=INF;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        mst(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;x&gt;&gt;y&gt;&gt;maxi;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;ns[i].lef&gt;&gt;ns[i].rig&gt;&gt;ns[i].hei;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ns+<span class="number">1</span>,ns+<span class="number">1</span>+n);</span><br><span class="line">        dp[n+<span class="number">1</span>][<span class="number">0</span>]=dp[n+<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        ns[n+<span class="number">1</span>].lef=-INF;ns[n+<span class="number">1</span>].rig=INF;ns[n+<span class="number">1</span>].hei=<span class="number">0</span>;</span><br><span class="line">        ns[<span class="number">0</span>].lef=ns[<span class="number">0</span>].rig=x;ns[<span class="number">0</span>].hei=y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            left_(i);</span><br><span class="line">            right_(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="built_in">min</span>(dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">0</span>]);        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="POJ2533-Longest-Ordered-Subsequence"><a href="#POJ2533-Longest-Ordered-Subsequence" class="headerlink" title="POJ2533 Longest Ordered Subsequence"></a><a href="https://cn.vjudge.net/problem/POJ-2533" rel="external nofollow noopener noreferrer" target="_blank">POJ2533 Longest Ordered Subsequence</a></h4><p>题如其名，直接转移即可。注意初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    mst(dp,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    dp[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[i])&#123;</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="POJ3186-Treats-for-the-Cows"><a href="#POJ3186-Treats-for-the-Cows" class="headerlink" title="POJ3186 Treats for the Cows"></a><a href="https://cn.vjudge.net/problem/POJ-3186" rel="external nofollow noopener noreferrer" target="_blank">POJ3186 Treats for the Cows</a></h4><p>题意懒得描述了……</p>
<p>$dp[i][j]$表示的是区间$[i,j]$所能获得的最大价值。</p>
<p>做法是直接转移过去即可。注意初始化和转移顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i],dp[i][i]=arr[i];</span><br><span class="line">    mst(dp,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> age=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j]+arr[i]*(n-j+i),dp[i][j<span class="number">-1</span>]+arr[j]*(n-j+i));</span><br><span class="line">    <span class="keyword">int</span> ans=dp[<span class="number">1</span>][n];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HDU1078-FatMouse-and-the-Cheese"><a href="#HDU1078-FatMouse-and-the-Cheese" class="headerlink" title="HDU1078 FatMouse and the Cheese"></a><a href="https://cn.vjudge.net/problem/HDU-1078" rel="external nofollow noopener noreferrer" target="_blank">HDU1078 FatMouse and the Cheese</a></h4><p>题目大意是说，现在有$n \times n$个网格，这些网格中有若干个网格放有cheese。从网格$(0,0)$出发，每次走到下一个放有cheese的地方，可以水平走、垂直走，可以回头，每次最多走$k$步；同时，每一次获得的cheese都应该比上一次多，问最终最多能得到多少cheese。</p>
<p>一开始想着状态要怎么转移，感觉这题的规则挺多，不太好转移……然而实际上只需要记忆化+爆搜+简单dp即可。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[x][y])    <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tx=<span class="number">0</span>;<span class="keyword">int</span> ty=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            tx=x+j*dir[i][<span class="number">0</span>];</span><br><span class="line">            ty=y+j*dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tx&lt;n&amp;&amp;<span class="number">0</span>&lt;=tx&amp;&amp;ty&lt;n&amp;&amp;<span class="number">0</span>&lt;=ty)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[tx][ty]&gt;mp[x][y])</span><br><span class="line">                    sum=<span class="built_in">max</span>(sum,dfs(tx,ty));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x][y]=sum+mp[x][y];</span><br><span class="line">    <span class="keyword">return</span> dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&amp;&amp;n!=<span class="number">-1</span>&amp;&amp;k!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;mp[i][j];</span><br><span class="line">        mst(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dfs(<span class="number">0</span>,<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HDU2859-Phalanx"><a href="#HDU2859-Phalanx" class="headerlink" title="HDU2859 Phalanx"></a><a href="https://cn.vjudge.net/problem/HDU-2859" rel="external nofollow noopener noreferrer" target="_blank">HDU2859 Phalanx</a></h4><p>题目大意是说，从一个矩阵中找出一个关于自身右对角线（从右上到左下）对称的子矩阵，问能找到的符合要求的最大子矩阵的大小是多少。</p>
<p>$dp[i][j]$表示如果$(i,j)$处的元素是某个子矩阵的左下角，那么对应的子矩阵的大小是多少。</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> str;<span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                mp[i][j]=str[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mst(dp,<span class="number">0</span>);<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x=i<span class="number">-1</span>;<span class="keyword">int</span> y=j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(x&gt;=<span class="number">0</span>&amp;&amp;y&lt;n)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mp[x][j]!=mp[i][y])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    x--;y++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sz=y-j;</span><br><span class="line">                <span class="keyword">if</span>(sz&gt;dp[i<span class="number">-1</span>][j+<span class="number">1</span>])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=sz; </span><br><span class="line">                ans=<span class="built_in">max</span>(ans,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="POJ3616-Miking-Time"><a href="#POJ3616-Miking-Time" class="headerlink" title="POJ3616 Miking Time"></a><a href="https://cn.vjudge.net/problem/POJ-3616" rel="external nofollow noopener noreferrer" target="_blank">POJ3616 Miking Time</a></h4><p>将每一个时间段的结束时间加上休息时间，即可用最大上升子序列和的思路来做。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,e,eff;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; nn)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s!=nn.s)    <span class="keyword">return</span> s&lt;nn.s;</span><br><span class="line">        <span class="keyword">return</span> e&lt;nn.e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node ns[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n,m,r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ns[i].s&gt;&gt;ns[i].e&gt;&gt;ns[i].eff;</span><br><span class="line">        ns[i].e+=r;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ns+<span class="number">1</span>,ns+<span class="number">1</span>+m);</span><br><span class="line">    mst(dp,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        dp[i]=ns[i].eff;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ns[j].e&lt;=ns[i].s)&#123;</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[j]+ns[i].eff,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="POJ3666-Making-the-Grade"><a href="#POJ3666-Making-the-Grade" class="headerlink" title="POJ3666 Making the Grade"></a><a href="https://cn.vjudge.net/problem/POJ-3666" rel="external nofollow noopener noreferrer" target="_blank">POJ3666 Making the Grade</a></h4><p>题目大意是说，对于一个给定的序列，现在要把它变成递增的或递减的，每改动一个数要付出的代价为改动后的数与改动前的数的差的绝对值。问如何改动才能使得代价最小。</p>
<p>首先，这题的数据有点问题，只需要考虑递增的情况……</p>
<p>这题的状态转移也不太好想，甚至感觉有点……神奇。具体见代码及代码注释</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs_</span><span class="params">(<span class="keyword">int</span> todo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(todo&lt;<span class="number">0</span>)    <span class="keyword">return</span> -todo;</span><br><span class="line">    <span class="keyword">return</span> todo;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> arr[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> b[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dp[maxn&lt;&lt;<span class="number">1</span>][maxn&lt;&lt;<span class="number">1</span>];        <span class="comment">//dp[i][j]表示前i个数,最后一个数在arr[]中第j小 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        b[i]=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);        <span class="comment">//? 为什么要排序?为什么不排序就会不行? </span></span><br><span class="line">    <span class="comment">//如果排序是为了去重，那去重的意义是什么?以及，为什么我不去重也能过? </span></span><br><span class="line">    mst(dp,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            tmp=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],tmp);        </span><br><span class="line">            <span class="comment">//k:[1,j],这一层循环可以省掉,维护一个最小值即可 </span></span><br><span class="line">            <span class="comment">//可以保证tmp一定是范围[1,j]内最小的 </span></span><br><span class="line">            dp[i][j]=abs_(arr[i]-b[j])+tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,dp[n][i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>基础DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>DP</tag>
        <tag>基础DP</tag>
      </tags>
  </entry>
  <entry>
    <title>快速读入模板</title>
    <url>/2019/02/18/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>代码如下👇</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'-'</span>)        sign=<span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(ch&gt;<span class="string">'9'</span>||ch&lt;<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>);</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x*sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read_Tp</span><span class="params">(T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ch=getchar();</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'-'</span>)        sign=<span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(ch&gt;<span class="string">'9'</span>||ch&lt;<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>);</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a=read_Tp(a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展欧几里得算法</title>
    <url>/2019/02/01/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="普通的欧几里得算法"><a href="#普通的欧几里得算法" class="headerlink" title="普通的欧几里得算法"></a>普通的欧几里得算法</h4><p>&emsp;&emsp;这大概是最为人熟知的数论算法了吧，作用是求出gcd(a,b)，代码如下:<br><a id="more"></a><br>递归版本:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>循环版本:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=a%b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;另外，求最大公约数还可以用库函数__gcd(),这是GNU里的库函数，不是标准库函数，头文件为 &lt; algorithm &gt;</p>
<h4 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h4><p>&emsp;&emsp;而拓展欧几里得算法则是在算出a,b的最大公约数的同时，顺带计算贝祖公式的一组解，即ax+by=gcd(a,b)的解( <a href="https://baike.baidu.com/item/%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86/5185441?fr=aladdin" rel="external nofollow noopener noreferrer" target="_blank">贝祖等式</a> )</p>
<p>&emsp;&emsp;那么，如果要手算ax+by=gcd(a,b)，我们要怎么算呢?</p>
<p>&emsp;&emsp;首先，因为gcd(a,b)=gcd(b,a%b),</p>
<p>&emsp;&emsp;所以a x + b y = gcd ( a,b ) = gcd ( b,a%b )= c x’ + d y’ ( 其中，c = b，d = a % b )</p>
<p>&emsp;&emsp;又因为a % b = a - (a/b) * b</p>
<p>&emsp;&emsp;所以有a y’ + b ( x’ - (a/b) * y) = a x + b y</p>
<p>&emsp;&emsp;比较两式，可得x = y’ , y = x’ - ( a / b ) * y’</p>
<p>&emsp;&emsp;又因为当b = 0时，解为x = 1 , y = 0，所以只要递归求解至b = 0即可</p>
<p>代码如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>&amp; x,<span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> tmp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=tmp-(a/b)*y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种写法为:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>&amp; x,<span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;    </span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r=exgcd(b,a%b,y,x);</span><br><span class="line">        y-=x*(a/b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;拓展欧几里得的一个作用，是求出满足形如ax+by=c的方程的解。根据贝祖等式可以看出，若c % gcd( a,b ) != 0，则方程无解。代码如下:<br><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">ll solve(ll a,ll b,ll b)</span><br><span class="line">&#123;</span><br><span class="line">    ll <span class="symbol">x</span>,<span class="symbol">y</span>;</span><br><span class="line">    ll g=exgcd(a,b,<span class="symbol">x</span>,<span class="symbol">y</span>);</span><br><span class="line">    <span class="keyword">if</span>(c%g)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="symbol">x</span>*=c/gcd;</span><br><span class="line">    b/=gcd;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>)</span><br><span class="line">        b=-b;        <span class="comment">//如果b &lt; 0，就取其绝对值</span></span><br><span class="line">    ll ans=<span class="symbol">x</span>%b;        <span class="comment">//如果求出的解小于0，就将其加上b</span></span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=<span class="number">0</span>)</span><br><span class="line">        ans+=b;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个算法的另一个作用是求最小逆元。根据a x = 1 ( mod p) ==&gt; ax = py + 1 ==&gt; ax + by = 1，不难看出，求最小逆元其实就是求ax + by = c的解的特殊情况。因此，利用拓展欧几里得求最小逆元的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> g=exgcd(a,bx,y);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>%gcd)        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    x*=<span class="number">1</span>/g;</span><br><span class="line">    b=<span class="built_in">abs</span>(b);        <span class="comment">//假如b是一个负数，就取b的绝对值</span></span><br><span class="line">    <span class="keyword">int</span> ans=x%b;    <span class="comment">//假如求得的解不是正数，就将解对b取模再加上b</span></span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=<span class="number">0</span>)        </span><br><span class="line">        ans+=b;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一道求ax + by = c 的模板题：<br><a href="https://cn.vjudge.net/problem/POJ-1061" rel="external nofollow noopener noreferrer" target="_blank">青蛙约会</a></p>
<p>我的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll&amp; d,ll&amp; x,ll&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        d=a;x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        exgcd(b,a%b,d,y,x);</span><br><span class="line">        y-=(a/b)*x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll a,ll b,ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x;ll y;ll g;</span><br><span class="line">    exgcd(a,b,g,x,y);</span><br><span class="line">    <span class="keyword">if</span>(c%g)        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    x=(x*c)/g;</span><br><span class="line">    b/=g;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>)        b=-b;</span><br><span class="line">    ll ans=x%b;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=<span class="number">0</span>)        ans+=b;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y,m,n,L;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld %lld %lld"</span>,&amp;x,&amp;y,&amp;m,&amp;n,&amp;L);</span><br><span class="line">    ll ans=solve(n-m,L,x-y);</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>为什么求ax + by = c的代码可以这样写呢？我也不知道啊OTZ(发出了数学太差的声音)</del></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>最大流，最大流最小割与最大权闭合子图</title>
    <url>/2019/10/10/%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%8C%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H5f34d005235d4ae08a65080af36eb1b35.jpg" alt><br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很久之前学过最大流，但当时网络流的学习便止步于此。国庆时做了几套去年ICPC Regional的题目，有好几道网络流相关的题目，遂决定复习一下最大流，同时学点新东西</p>
<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><p>解决最大流问题主要有FF，EK，Dinic，ISAP这四种算法。FF和EK在时间复杂度上较劣，不适合用来解题，故大多数情况使用的都是Dinic和ISAP。而这两种算法相比较，虽然ISAP会比Dinic更快一点，但由于网络流相关的题目重点往往不在算法实现，而在于如何对问题建模。再加上Dinic的思路比ISAP更简明，实现也很简单，故实际解题时，Dinic使用得更多一些。</p>
<h4 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h4><h5 id="该算法的大致步骤如下："><a href="#该算法的大致步骤如下：" class="headerlink" title="该算法的大致步骤如下："></a>该算法的大致步骤如下：</h5><ol>
<li>连边，建立网络</li>
<li>BFS建立分层图</li>
<li>判断分层后汇点所处层次是否为-1。若是，说明此时汇点已不可达，直接输出答案；否则，进行下一步</li>
<li>一边DFS完成所有增广。对于网络中的每一条边，都加上当前的最小残量，同时对于每一条边的反向边，都减去当前的最小残量，并将答案加上该最小残量。</li>
<li>返回步骤2</li>
</ol>
<p>该算法的最坏时间复杂度为：$O(n^2 m)$，但大多数情况下都是挺快的</p>
<h5 id="当前弧优化"><a href="#当前弧优化" class="headerlink" title="当前弧优化"></a>当前弧优化</h5><p>每一次在做dfs时，对于一个点，有可能有一些边在之前已经计算过了，那我们在遍历这个点的边的时候，就没必要再计算那些已经计算过的边。因此，我们可以用一个cur[]数组记录某个点已经计算到了那条边。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dep[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cur[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;<span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> wei;</span><br><span class="line">&#125;;</span><br><span class="line">edge es[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;mst(head,<span class="number">-1</span>);</span><br><span class="line">    mst(dep,<span class="number">-1</span>);mst(cur,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    es[cnt].to=v;</span><br><span class="line">    es[cnt].wei=wei;</span><br><span class="line">    es[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(u,v,wei);</span><br><span class="line">    add(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    mst(dep,<span class="number">-1</span>);dep[s]=<span class="number">0</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=es[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(es[i].wei&gt;<span class="number">0</span>&amp;&amp;dep[es[i].to]==<span class="number">-1</span>)&#123;</span><br><span class="line">                dep[es[i].to]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                que.push(es[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> mini)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==t) <span class="keyword">return</span> mini;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[s];i!=<span class="number">-1</span>;i=es[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(es[i].wei&gt;<span class="number">0</span>&amp;&amp;dep[es[i].to]==dep[s]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> d=dfs(es[i].to,t,<span class="built_in">min</span>(es[i].wei,mini));</span><br><span class="line">            <span class="keyword">if</span>(d&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                es[i].wei-=d;</span><br><span class="line">                es[i^<span class="number">1</span>].wei+=d;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) cur[i]=head[i];</span><br><span class="line">        <span class="keyword">while</span>((tmp=dfs(s,t,INF))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans+=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,s,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        add_edge(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=Dinic(s,t,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="验板子"><a href="#验板子" class="headerlink" title="验板子"></a>验板子</h5><p><a href="https://www.luogu.org/problem/P3376" rel="external nofollow noopener noreferrer" target="_blank">P3376 【模板】网络最大流</a></p>
<h3 id="最大流最小割"><a href="#最大流最小割" class="headerlink" title="最大流最小割"></a>最大流最小割</h3><h4 id="什么是割-什么是最小割？"><a href="#什么是割-什么是最小割？" class="headerlink" title="什么是割?什么是最小割？"></a>什么是割?什么是最小割？</h4><p>所谓的割，指的是对于一个网络上的一个边集，如果从网络上将该边集中的边都删去后，不存在一条从源点到汇点的路，则该边集称为割。最小割指的就是边权和最小的割</p>
<h4 id="一个结论"><a href="#一个结论" class="headerlink" title="一个结论"></a>一个结论</h4><center><strong>最小割&emsp;==&emsp;最大流</strong></center>



<p>我是这么理解这个结论的：因为割的意思是指拿掉割里面的边以后，就不能找到一条从源点到汇点的路了，也就是说割将网络的两个部分连接起来，拿掉之后网络就分成了两个部分。那我们是否可以将割集中的边合并成一条边呢？这样去理解的话就可以很容易得出这样一个结论：在满足最大流的情况下，这一条边的流量就是等于最大流。而又因为流量不能超过容量，故在满足最大流的情况下，任意一个割的容量和都是大于等于最大流的。在这个基础上，我们不断地去找容量和更小的割，最终一定能够找到一个割，他们的容量和等于最大流。为什么一定能找到呢？因为最大流意味着满流，意味着我们已经无法继续增广了。</p>
<h4 id="来道例题"><a href="#来道例题" class="headerlink" title="来道例题"></a>来道例题</h4><p><a href="https://www.luogu.org/problem/P2774" rel="external nofollow noopener noreferrer" target="_blank">P2774 方格取数</a></p>
<p>第一反应是贪心，隔一个数取一个什么的。但很容易就能举出反例。正确的做法是按照$(i+j)$（$i,j$分别是行数和列数）的奇偶来连边构建一个二分图。对于一个方格，如果其所在行加上所在列<script type="math/tex">row_{cur} + col_{cur}</script>为奇数，则将其与超级源点连一条容量为1的边；如果为偶数，则将其与超级汇点连一条容量为1的边。最后，对于左侧的奇数点，将它们与所有<strong>不符合限制的不能取的</strong>偶数点，即与它们相邻的那些点各连一条容量为INF的边。最后算一遍最小割，将所有方格的数的总和减去最小割即为答案。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug puts(<span class="meta-string">"debug"</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dep[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cur[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;<span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> wei;</span><br><span class="line">&#125;;</span><br><span class="line">edge es[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;mst(head,<span class="number">-1</span>);</span><br><span class="line">    mst(dep,<span class="number">-1</span>);mst(cur,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    es[cnt].to=v;</span><br><span class="line">    es[cnt].wei=wei;</span><br><span class="line">    es[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(u,v,wei);</span><br><span class="line">    add(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    mst(dep,<span class="number">-1</span>);dep[s]=<span class="number">0</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=es[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(es[i].wei&gt;<span class="number">0</span>&amp;&amp;dep[es[i].to]==<span class="number">-1</span>)&#123;</span><br><span class="line">                dep[es[i].to]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                que.push(es[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> mini)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==t) <span class="keyword">return</span> mini;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[s];i!=<span class="number">-1</span>;i=es[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(es[i].wei&gt;<span class="number">0</span>&amp;&amp;dep[es[i].to]==dep[s]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> d=dfs(es[i].to,t,<span class="built_in">min</span>(es[i].wei,mini));</span><br><span class="line">            <span class="keyword">if</span>(d&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                es[i].wei-=d;</span><br><span class="line">                es[i^<span class="number">1</span>].wei+=d;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) cur[i]=head[i];</span><br><span class="line">        <span class="keyword">while</span>((tmp=dfs(s,t,INF))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans+=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;mp[i][j]);</span><br><span class="line">            sum+=mp[i][j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cntt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++,cntt++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i+j)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                add_edge(<span class="number">0</span>,cntt,mp[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(j&lt;m) </span><br><span class="line">                    add_edge(cntt,cntt+<span class="number">1</span>,INF);</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">1</span>) </span><br><span class="line">                    add_edge(cntt,cntt<span class="number">-1</span>,INF);</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">1</span>) </span><br><span class="line">                    add_edge(cntt,cntt-m,INF);</span><br><span class="line">                <span class="keyword">if</span>(i&lt;n) </span><br><span class="line">                    add_edge(cntt,cntt+m,INF);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                add_edge(cntt,n*m+<span class="number">1</span>,mp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    debug;</span></span><br><span class="line">    <span class="keyword">int</span> ans=Dinic(<span class="number">0</span>,n*m+<span class="number">1</span>,n*m*<span class="number">2</span>);</span><br><span class="line">    ans=sum-ans;    <span class="comment">//总和减去最小割</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这道题中我们可以看出，最小割可以解决这样的一类问题，在满足某些限制的情况下，计算可以获得的最大价值。在这种情况下，我们可以先假设所有价值都可取，然后将那些不满足情况的作为割删去，那么求最小割就等价于求最小损失。</p>
<h3 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h3><h4 id="什么是最大权闭合子图？"><a href="#什么是最大权闭合子图？" class="headerlink" title="什么是最大权闭合子图？"></a>什么是最大权闭合子图？</h4><p>首先，闭合子图指的是对于一个图，我们从中选出一个子图，它的任意一个点的出度指向的点仍然在这个子图内。而最大权闭合子图指的就是所有闭合子图中点权和最大的那一个。</p>
<h4 id="如何求最大权闭合子图？"><a href="#如何求最大权闭合子图？" class="headerlink" title="如何求最大权闭合子图？"></a>如何求最大权闭合子图？</h4><p>有一个结论，对于一个图，满足</p>
<center><strong>最大权闭合子图权值=所有权值为正的权值总和-最大流</strong></center>

<p>证明不会……</p>
<p>如何得到这样的一个图呢？</p>
<ol>
<li>抽象出一个超级源点和一个超级汇点</li>
<li>将权值为正的点与源点连边，容量分别为各点点权</li>
<li>将权值为负的点与汇点连边，容量分别为各点点权的绝对值</li>
<li>权值为0的点不做处理</li>
<li>将除了源点和汇点之外的边按照题目中的关系连边，容量为INF</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dep[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cur[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;<span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> wei;</span><br><span class="line">&#125;;</span><br><span class="line">edge es[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;mst(head,<span class="number">-1</span>);</span><br><span class="line">    mst(dep,<span class="number">-1</span>);mst(cur,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    es[cnt].to=v;</span><br><span class="line">    es[cnt].wei=wei;</span><br><span class="line">    es[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(u,v,wei);</span><br><span class="line">    add(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    mst(dep,<span class="number">-1</span>);dep[s]=<span class="number">0</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=es[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(es[i].wei&gt;<span class="number">0</span>&amp;&amp;dep[es[i].to]==<span class="number">-1</span>)&#123;</span><br><span class="line">                dep[es[i].to]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                que.push(es[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> mini)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==t) <span class="keyword">return</span> mini;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[s];i!=<span class="number">-1</span>;i=es[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(es[i].wei&gt;<span class="number">0</span>&amp;&amp;dep[es[i].to]==dep[s]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> d=dfs(es[i].to,t,<span class="built_in">min</span>(es[i].wei,mini));</span><br><span class="line">            <span class="keyword">if</span>(d&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                es[i].wei-=d;</span><br><span class="line">                es[i^<span class="number">1</span>].wei+=d;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) cur[i]=head[i];</span><br><span class="line">        <span class="keyword">while</span>((tmp=dfs(s,t,INF))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans+=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[maxn&lt;&lt;<span class="number">1</span>],b[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);        <span class="comment">//学生 </span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;        <span class="comment">//活动 </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">int</span> k;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line">            add_edge(i,v+n,INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add_edge(<span class="number">0</span>,i,a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) add_edge(i+n,n+m+<span class="number">1</span>,b[i]);</span><br><span class="line">    <span class="keyword">int</span> ans=Dinic(<span class="number">0</span>,n+m+<span class="number">1</span>,n+m+<span class="number">3</span>);</span><br><span class="line">    ans=sum-ans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测一下板子"><a href="#测一下板子" class="headerlink" title="测一下板子"></a>测一下板子</h4><p><a href="https://vjudge.net/problem/HihoCoder-1398" rel="external nofollow noopener noreferrer" target="_blank">网络流五·最大权闭合子图</a></p>
<h3 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h3><ul>
<li><a href="https://www.cnblogs.com/songorz/p/9642840.html" rel="external nofollow noopener noreferrer" target="_blank">最大权闭合子图</a></li>
<li><a href="https://blog.csdn.net/qq_41357771/article/details/79416899" rel="external nofollow noopener noreferrer" target="_blank">网络流【最大流&amp;&amp;最小割&amp;&amp;费用流】——一篇简单易懂的博文</a></li>
<li><a href="https://www.cnblogs.com/linzhengmin/p/9313216.html" rel="external nofollow noopener noreferrer" target="_blank">[算法]网络最大流Dinic<br>前言</a></li>
</ul>
]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>最大流最小割</tag>
        <tag>最大权闭合子图</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉路、欧拉回路与Fleury算法</title>
    <url>/2019/02/27/%E6%AC%A7%E6%8B%89%E8%B7%AF%E3%80%81%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E4%B8%8EFleury%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="一、概念解释"><a href="#一、概念解释" class="headerlink" title="一、概念解释"></a>一、概念解释</h4><ul>
<li><p>欧拉路：给定无孤立结点图G，若存在一条路，经过图中每边一次且仅一次，该条路称为欧拉路。</p>
</li>
<li><p>欧拉路的存在条件：没有孤立结点，同时奇数度数的点只有2个或0个。</p>
</li>
<li><p>欧拉回路：若一个连通图中没有奇数度数的点，则该图中一定存在一条起点与终点重合的欧拉路，称为欧拉回路。</p>
</li>
</ul>
<p>&emsp;&emsp;通俗地讲，欧拉路就是一笔画游戏，每条边只能走一次，问怎么画才能把所有边都画出来。欧拉回路就是在此基础上，不仅要把所有边都画出来，还要求起点和终点要是同一个地方。</p>
<h4 id="二、判断欧拉路是否存在"><a href="#二、判断欧拉路是否存在" class="headerlink" title="二、判断欧拉路是否存在"></a>二、判断欧拉路是否存在</h4><p>&emsp;&emsp;要判断欧拉路是否存在，只需要判断奇数度数的个数即可。一般使用并查集来实现。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断欧拉路是否存在</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">int</span> deg[maxn];</span><br><span class="line"><span class="keyword">bool</span> root[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)</span><br><span class="line">        pre[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> pre[x]=findr(pre[x]);;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mix</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=findr(x);</span><br><span class="line">    <span class="keyword">int</span> fy=findr(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">        pre[fy]=fx;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    mst(deg,<span class="number">0</span>);mst(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        mix(a,b);</span><br><span class="line">        deg[a]++;deg[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">0</span>;<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(deg[i]&amp;<span class="number">1</span>)</span><br><span class="line">            d++;        <span class="comment">//奇数度数节点计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        root[findr(i)]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(root[i])        <span class="comment">//判断是否有孤立节点</span></span><br><span class="line">            cnt++;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>&amp;&amp;(d==<span class="number">0</span>||d==<span class="number">2</span>))</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"OK"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三、Fleury算法求欧拉回路"><a href="#三、Fleury算法求欧拉回路" class="headerlink" title="三、Fleury算法求欧拉回路"></a>三、Fleury算法求欧拉回路</h4><p>&emsp;&emsp;要求欧拉回路，一般使用Fleury算法。这个算法的过程可以这样描述：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、在原图中找一个任意路径L1(不需要是欧拉路)，并按照L1的顺序将L1上的点压入一个栈中</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、从L1的终点往回回溯，依次将每个点出栈。并检查当前点是否还有其他没有经过的边。若存在则以当前点为起点，查找L2，并对L2的节点同样用栈记录重复该算法。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、当L1中的点全部出栈后，算法结束。</span><br></pre></td></tr></table></figure>
<p>(参考<a href="https://cn.vjudge.net/problem/HihoCoder-1181" rel="external nofollow noopener noreferrer" target="_blank">欧拉路·二</a>)</p>
<p>具体代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> gra[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> deg[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> path[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">int</span> x=g[u][i];</span><br><span class="line">        <span class="keyword">if</span>(gra[u][x])&#123;</span><br><span class="line">            gra[u][x]--;</span><br><span class="line">            gra[x][u]--;</span><br><span class="line">            dfs(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path[<span class="built_in">size</span>++]=u;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    mst(path,<span class="number">0</span>);<span class="built_in">size</span>=<span class="number">0</span>;</span><br><span class="line">    mst(gra,<span class="number">0</span>);mst(deg,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        gra[u][v]++;gra[v][u]++;</span><br><span class="line">        deg[u]++;deg[v]++;</span><br><span class="line">        g[u].push_back(v);g[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">0</span>;<span class="keyword">int</span> st=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(deg[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            d++;</span><br><span class="line">            st=i;</span><br><span class="line">        &#125;</span><br><span class="line">    dfs(st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;path[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;path[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>欧拉路与欧拉回路</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>欧拉路与欧拉回路</tag>
        <tag>Fleury</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1417 烹调方案</title>
    <url>/2019/02/19/%E6%B4%9B%E8%B0%B7P1417-%E7%83%B9%E8%B0%83%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1417" rel="external nofollow noopener noreferrer" target="_blank">P1417 烹调方案</a></p>
<p>&emsp;&emsp;依然是01背包。这道题跟之前HDU的那道merchant很像，都是要先算一个不等式，再根据这个不等式进行排序，然后再进行01背包。具体而言，是要解下面这个不等式：</p>
<p>&emsp;a1 - (t0 + c1) x b1 + a2 - (t0 + c1 + c2) x b2 &gt; a2 - (t0 + c2) x b2 +a1 - (t0 + c1 + c2) x b1</p>
<p>==&gt;&emsp;&emsp;&emsp;b2 c1 &lt; b1 c2</p>
<p>具体代码如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">food</span>&#123;</span></span><br><span class="line">    ll a,b,c;</span><br><span class="line">&#125;;</span><br><span class="line">food arr[<span class="number">55</span>];</span><br><span class="line">ll dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(food fa,food fb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fb.b)*(fa.c)&lt;(fa.b)*(fb.c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t,n;</span><br><span class="line">    mst(dp,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)        <span class="built_in">cin</span>&gt;&gt;arr[i].a;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)        <span class="built_in">cin</span>&gt;&gt;arr[i].b;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)        <span class="built_in">cin</span>&gt;&gt;arr[i].c;</span><br><span class="line">    sort(arr,arr+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=t;j&gt;=arr[i].c;j--)&#123;</span><br><span class="line">            ll val=(arr[i].a)-(arr[i].b)*j;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-arr[i].c]+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=t;j++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[j]);</span><br><span class="line"><span class="comment">//    ans=dp[t];</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1855 榨取kkksc03</title>
    <url>/2019/02/19/%E6%B4%9B%E8%B0%B7P1855-%E6%A6%A8%E5%8F%96kkksc03/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1855" rel="external nofollow noopener noreferrer" target="_blank">P1855 榨取kkksc03</a></p>
<p>&emsp;&emsp;一道01背包模板题，但多了一个维度。</p>
<a id="more"></a>
<p>代码如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">205</span>],t[<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">205</span>],t[<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,M,T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;M&gt;&gt;T;</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">    <span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="keyword">sizeof</span>(t));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m[i]&gt;&gt;t[i];</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=M;i&gt;=m[k];i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=T;j&gt;=t[k];j--)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-m[k]][j-t[k]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[M][T]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2018/12/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>这是我的第一篇博客<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello,world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>hexo-test</category>
      </categories>
  </entry>
  <entry>
    <title>用手势操控你的电脑——基于Opencv.js，Tensorflow，electron的手势人机交互</title>
    <url>/2020/07/04/%E7%94%A8%E6%89%8B%E5%8A%BF%E6%93%8D%E6%8E%A7%E4%BD%A0%E7%9A%84%E7%94%B5%E8%84%91%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EOpencv-js%EF%BC%8CTensorflow%EF%BC%8Celectron%E7%9A%84%E6%89%8B%E5%8A%BF%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p><img src="https://pic.downk.cc/item/5f00278014195aa594787856.png" alt><br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨晚看了以下许久没有访问的博客，发现最近一篇博客居然是今年3月份的一份AGC题解。还记得大一的时候，写博客的热情高涨，恨不得日更三篇；上了大二之后，一方面是各方面的压力变大了，另一方面是自己在这方面越来越懒，<del>于是出现了四个月没写过一篇文章的情况</del>。这学期上多媒体课程，期末大作业和刘总一起做了一个基于手势识别的人机交互小程序，就拿来<del>水一水</del>吧</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>看标题就知道，这是一个通过识别手势来完成一些电脑操作的东西。因为是一个桌面应用，同时为了界面好看（好看是第一生产力.jpg），我们选择了electron。首先是用python+Tensorflow训练一个CNN用于手势识别，并导出该模型为json格式；然后，我们在electron中使用opencv.js处理图像，并把上一步训练得到的json格式模型导入到Tensorflow.js中做手势识别；最后，借助robot.js来实现操控电脑。</p>
<p>放一下结构图</p>
<p><img src="https://pic.downk.cc/item/5f00239914195aa594769dc9.jpg"></p>
<p>之所以要分离出前端和服务端，是因为robot.js要塞进electron里面比较麻烦，尝试了好几次之后都没有成功，于是索性不把他放到electron里面。这样一来，避免了配置上的麻烦，而且结构更清晰，代码写起来也更方便。</p>
<p>目前仅支持在windows上使用，可以完成的操作有：</p>
<ul>
<li>切换窗口</li>
<li>隐藏窗口</li>
<li>静音/恢复音量</li>
<li>关闭当前窗口</li>
<li>上、下、左、右四个方向键</li>
</ul>
<h3 id="模型搭建"><a href="#模型搭建" class="headerlink" title="模型搭建"></a>模型搭建</h3><p>这一步主要就是采集训练样本，然后使用Opencv处理图像，最后扔进Tensorflow里训练。</p>
<p>先说一下采集训练样本以及处理图像这两部分。通过Opencv调用摄像头，每0.1秒截取一次图像，然后用Opencv处理这一图像。所做的处理包括：</p>
<ul>
<li><p>获取ROI（感兴趣区域）</p>
<p>其实就是从原图像上截取一个指定区域。</p>
<p><center><img src="https://pic.downk.cc/item/5f00061014195aa5946a4677.png" style="zoom:50%;"></center><br><center>处理前</center><br><center><img src="https://pic.downk.cc/item/5f00064814195aa5946a5c36.png" style="zoom: 67%;"></center><br><center>处理后</center><br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRoi</span><span class="params">(frame, x0, y0, width, height)</span>:</span></span><br><span class="line">    roi = frame[y0:y0 + height, x0:x0 + width]</span><br><span class="line">    cv.imshow(<span class="string">'roi'</span>, roi)</span><br><span class="line">    <span class="keyword">return</span> roi</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>使用Otsu法（大津法）进行肤色检测</p>
<p>大致原理是通过遮罩的方法，计算按位与运算，从而过滤掉那些我们不关心的像素。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSkin</span><span class="params">(frame)</span>:</span></span><br><span class="line">    ycrcb = cv.cvtColor(frame, cv.COLOR_BGR2YCR_CB)</span><br><span class="line">    y, cr, cb = cv.split(ycrcb)</span><br><span class="line">    cr_ = cv.GaussianBlur(cr, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>) <span class="comment"># 高斯模糊</span></span><br><span class="line">   _, skin = cv.threshold(cr_, <span class="number">0</span>, <span class="number">255</span>, cv.THRESH_BINARY | cv.THRESH_OTSU) <span class="comment"># otsu二值化 </span></span><br><span class="line">    ret = cv.bitwise_and(frame, frame, mask=skin)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<center><img src="https://pic.downk.cc/item/5f00064814195aa5946a5c36.png" style="zoom:50%;"></center>
<center>处理前</center>
<center><img src="https://pic.downk.cc/item/5f000a5c14195aa5946bfd10.png" style="zoom:50%;"></center>
<center>处理后</center>
</li>
<li><p>提取轮廓并计算傅里叶算子</p>
<p>提取轮廓可以用opencv中的findContour。计算傅里叶算子可以理解为提取特征。</p>
<center><img src="https://pic.downk.cc/item/5f000a5c14195aa5946bfd10.png" style="zoom:50%;"></center>
<center>处理前</center>
 <center><img src="https://pic.downk.cc/item/5f000ad514195aa5946c30ba.png" style="zoom:50%;"></center>

<center>处理后</center>

<p>代码如下：</p>
<p>提取轮廓</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findContour</span><span class="params">(Laplacian)</span>:</span></span><br><span class="line">    h = cv.findContours(Laplacian, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_NONE)</span><br><span class="line">    contour = h[<span class="number">0</span>]</span><br><span class="line">    contour = sorted(contour, key=cv.contourArea, reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> contour</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  计算傅里叶算子：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trucate</span><span class="params">(des)</span>:</span></span><br><span class="line">    ret = np.fft.fftshift(des)</span><br><span class="line">    centerIdx = int(len(ret) / <span class="number">2</span>)</span><br><span class="line">    low, high = centerIdx - int(MIN_DESCRIPTOR / <span class="number">2</span>), centerIdx + int(MIN_DESCRIPTOR / <span class="number">2</span>)</span><br><span class="line">    ret = ret[low:high]</span><br><span class="line">    ret = np.fft.ifftshift(ret)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourier</span><span class="params">(frame)</span>:</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    dst = cv.Laplacian(gray, cv.CV_16S, ksize=<span class="number">3</span>)</span><br><span class="line">    Laplacian = cv.convertScaleAbs(dst)</span><br><span class="line">    contour = findContour(Laplacian)</span><br><span class="line">    contourArray = contour[<span class="number">0</span>][:, <span class="number">0</span>, :]</span><br><span class="line">    retbg = np.ones(dst.shape, np.uint8)</span><br><span class="line">    ret = cv.drawContours(retbg, contour[<span class="number">0</span>], <span class="number">-1</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line">    contourComplex = np.empty(contourArray.shape[:<span class="number">-1</span>], dtype=complex)</span><br><span class="line">    contourComplex.real = contourArray[:, <span class="number">0</span>]</span><br><span class="line">    contourComplex.imag = contourArray[:, <span class="number">1</span>]</span><br><span class="line">    fourierResult = np.fft.fft(contourComplex)</span><br><span class="line">    desInUse = trucate(fourierResult)</span><br><span class="line">    <span class="keyword">return</span> ret, desInUse</span><br></pre></td></tr></table></figure>
<p>  根据傅里叶算子重构：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reconstruct</span><span class="params">(img, desInUse)</span>:</span></span><br><span class="line">    contour_reconstruct = np.fft.ifft(descirptor_in_use)</span><br><span class="line">    contour_reconstruct = np.array([contour_reconstruct.real, contour_reconstruct.imag])</span><br><span class="line">    contour_reconstruct = np.transpose(contour_reconstruct)</span><br><span class="line">    contour_reconstruct = np.expand_dims(contour_reconstruct, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> contour_reconstruct.min() &lt; <span class="number">0</span>:</span><br><span class="line">        contour_reconstruct -= contour_reconstruct.min()</span><br><span class="line">    contour_reconstruct *= img.shape[<span class="number">0</span>] / contour_reconstruct.max()</span><br><span class="line">    contour_reconstruct = contour_reconstruct.astype(np.int32, copy=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    black_np = np.ones(img.shape, np.uint8)  <span class="comment"># 创建黑色幕布</span></span><br><span class="line">    black = cv2.drawContours(black_np, contour_reconstruct, <span class="number">-1</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">1</span>)  <span class="comment"># 绘制白色轮廓</span></span><br><span class="line">    cv2.imshow(<span class="string">'contour_reconstruct'</span>, black)</span><br><span class="line">    <span class="keyword">return</span> black</span><br></pre></td></tr></table></figure>
<p>完成上面这些步骤后，就可以得到原始的训练样本了。</p>
<p>接着还要处理得到测试集与训练集。这里做的事情包括:</p>
<ul>
<li><p>改变原始图片尺寸</p>
<p>将尺寸从$300\times 300$改成$128\times 128$。</p>
</li>
<li><p>归一化</p>
<p>将图片中每个像素的值除以255。</p>
</li>
<li><p>划分测试集与训练集</p>
</li>
</ul>
<p>最后搭建CNN并训练了。CNN的结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Layer</th>
<th style="text-align:center">Width</th>
<th style="text-align:center">Height</th>
<th style="text-align:center">Filter</th>
<th style="text-align:center">Kernel Size</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Input</td>
<td style="text-align:center">128</td>
<td style="text-align:center">128</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">Convolution</td>
<td style="text-align:center">128</td>
<td style="text-align:center">128</td>
<td style="text-align:center">32</td>
<td style="text-align:center">3×3</td>
</tr>
<tr>
<td style="text-align:center">Max Pooling</td>
<td style="text-align:center">64</td>
<td style="text-align:center">64</td>
<td style="text-align:center">32</td>
<td style="text-align:center">2×2</td>
</tr>
<tr>
<td style="text-align:center">Convolution</td>
<td style="text-align:center">64</td>
<td style="text-align:center">64</td>
<td style="text-align:center">64</td>
<td style="text-align:center">3×3</td>
</tr>
<tr>
<td style="text-align:center">Max Pooling</td>
<td style="text-align:center">32</td>
<td style="text-align:center">32</td>
<td style="text-align:center">64</td>
<td style="text-align:center">2×2</td>
</tr>
<tr>
<td style="text-align:center">Convolution</td>
<td style="text-align:center">32</td>
<td style="text-align:center">32</td>
<td style="text-align:center">128</td>
<td style="text-align:center">3×3</td>
</tr>
<tr>
<td style="text-align:center">Max Pooling</td>
<td style="text-align:center">16</td>
<td style="text-align:center">16</td>
<td style="text-align:center">128</td>
<td style="text-align:center">2×2</td>
</tr>
<tr>
<td style="text-align:center">Flatten</td>
<td style="text-align:center">32768</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">Dense</td>
<td style="text-align:center">64</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">Dropout</td>
<td style="text-align:center">64</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">Dense</td>
<td style="text-align:center">9</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<p>最终训练结果：</p>
<p><img src="https://pic.downk.cc/item/5f00128a14195aa5946f60ad.jpg" alt></p>
<p>效果还不错（至少目前来说）</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端部分做的事情除了展示界面，还包括以下这些：</p>
<ul>
<li><p>采集手势</p>
<p>调用摄像头并读取图像帧。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMedia</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> constraints = &#123;</span><br><span class="line">    video: &#123;</span><br><span class="line">      width: <span class="number">400</span>, </span><br><span class="line">      height: <span class="number">400</span>, </span><br><span class="line">      facingMode: <span class="string">'user'</span>,</span><br><span class="line">      mirrored: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    audio: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> promise = navigator.mediaDevices.getUserMedia(constraints);</span><br><span class="line">  promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">MediaStream</span>) </span>&#123;</span><br><span class="line">    video.srcObject = MediaStream;</span><br><span class="line">    video.play();</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">PermissionDeniedError</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(PermissionDeniedError);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据处理</p>
<p>  其实就是把在Opencv里的东西在Opencv.js上再实现一遍</p>
</li>
<li><p>模型预测</p>
<p>将处理后的图像帧数据转换为Tensorflow.js输入所对应的格式后，将其输入上述已经训练好的模型中，获得预测值</p>
</li>
<li><p>手势判断与输出</p>
<p>根据模型预测输出的Tensor判断手势类型，且根据“阈值溢出机制”判断是否向服务器发送手势。什么是“阈值溢出机制”呢？实际上就是，单位时间内，如果某个手势的出现频率超过一个阈值$\lambda(&gt;0.5)$，则认为这一手势就是当前手势。</p>
</li>
</ul>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>这一部分通过TCP协议获取前端的手势识别结果，并根据这一结果，通过调用robot.js来完成相应操作。</p>
<p>服务端代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)</span><br><span class="line"><span class="keyword">const</span> robot = <span class="built_in">require</span>(<span class="string">'robotjs'</span>)</span><br><span class="line"><span class="keyword">let</span> controlable = <span class="literal">false</span><span class="comment">//解锁</span></span><br><span class="line"><span class="keyword">let</span> directable = <span class="literal">false</span><span class="comment">//开启上下左右键</span></span><br><span class="line"><span class="keyword">let</span> key_set = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear_key</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; key_set.length; index++) &#123;</span><br><span class="line">    robot.keyToggle(key_set[index], <span class="string">'up'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  key_set = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minimize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'minimize'</span>)</span><br><span class="line">  pre_gesture = <span class="number">7</span>;</span><br><span class="line">  robot.keyToggle(<span class="string">'command'</span>, <span class="string">'down'</span>)</span><br><span class="line">  robot.keyTap(<span class="string">'D'</span>)</span><br><span class="line">  robot.keyToggle(<span class="string">'command'</span>, <span class="string">'up'</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'closeWin'</span>)</span><br><span class="line">  pre_gesture = <span class="number">4</span>;</span><br><span class="line">  robot.keyToggle(<span class="string">'alt'</span>, <span class="string">'down'</span>)</span><br><span class="line">  robot.keyTap(<span class="string">'f4'</span>)</span><br><span class="line">  robot.keyToggle(<span class="string">'alt'</span>, <span class="string">'up'</span>)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">altTab</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'altTab'</span>)</span><br><span class="line">  pre_gesture = <span class="number">8</span>;</span><br><span class="line">  robot.keyToggle(<span class="string">'alt'</span>, <span class="string">'down'</span>)</span><br><span class="line">  key_set.push(<span class="string">'alt'</span>)</span><br><span class="line">  robot.keyTap(<span class="string">'tab'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">re_altTab</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'re_altTab'</span>)</span><br><span class="line">  pre_gesture = <span class="number">9</span>;</span><br><span class="line">  robot.keyToggle(<span class="string">'alt'</span>, <span class="string">'down'</span>)</span><br><span class="line">  key_set.push(<span class="string">'alt'</span>)</span><br><span class="line">  robot.keyToggle(<span class="string">'shift'</span>, <span class="string">'down'</span>)</span><br><span class="line">  key_set.push(<span class="string">'shift'</span>)</span><br><span class="line">  robot.keyTap(<span class="string">'tab'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">audioMute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'audio_mute'</span>)</span><br><span class="line">  robot.keyTap(<span class="string">'audio_mute'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pre_gesture;</span><br><span class="line"><span class="keyword">const</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">sock</span>) </span>&#123;</span><br><span class="line">  sock.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'close socket'</span>)</span><br><span class="line">    server.close()</span><br><span class="line">  &#125;)</span><br><span class="line">  sock.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok!'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">    <span class="keyword">let</span> stringifyData = data.toString()</span><br><span class="line">    <span class="keyword">if</span> (stringifyData === <span class="string">'5'</span>) &#123;</span><br><span class="line">      directable = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (controlable) &#123;</span><br><span class="line">        controlable = <span class="literal">false</span>;</span><br><span class="line">        clear_key();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        controlable = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      pre_gesture = stringifyData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (controlable) &#123;</span><br><span class="line">      <span class="keyword">if</span> (directable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stringifyData === <span class="string">'1'</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'up'</span>)</span><br><span class="line">          robot.keyTap(<span class="string">'up'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stringifyData === <span class="string">'7'</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'down'</span>)</span><br><span class="line">          robot.keyTap(<span class="string">'down'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stringifyData === <span class="string">'8'</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'right'</span>)</span><br><span class="line">          robot.keyTap(<span class="string">'right'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stringifyData === <span class="string">'9'</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'left'</span>)</span><br><span class="line">          robot.keyTap(<span class="string">'left'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stringifyData != pre_gesture) &#123;</span><br><span class="line">          clear_key()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stringifyData === <span class="string">'6'</span>) &#123;</span><br><span class="line">          audioMute()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stringifyData === <span class="string">'7'</span>) &#123;</span><br><span class="line">          minimize()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stringifyData === <span class="string">'4'</span>) &#123;</span><br><span class="line">          directable = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stringifyData === <span class="string">'2'</span>) &#123;</span><br><span class="line">          closeWindow()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stringifyData === <span class="string">'9'</span>) &#123;</span><br><span class="line">          re_altTab()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stringifyData === <span class="string">'8'</span>) &#123;</span><br><span class="line">          altTab()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'listening'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'start listening'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listen error'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'stop listening'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(&#123;</span><br><span class="line">  port: <span class="number">6080</span>,</span><br><span class="line">  host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  exclusive: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>electron的主进程中连接服务端并发送手势识别结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sockConfig = &#123;</span><br><span class="line">  port: <span class="number">6080</span>,</span><br><span class="line">  host: <span class="string">'127.0.0.1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sock = net.connect(sockConfig, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'connected to server!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sock.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'connect success'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendGesture</span>(<span class="params">ges</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ges2string = ges.toString()</span><br><span class="line">  <span class="built_in">console</span>.log(ges2string)</span><br><span class="line">  sock.write(ges2string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h2><p><img src="https://pic.downk.cc/item/5f00185114195aa59471b6bb.png"></p>
<center>为了避免误操作，一开始是上锁状态，无法操作</center>

<p><img src="https://pic.downk.cc/item/5f00188214195aa59471cc29.png"></p>
<center>手势5解锁</center>

<p><img src="https://pic.downk.cc/item/5f0018a814195aa59471daeb.png"></p>
<center>无法识别手势，需要调整手势</center>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>手势识别</tag>
        <tag>人机交互</tag>
        <tag>JavaScript</tag>
        <tag>Electron</tag>
        <tag>Tensorflow</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>状压dp总结(更新中)</title>
    <url>/2019/07/22/%E7%8A%B6%E5%8E%8Bdp%E6%80%BB%E7%BB%93-%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1pqI0aW61gK0jSZFlq6xDKFXaA.jpg" alt><br><a id="more"></a></p>
<p>所谓的状压dp指的是状态压缩dp。具体来说就是借助二进制数来对保存状态时的空间复杂度进行优化。举个简单的例子，对于一个n行m列的棋盘，如果用1表示有棋子放置，用0表示没有棋子放置，则我们可以用n个m位的二进制数来表示当前棋盘的整体状态。与常规的使用数组保存状态相比，对于一个n行m列的棋盘，至少需要一个n × m的int型数组来进行保存，也就是n × m × 32 byte。而使用二进制数表示则只需要n × 32 byte（一般而言）。由此可见，空间复杂度得到了很大的优化。而在状压dp中，我们可以使用各种位运算来操作二进制数，这使得时间复杂度也很优良。</p>
<p>首先上一道题目感受一下吧。</p>
<p><a href="https://www.luogu.org/problemnew/show/P1879" rel="external nofollow noopener noreferrer" target="_blank">P1879 Corn Fields</a></p>
<p>题目大意是说，有一块m行n列的牧场，每一格都是一块正方形的土地。现在要在这些土地上种草，规则是只能在肥沃的土地上种草，且不能选择两块相邻的土地。问一共有多少种可行的种植方案。（完全不种草也是一种方案）</p>
<p>如果不使用状压dp而是直接暴力dfs的话，当n和m取到最大值时，很有可能跑几个小时都跑不出结果……</p>
<p>考虑使用状压dp。大致思路为，首先使用m个n位的二进制数保存土地的肥沃情况，然后预处理出所有不存在相邻列的行状态。dp[i][j]表示的是对于牧场的第i行，在状态j下一共有多少种放置方法。对于第i行，我们可以由第k-1行转移过来。状态转移方程为:</p>
<script type="math/tex; mode=display">
dp[i][j]=(dp[i][j]+dp[i-1][k])\ mod\ p\\
p = 100000000, 0\lt j\lt (1<<n),0\lt k\lt (1<<n)</script><p>在最后计算答案的时候，根据dp[][]的定义，我们只需要讲dp[n][]里面的内容全部加起来，然后取个模就是题目要求的答案。</p>
<p>代码如下:</p>
<p>（由于个人习惯，代码中是n行m列，而非题目所述的m行n列）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> map_[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1</span>&lt;&lt;<span class="number">12</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">15</span>][<span class="number">1</span>&lt;&lt;<span class="number">12</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> mod=<span class="number">100000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;      <span class="comment">//n行m列 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp;<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">            map_[i]=(map_[i]&lt;&lt;<span class="number">1</span>)+tmp;   <span class="comment">//用二进制数保存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)&#123;</span><br><span class="line">        arr[i]=((i&amp;(i&lt;&lt;<span class="number">1</span>))==<span class="number">0</span>)&amp;&amp;((i&amp;(i&gt;&gt;<span class="number">1</span>))==<span class="number">0</span>); <span class="comment">//检查该状态是否有相邻列</span></span><br><span class="line">    &#125;</span><br><span class="line">    mst(dp,<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&amp;&amp;((j&amp;map_[i])==j))&#123;    <span class="comment">//当前状态没有相邻列，且都是在肥沃土地上种草</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);k++)&#123;    <span class="comment">//枚举上一行的状态</span></span><br><span class="line">                    <span class="keyword">if</span>((k&amp;j)==<span class="number">0</span>)        <span class="comment">//同一列上没有相邻</span></span><br><span class="line">                        dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][k])%mod; <span class="comment">//当前行的状态由上一行转移而来</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)</span><br><span class="line">        ans=(ans+dp[n][i])%mod;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这道题目，有没有一种感觉，状压dp其实是一种高效的暴力，也就是说，其本质还是暴力？确实如此，状压dp其实可以说是经过了很好的优化的暴力(至少目前我是这么认为的OTZ)。抓住这一点，有利于我们建立状压dp的思考方法。</p>
<p>再看一道题</p>
<p><a href="https://www.luogu.org/problemnew/show/P1896" rel="external nofollow noopener noreferrer" target="_blank">P1896 互不侵犯</a></p>
<p>题目大意是说，在一个n × n的棋盘中放k个国王，使他们互不攻击，问有多少种摆放的方案。国王可以攻击到它的上下左右，以及左上左下右上右下八个方向。</p>
<p>这道题与上一道题有点像，但多了个k个国王的约束条件。大致思路为：首先预处理出所有不存在列相邻情况的行状态，也就是那些无法让国王横向攻击的行状态。通过上一行的状态，可以转移得到当前行的状态。状态转移方程为：</p>
<script type="math/tex; mode=display">
dp[i][j][kings[i]+cnt]+=dp[i-1][p][cnt]\</script><p>该方程的第一维表示的是当前所处行的行号，第二维表示的是状态j，第三维表示的是在这一行以及这一行上面的行中一个放置了的国王的个数(kings[i]表示的是状态j的国王个数，也就是有多少个1)。</p>
<p>具体代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ll ok[<span class="number">1</span>&lt;&lt;<span class="number">9</span>+<span class="number">5</span>];</span><br><span class="line">ll kings[<span class="number">1</span>&lt;&lt;<span class="number">9</span>+<span class="number">5</span>];</span><br><span class="line">ll dp[<span class="number">10</span>][<span class="number">1</span>&lt;&lt;<span class="number">9</span>+<span class="number">2</span>][<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    mst(ok,<span class="number">0</span>);mst(kings,<span class="number">0</span>);</span><br><span class="line">    mst(dp,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> maxi_state=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxi_state;i++)&#123;        <span class="comment">//预处理所有不存在列相邻情况的行状态</span></span><br><span class="line">        <span class="keyword">if</span>((i&amp;(i&lt;&lt;<span class="number">1</span>))==<span class="number">0</span>)&#123;</span><br><span class="line">            ok[idx++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i++)&#123;        <span class="comment">//数一下状态i有多少个国王，也就是有多少个1</span></span><br><span class="line">        <span class="keyword">int</span> tmp=ok[i];</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            kings[i]+=(tmp&amp;<span class="number">1</span>);    <span class="comment">//等价于kings[i]+=tmp%2;</span></span><br><span class="line">            tmp&gt;&gt;=<span class="number">1</span>;            <span class="comment">//等价于tmp/=2;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kings[i]&lt;=k)        <span class="comment">//如果第一行的国王个数不大于k</span></span><br><span class="line">            dp[<span class="number">1</span>][i][kings[i]]=<span class="number">1</span>;    <span class="comment">//先处理第一行，以便根据第一行推出第二行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">2</span>;row&lt;=n;row++)&#123;    <span class="comment">//处理每一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i++)&#123;     <span class="comment">//枚举当前行的状态</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;idx;j++)&#123;     <span class="comment">//枚举上一行的状态</span></span><br><span class="line">                <span class="keyword">if</span>(ok[i]&amp;ok[j])        <span class="comment">//如果行相邻</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((ok[j]&lt;&lt;<span class="number">1</span>)&amp;(ok[i]))    <span class="comment">//如果对角线上有国王</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((ok[j]&gt;&gt;<span class="number">1</span>)&amp;(ok[i]))    <span class="comment">//同上</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> cnt=<span class="number">1</span>;cnt&lt;=k;cnt++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(kings[i]+cnt&lt;=k)&#123;        <span class="comment">//国王数不能超过k</span></span><br><span class="line">                        dp[row][i][kings[i]+cnt]+=dp[row<span class="number">-1</span>][j][cnt];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;        <span class="comment">//注意要用long long，否则会WA</span></span><br><span class="line">    <span class="comment">//因为不知道到底是在哪一行用完k个国王，所以要把所有行上的方案数都加起来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;idx;j++)</span><br><span class="line">            ans+=dp[i][j][k];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再来一题</p>
<p><a href="https://cn.vjudge.net/problem/HDU-1074" rel="external nofollow noopener noreferrer" target="_blank">Doing Homework</a></p>
<p>大致题意是说，现在要交作业了，一共有n项作业要做，每一项作业都对应一个ddl和完成所需要的时间，如果超过了ddl，则会得到一定的惩罚，每超过1天则惩罚加1分。问如何安排做作业的次序才能使得到的惩罚最少。</p>
<p>一开始看到这道题目时我没有想到要用状压，因为那时我还没学……我想到的是，这题感觉可以通过DAG来解决，但又似乎不是正解…..所以正确做法应该是，用二进制数表示某一科目是否已经完成，0表示未完成，1表示已完成。故011表示第1和第2项作业已经完成，而第3项则未完成。一个表示作业完成情况的二进制数是可以由其他二进制数转移而来的，如011就可以有001和010转移而来，而001和010都是由000转移而来。这就是这道题dp的基本思路。而对于这道题的输出，因为要输出做作业的次序，所以需要输出路径。这只需要记录下当前作业的前驱，输出时递归一下即可。具体见代码注释。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">int</span> ddl;</span><br><span class="line">&#125;;</span><br><span class="line">hw hws[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> dp[(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> pre[(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state==<span class="number">0</span>)    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> tt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(((<span class="number">1</span>&lt;&lt;i)&amp;state)&amp;&amp;(((<span class="number">1</span>&lt;&lt;i)&amp;pre[state])==<span class="number">0</span>))&#123;        </span><br><span class="line">            <span class="comment">//如果在状态state下，作业i已经完成，而state的前驱没有完成作业i，那就说明state相较于其</span></span><br><span class="line">            <span class="comment">//前驱，多完成了作业i</span></span><br><span class="line">            tt=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    show(pre[state]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;hws[tt].name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        mst(pre,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;hws[i].name&gt;&gt;hws[i].ddl&gt;&gt;hws[i].cost;</span><br><span class="line">        <span class="keyword">int</span> maxi_state=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxi_state;i++)</span><br><span class="line">            dp[i]=INF;        <span class="comment">//因为是求最小值，所以初始化为INF</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;        <span class="comment">//所有作业都没做时，惩罚自然也是0</span></span><br><span class="line">        <span class="keyword">int</span> kase=<span class="number">0</span>;<span class="keyword">int</span> t1=<span class="number">0</span>;<span class="keyword">int</span> t2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxi_state;i++)&#123;        <span class="comment">//枚举完成作业的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;    <span class="comment">//枚举作业</span></span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))        <span class="comment">//如果当前作业已经完成了，就continue</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;k))</span><br><span class="line">                        tot+=hws[k].cost;        <span class="comment">//将已经完成的作业所花费的时间加起来</span></span><br><span class="line">                &#125;</span><br><span class="line">                tot+=hws[j].cost;        <span class="comment">//再加上当前作业</span></span><br><span class="line">                <span class="keyword">int</span> penalty=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(tot&gt;hws[j].ddl)        <span class="comment">//计算惩罚</span></span><br><span class="line">                    penalty=tot-hws[j].ddl;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    penalty=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp=dp[i|(<span class="number">1</span>&lt;&lt;j)];</span><br><span class="line">                dp[i|(<span class="number">1</span>&lt;&lt;j)]=<span class="built_in">min</span>(dp[i|(<span class="number">1</span>&lt;&lt;j)],dp[i]+penalty);</span><br><span class="line">                <span class="keyword">if</span>(dp[i|(<span class="number">1</span>&lt;&lt;j)]!=tmp)       <span class="comment">//小于时才去记录</span></span><br><span class="line">                    pre[i|(<span class="number">1</span>&lt;&lt;j)]=i;        <span class="comment">//pre[]保存前驱状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        show((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，经过这三道题目，可以得出结论，状压dp其实本质就是暴力(大概)</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树专题总结</title>
    <url>/2019/08/10/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H8248ceab1da6430e949cd345061b92c0I.jpg" alt></p>
<p>Photo by <strong>Mohsin</strong> khan from <strong>Pexels</strong><br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>线段树的专题事实上早就已经刷完了，然而一直拖到现在才写题解……</p>
<p>bin巨的线段树专题主要包括以下几个方面：</p>
<ul>
<li>线段树维护和、区间和、立方和、最大值、最小值</li>
<li>线段树与染色问题</li>
<li>区间合并</li>
<li>扫描线</li>
</ul>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><a href="https://cn.vjudge.net/problem/HDU-1166" rel="external nofollow noopener noreferrer" target="_blank">HDU1166 敌兵布阵</a></p>
<p>题意是说，现在有N个数，三种操作，这三种操作分别是：</p>
<ul>
<li>Add i j，表示在第$i$个数$a_i$上加上$j$</li>
<li>Sub i j，表示在第$i$个数$a_i$上减去$j$</li>
<li>Query i j，表示询问区间$[i,j]$的总和</li>
</ul>
<p>典型的单点修改区间查询。直接套线段树模板即可。sub操作可以通过add上相反数实现。</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> todo,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        sum[rt]+=todo;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">        update(pos,todo,lson);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        update(pos,todo,rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=lef&amp;&amp;R&gt;=rig)</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">        ret+=query(L,R,lson);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">        ret+=query(L,R,rson);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,++kase);</span><br><span class="line">        mst(arr,<span class="number">0</span>);mst(sum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        getchar();</span><br><span class="line"><span class="comment">//        for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//            scanf("%d",&amp;arr[i]);</span></span><br><span class="line">        build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> str[<span class="number">15</span>];<span class="keyword">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'E'</span>)        <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b); </span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> ans=query(a,b,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'A'</span>)&#123;</span><br><span class="line">                update(a,b,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'S'</span>)&#123;</span><br><span class="line">                update(a,-b,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/HDU-1754" rel="external nofollow noopener noreferrer" target="_blank">HDU1754 I Hate It</a></p>
<p>题意是查询区间最大值，同时还要有修改操作。线段树维护区间最大值即可。</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> maxi[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    maxi[rt]=<span class="built_in">max</span>(maxi[rt&lt;&lt;<span class="number">1</span>],maxi[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</span><br><span class="line">        maxi[rt]=tmp;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> val,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        maxi[rt]=val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">        update(pos,val,lson);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        update(pos,val,rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=lef&amp;&amp;rig&lt;=R)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,maxi[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">        query(L,R,lson);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">        query(L,R,rson);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">        build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        ans=<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//        getchar();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">char</span> op;<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;op);</span><br><span class="line">            <span class="keyword">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="string">'Q'</span>)&#123;</span><br><span class="line">                ans=<span class="number">-1</span>;</span><br><span class="line">                query(x,y,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'U'</span>)&#123;</span><br><span class="line">                update(x,y,<span class="number">1</span>,n,<span class="number">1</span>);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题有多组样例…OTZ</p>
<p><a href="https://cn.vjudge.net/problem/POJ-3468" rel="external nofollow noopener noreferrer" target="_blank">POJ3468 A Simple Problem with integers</a></p>
<p>题意是说，有一串数字以及两种操作，一是为某一区间上的数都加上某个数，另一个操作是询问区间和。最简单的区间修改区间查询。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ll sum[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll lazy[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(ll rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll lef,ll rig,ll rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt]=<span class="number">0</span>;lazy[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line"><span class="comment">//        cin&gt;&gt;sum[rt];</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(ll rt,ll len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt])&#123;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]+=lazy[rt];</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>]+=lazy[rt]*(len-(len&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[rt]*(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        lazy[rt]=<span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll toL,ll toR,ll todo,ll lef,ll rig,ll rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;toR&gt;=rig)&#123;</span><br><span class="line">        lazy[rt]+=todo;</span><br><span class="line">        sum[rt]+=todo*(rig-lef+<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt,rig-lef+<span class="number">1</span>);</span><br><span class="line">    ll mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        update(toL,toR,todo,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        update(toL,toR,todo,rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll toL,ll toR,ll lef,ll rig,ll rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;toR&gt;=rig)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt,rig-lef+<span class="number">1</span>);</span><br><span class="line">    ll mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        ans+=query(toL,toR,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        ans+=query(toL,toR,rson);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    std::ios::sync_with_stdio(false);</span></span><br><span class="line">    ll n,q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;q);</span><br><span class="line">    build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> op;<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">'Q'</span>)&#123;</span><br><span class="line">            ll L,R;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;L,&amp;R);</span><br><span class="line">            ll ans=query(L,R,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'C'</span>)&#123;</span><br><span class="line">            ll L,R,to;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;L,&amp;R,&amp;to);</span><br><span class="line">            update(L,R,to,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/POJ-2528" rel="external nofollow noopener noreferrer" target="_blank">POJ2528 Mayor’s posters</a></p>
<p>已写题解，不再赘述</p>
<p><a href="https://mimori.coding.me/2019/05/18/POJ2528-Mayor-s-poster/" rel="external nofollow noopener noreferrer" target="_blank">Mayor’s poster</a></p>
<p><a href="https://cn.vjudge.net/problem/HDU-1698" rel="external nofollow noopener noreferrer" target="_blank">HDU1698 Just a Hook</a></p>
<p>就是区间修改区间查询。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> lazy[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt]!=<span class="number">0</span>)&#123;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]=lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=lazy[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>]=(len-(len&gt;&gt;<span class="number">1</span>))*lazy[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(len&gt;&gt;<span class="number">1</span>)*lazy[rt];</span><br><span class="line">        lazy[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        sum[rt]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> todo,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;toR&gt;=rig)&#123;</span><br><span class="line">        lazy[rt]=todo;</span><br><span class="line">        sum[rt]=(rig-lef+<span class="number">1</span>)*todo;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    pushdown(rt,rig-lef+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        update(toL,toR,todo,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        update(toL,toR,todo,rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;toR&gt;=rig)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    pushdown(rt,rig-lef+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        ret+=query(toL,toR,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        ret+=query(toL,toR,rson);</span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        mst(lazy,<span class="number">0</span>);mst(sum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        debug;</span></span><br><span class="line">        <span class="keyword">int</span> q;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="comment">//        debug;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line"><span class="comment">//            debug;</span></span><br><span class="line">            <span class="keyword">int</span> x,y,z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            update(x,y,z,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: The total value of the hook is %d.\n"</span>,++kase,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/ZOJ-1610" rel="external nofollow noopener noreferrer" target="_blank">ZOJ1610 Count the Colors</a></p>
<p>依然是染色问题。题意是说，在一条直线上涂色，颜色与颜色之间可以相互覆盖，问最终可以看到的颜色有多少。</p>
<p>与贴海报那题思路几乎一样。只需要用个$cnt[]$数组记录一下颜色个数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">8005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> lazy[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lef;</span><br><span class="line">    <span class="keyword">int</span> rig;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">&#125;;</span><br><span class="line">node ns[<span class="number">8005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]=lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=lazy[rt];</span><br><span class="line">        lazy[rt]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> todo,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;toR&gt;=rig)&#123;</span><br><span class="line">        lazy[rt]=todo;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        update(toL,toR,todo,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        update(toL,toR,todo,rson);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tag=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy[rt]!=<span class="number">-1</span>&amp;&amp;lazy[rt]!=tag)&#123;</span><br><span class="line">            cnt[lazy[rt]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        tag=lazy[rt];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    query(lson);</span><br><span class="line">    query(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> max_id=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> range=<span class="number">-1</span>;</span><br><span class="line">        mst(lazy,<span class="number">-1</span>);mst(cnt,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> lef,rig,to;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;ns[i].lef,&amp;ns[i].rig,&amp;ns[i].to);</span><br><span class="line">            range=<span class="built_in">max</span>(range,ns[i].rig); </span><br><span class="line">            max_id=<span class="built_in">max</span>(max_id,ns[i].to);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            update(ns[i].lef+<span class="number">1</span>,ns[i].rig,ns[i].to,<span class="number">0</span>,range,<span class="number">1</span>);</span><br><span class="line">        query(<span class="number">0</span>,range,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=max_id;i++)</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]!=<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,cnt[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/POJ-3264" rel="external nofollow noopener noreferrer" target="_blank">POJ3264 Balanced Lineup</a></p>
<p>线段树维护区间最大值和最小值</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">8005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> lazy[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lef;</span><br><span class="line">    <span class="keyword">int</span> rig;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">&#125;;</span><br><span class="line">node ns[<span class="number">8005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]=lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=lazy[rt];</span><br><span class="line">        lazy[rt]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> todo,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;toR&gt;=rig)&#123;</span><br><span class="line">        lazy[rt]=todo;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        update(toL,toR,todo,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        update(toL,toR,todo,rson);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tag=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy[rt]!=<span class="number">-1</span>&amp;&amp;lazy[rt]!=tag)&#123;</span><br><span class="line">            cnt[lazy[rt]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        tag=lazy[rt];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    query(lson);</span><br><span class="line">    query(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> max_id=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> range=<span class="number">-1</span>;</span><br><span class="line">        mst(lazy,<span class="number">-1</span>);mst(cnt,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> lef,rig,to;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;ns[i].lef,&amp;ns[i].rig,&amp;ns[i].to);</span><br><span class="line">            range=<span class="built_in">max</span>(range,ns[i].rig); </span><br><span class="line">            max_id=<span class="built_in">max</span>(max_id,ns[i].to);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            update(ns[i].lef+<span class="number">1</span>,ns[i].rig,ns[i].to,<span class="number">0</span>,range,<span class="number">1</span>);</span><br><span class="line">        query(<span class="number">0</span>,range,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=max_id;i++)</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]!=<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,cnt[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/HDU-4027" rel="external nofollow noopener noreferrer" target="_blank">HDU4027 Can you answer these queries?</a></p>
<p>题意是说，现在有一正整数序列，还有两种操作，第一种是可以将某一区间内的整数变为其自身的平方根；第二种操作是询问区间和。</p>
<p>注意本题有一个条件，“Notice that the square root operation should be rounded down to integer.”，因此，当某次操作后，如果某个数的结果小于1，那它就直接变成0了！这就给了我们一个解题的思路：这题我们可以一直走到叶子节点再进行平方根操作，对于那些已经为0的数，就可以将它们记录下来，下次操作的时候就可以不用操作这个数了！由此降低复杂度。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ll sum[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    flag[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag[rt&lt;&lt;<span class="number">1</span>]&amp;&amp;flag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])</span><br><span class="line">        flag[rt]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag[rt])</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        sum[rt]=(ll)<span class="built_in">sqrt</span>(sum[rt]);</span><br><span class="line">        <span class="keyword">if</span>(sum[rt]&lt;=<span class="number">1</span>)        </span><br><span class="line">            flag[rt]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid) </span><br><span class="line">        update(toL,toR,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)    </span><br><span class="line">        update(toL,toR,rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;rig&lt;=toR)&#123;</span><br><span class="line">        ans+=sum[rt];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        query(toL,toR,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        query(toL,toR,rson);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        mst(flag,<span class="number">0</span>);</span><br><span class="line">        build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++kase);</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="keyword">int</span> op,l,r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line">            <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">                swap(l,r);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">0</span>)&#123;</span><br><span class="line">                update(l,r,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">                ans=<span class="number">0</span>;</span><br><span class="line">                query(l,r,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/HDU-1540" rel="external nofollow noopener noreferrer" target="_blank">HDU1540 Tunnel Warfare</a></p>
<p>地道战。</p>
<p>题意是说，有一系列的村庄，除了末端的两个村庄以外，其他的都与相邻的两个连接形成一条线。现在有三种操作，一种是摧毁第$x$个村庄；一种是询问有多少个村庄与第$x$个村庄直接或间接连接；还有一种是将最后被摧毁的村庄修复，意味着该村庄与其邻近两个村庄的连接重新建立。</p>
<p>这题的正解是区间合并，但有一种很巧妙的做法：用线段树维护区间最大值和最小值。对于最大值，一开始初始化每个村庄都为0；对于最小值，初始化每个村庄都为INF。摧毁的时候，如果要摧毁第$x$个村庄，只需要将对应的maxi[rt]改为$x$，对应的mini[rt]也改为$x$即可。查询的时候，对于第$x$个村庄，查询区间$[1,x-1]$的最小值$mini_val$，再查询区间$[x,n]$的最大值$mini_val$，答案就是$mini_val-maxi_val-1$。而对于修复操作，只需要将对应的maxi[rt]改回0，mini[rt]改回INF即可。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> mini[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> maxi[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mini[rt]=<span class="built_in">min</span>(mini[rt&lt;&lt;<span class="number">1</span>],mini[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    maxi[rt]=<span class="built_in">max</span>(maxi[rt&lt;&lt;<span class="number">1</span>],maxi[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        mini[rt]=n+<span class="number">1</span>;</span><br><span class="line">        maxi[rt]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_max</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> todo,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        maxi[rt]=todo;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">        update_max(pos,todo,lson);</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;mid)</span><br><span class="line">        update_max(pos,todo,rson);</span><br><span class="line">    maxi[rt]=<span class="built_in">max</span>(maxi[rt&lt;&lt;<span class="number">1</span>],maxi[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_min</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> todo,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        mini[rt]=todo;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">        update_min(pos,todo,lson);</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;mid)</span><br><span class="line">        update_min(pos,todo,rson);</span><br><span class="line">    mini[rt]=<span class="built_in">min</span>(mini[rt&lt;&lt;<span class="number">1</span>],mini[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> min_val=INF;</span><br><span class="line"><span class="keyword">int</span> max_val=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;rig&lt;=toR)&#123;</span><br><span class="line">        max_val=<span class="built_in">max</span>(max_val,maxi[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        query_max(toL,toR,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        query_max(toL,toR,rson);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;rig&lt;=toR)&#123;</span><br><span class="line">        min_val=<span class="built_in">min</span>(min_val,mini[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        query_min(toL,toR,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        query_min(toL,toR,rson);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stk[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">     <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">         getchar();<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">         mst(stk,<span class="number">0</span>);</span><br><span class="line">         build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">             max_val=<span class="number">-2</span>;min_val=INF;</span><br><span class="line">            <span class="keyword">char</span> op;<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line"><span class="comment">//            getchar();getchar();</span></span><br><span class="line">            <span class="keyword">if</span>(op==<span class="string">'D'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> a;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">                stk[cnt++]=a;</span><br><span class="line">                update_max(a,a,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">                update_min(a,a,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> a;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">                query_max(<span class="number">1</span>,a,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">                query_min(a,n,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//                cout&lt;&lt;"max:"&lt;&lt;max_val&lt;&lt;" "&lt;&lt;"min:"&lt;&lt;min_val&lt;&lt;endl; </span></span><br><span class="line"><span class="comment">//                if(min_val==50001)        min_val=n+1;</span></span><br><span class="line"><span class="comment">//                if(max_val==-1)        max_val=1;</span></span><br><span class="line">                <span class="keyword">int</span> ans=min_val-max_val<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(min_val==max_val)        ans=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'R'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=stk[--cnt];</span><br><span class="line">                update_max(tmp,<span class="number">0</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">                update_min(tmp,n+<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而本题的正解我却没有写hhhh，先挖个坑，到时再补</p>
<p><a href="https://cn.vjudge.net/problem/HDU-3974" rel="external nofollow noopener noreferrer" target="_blank">HDU3974 Assign the task</a></p>
<p>题意是说，一个公司有N个员工，每个员工都有一个直接的上司。叶子节点没有下属，树根没有上司。当上司收到工作后，上司会将这份工作下发给他的所有下属，包括不直属的下属。下属在收到一份新的工作后，会马上停止手头上的工作开始新的工作。问，当前某个员工的工作是什么。</p>
<p>先用dfs序将树转为线性区间，就转化为单点查询区间修改的问题了，可以直接用线段树来搞。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> in[maxn];</span><br><span class="line"><span class="keyword">int</span> out[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gra[maxn];</span><br><span class="line"><span class="keyword">int</span> tree[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span>        <span class="comment">//id从1开始 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len++;</span><br><span class="line">    in[u]=id++;        <span class="comment">//记录一下入栈时间 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;gra[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dfs(gra[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    out[u]=id++;    <span class="comment">//记录一下出栈时间 </span></span><br><span class="line">    len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[rt]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[rt]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        tree[rt&lt;&lt;<span class="number">1</span>]=tree[rt];</span><br><span class="line">        tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=tree[rt];</span><br><span class="line">        tree[rt]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> todo,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;rig&lt;=toR)&#123;</span><br><span class="line">        tree[rt]=todo;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        update(toL,toR,todo,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        update(toL,toR,todo,rson);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        ans=tree[rt];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">        query(pos,lson);</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;mid)</span><br><span class="line">        query(pos,rson);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("data_generator.txt","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++kase);</span><br><span class="line">        ans=<span class="number">0</span>;id=<span class="number">1</span>;</span><br><span class="line">        mst(vis,<span class="number">0</span>);</span><br><span class="line">        mst(in,<span class="number">0</span>);mst(out,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">2</span>*n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">            gra[v].push_back(u);</span><br><span class="line">            vis[u]=<span class="number">1</span>;        <span class="comment">//用来记录节点u是否是别人的儿子 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="comment">//        getchar();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> op;<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line"><span class="comment">//            char tmp=getchar();</span></span><br><span class="line">            <span class="keyword">if</span>(op==<span class="string">'C'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">                query(in[x],<span class="number">1</span>,<span class="number">2</span>*n,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);    </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'T'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">                update(in[x],out[x],y,<span class="number">1</span>,<span class="number">2</span>*n,<span class="number">1</span>);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            gra[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/HDU-4578" rel="external nofollow noopener noreferrer" target="_blank">HDU4578 Transformation</a></p>
<p>题意是说，现在有$n$个整数$a_1,a_2,a_3,…,a_n$，初始值都为0。有以下四种操作：</p>
<ul>
<li><p>对$a_x$到$a_y$的数，分别都加上$c$。</p>
</li>
<li><p>对$a_x$到$a_y$的数，分别都乘上$c$。</p>
</li>
<li><p>将$a_x$到$a_y$的数，都改为$c$。</p>
</li>
<li><p>求$a<em>x$到$a_y$的数的$p$次幂的总和。即$a_x^p+a</em>{x+1}^p+a<em>{x+2}^p+…+a</em>{y}^p$。其中，$0 \lt p \lt 4$，$p$是整数。</p>
<p>这是一道比较复杂的题目，难点在于怎么维护$p$次幂的区间和，以及加操作与乘操作之间的相互影响怎么处理。事实上根据以下两条式子来维护三次方和以及二次方和即可：</p>
<script type="math/tex; mode=display">
(x+c)^3=x^3+3cx^2+3c^2x+c^3 \\
(x+c)^2=x^2+2cx+c^2</script><p>具体的看代码注释吧。</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ll mod=<span class="number">10007</span>;</span><br><span class="line">ll sum1[maxn&lt;&lt;<span class="number">2</span>];        <span class="comment">//区间和 </span></span><br><span class="line">ll sum2[maxn&lt;&lt;<span class="number">2</span>];        <span class="comment">//区间平方和 </span></span><br><span class="line">ll sum3[maxn&lt;&lt;<span class="number">2</span>];        <span class="comment">//区间立方和</span></span><br><span class="line">ll lazy_add[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll lazy_mul[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll lazy_set[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum1[rt]=(sum1[rt&lt;&lt;<span class="number">1</span>]+sum1[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">    sum2[rt]=(sum2[rt&lt;&lt;<span class="number">1</span>]+sum2[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">    sum3[rt]=(sum3[rt&lt;&lt;<span class="number">1</span>]+sum3[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum1[rt]=sum2[rt]=sum3[rt]=<span class="number">0</span>;</span><br><span class="line">    lazy_add[rt]=<span class="number">0</span>;</span><br><span class="line">    lazy_mul[rt]=<span class="number">1</span>;</span><br><span class="line">    lazy_set[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line"><span class="comment">//        sum1[rt]=sum2[rt]=sum3[rt]=0;</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy_set[rt]!=<span class="number">0</span>)&#123;</span><br><span class="line">        lazy_add[rt&lt;&lt;<span class="number">1</span>]=lazy_add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">0</span>;        </span><br><span class="line">        lazy_mul[rt&lt;&lt;<span class="number">1</span>]=lazy_mul[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        lazy_set[rt&lt;&lt;<span class="number">1</span>]=lazy_set[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=lazy_set[rt];</span><br><span class="line">        ll tmp=(lazy_set[rt]*(lazy_set[rt]%mod)*(lazy_set[rt]%mod))%mod;</span><br><span class="line">        sum3[rt&lt;&lt;<span class="number">1</span>]=((len-(len&gt;&gt;<span class="number">1</span>))*tmp)%mod;</span><br><span class="line">        sum3[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=((len&gt;&gt;<span class="number">1</span>)*tmp)%mod;</span><br><span class="line">        </span><br><span class="line">        sum2[rt&lt;&lt;<span class="number">1</span>]=((len-(len&gt;&gt;<span class="number">1</span>))*((lazy_set[rt]%mod)*(lazy_set[rt]%mod)))%mod;</span><br><span class="line">        sum2[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=((len&gt;&gt;<span class="number">1</span>)*((lazy_set[rt]%mod)*(lazy_set[rt]%mod)))%mod;</span><br><span class="line">        </span><br><span class="line">        sum1[rt&lt;&lt;<span class="number">1</span>]=((len-(len&gt;&gt;<span class="number">1</span>))*(lazy_set[rt]%mod))%mod;</span><br><span class="line">        sum1[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=((len&gt;&gt;<span class="number">1</span>)*(lazy_set[rt]%mod))%mod;</span><br><span class="line">        </span><br><span class="line">        lazy_set[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lazy_add[rt]!=<span class="number">0</span>||lazy_mul[rt]!=<span class="number">1</span>)&#123;</span><br><span class="line">        ll add=lazy_add[rt];ll mul=lazy_mul[rt];</span><br><span class="line">        ll tmp=(mul*mul%mod*mul%mod)%mod;</span><br><span class="line">        </span><br><span class="line">        lazy_add[rt&lt;&lt;<span class="number">1</span>]=(lazy_add[rt&lt;&lt;<span class="number">1</span>]*mul%mod+add%mod)%mod;</span><br><span class="line">        lazy_add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(lazy_add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul%mod+add%mod)%mod;</span><br><span class="line">        lazy_mul[rt&lt;&lt;<span class="number">1</span>]=(lazy_mul[rt&lt;&lt;<span class="number">1</span>]%mod*mul%mod)%mod;</span><br><span class="line">        lazy_mul[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(lazy_mul[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul%mod)%mod;</span><br><span class="line">        </span><br><span class="line">        sum3[rt&lt;&lt;<span class="number">1</span>]=(sum3[rt&lt;&lt;<span class="number">1</span>]*tmp%mod+add*add%mod*add%mod*(len-(len&gt;&gt;<span class="number">1</span>))</span><br><span class="line">                    +<span class="number">3</span>*sum2[rt&lt;&lt;<span class="number">1</span>]*mul*mul%mod*add%mod+<span class="number">3</span>*sum1[rt&lt;&lt;<span class="number">1</span>]*mul</span><br><span class="line">                    *add%mod*add%mod)%mod;        <span class="comment">//(x + c)^3 = x^3 + 3cx^2 + 3(c^2)x + c^3</span></span><br><span class="line">        sum3[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sum3[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*tmp%mod+add*add%mod*add%mod*(len&gt;&gt;<span class="number">1</span>)</span><br><span class="line">                    +<span class="number">3</span>*sum2[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul*mul%mod*add%mod+<span class="number">3</span>*sum1[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul</span><br><span class="line">                    *add%mod*add%mod)%mod;        <span class="comment">//(x + c)^3 = x^3 + 3cx^2 + 3(c^2)x + c^3</span></span><br><span class="line">                    </span><br><span class="line">        sum2[rt&lt;&lt;<span class="number">1</span>]=(sum2[rt&lt;&lt;<span class="number">1</span>]*mul*mul%mod+add*add%mod*(len-(len&gt;&gt;<span class="number">1</span>))</span><br><span class="line">                    +<span class="number">2</span>*mul*add%mod*sum1[rt&lt;&lt;<span class="number">1</span>]%mod)%mod;    <span class="comment">//(x + c)^2 = x^2 + 2cx + c^2</span></span><br><span class="line">        sum2[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sum2[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul*mul%mod+add*add%mod*(len&gt;&gt;<span class="number">1</span>)</span><br><span class="line">                    +<span class="number">2</span>*mul*add%mod*sum1[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;    <span class="comment">//(x + c)^2 = x^2 + 2cx + c^2</span></span><br><span class="line">                    </span><br><span class="line">        sum1[rt&lt;&lt;<span class="number">1</span>]=(sum1[rt&lt;&lt;<span class="number">1</span>]*mul%mod+add%mod*(len-(len&gt;&gt;<span class="number">1</span>)))%mod;</span><br><span class="line">        sum1[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sum1[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul%mod+add%mod*(len&gt;&gt;<span class="number">1</span>))%mod;</span><br><span class="line">        </span><br><span class="line">        lazy_add[rt]=<span class="number">0</span>;lazy_mul[rt]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">op==1:add </span></span><br><span class="line"><span class="comment">op==2:mul</span></span><br><span class="line"><span class="comment">op==3:set</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> op,<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> todo,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toR&lt;lef||toL&gt;rig)        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;toR&gt;=rig)&#123;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            lazy_add[rt]=(todo+lazy_add[rt])%mod;</span><br><span class="line">            sum3[rt]=(sum3[rt]+(todo*todo%mod*todo%mod*(rig-lef+<span class="number">1</span>))</span><br><span class="line">            +<span class="number">3</span>*todo%mod*sum2[rt]%mod+<span class="number">3</span>*todo*todo%mod*sum1[rt]%mod)%mod;</span><br><span class="line">            <span class="comment">//(x + c)^3 = x^3 + 3cx^2 + 3(c^2)x + c^3</span></span><br><span class="line">            sum2[rt]=(sum2[rt]+(todo*todo%mod)*(rig-lef+<span class="number">1</span>)</span><br><span class="line">            +<span class="number">2</span>*sum1[rt]%mod*todo%mod)%mod;</span><br><span class="line">            </span><br><span class="line">            sum1[rt]=(sum1[rt]+(rig-lef+<span class="number">1</span>)*todo%mod)%mod;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            lazy_add[rt]=(lazy_add[rt]*todo)%mod;</span><br><span class="line">            lazy_mul[rt]=(lazy_mul[rt]*todo)%mod;</span><br><span class="line">            sum1[rt]=(todo*sum1[rt])%mod;</span><br><span class="line">            sum2[rt]=(todo*todo%mod*sum2[rt])%mod;</span><br><span class="line">            sum3[rt]=(todo*todo%mod*todo%mod*sum3[rt]%mod)%mod;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            lazy_add[rt]=<span class="number">0</span>;</span><br><span class="line">            lazy_mul[rt]=<span class="number">1</span>;</span><br><span class="line">            lazy_set[rt]=todo;</span><br><span class="line">            sum3[rt]=(rig-lef+<span class="number">1</span>)%mod*todo*todo%mod*todo%mod;</span><br><span class="line">            sum2[rt]=(rig-lef+<span class="number">1</span>)%mod*todo*todo%mod;</span><br><span class="line">            sum1[rt]=(rig-lef+<span class="number">1</span>)%mod*todo%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    push_down(rt,rig-lef+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        update(op,toL,toR,todo,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        update(op,toL,toR,todo,rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;toR&gt;=rig)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> sum1[rt];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> sum2[rt];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> sum3[rt]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    push_down(rt,rig-lef+<span class="number">1</span>);</span><br><span class="line">    ll ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        ret+=query(p,toL,toR,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        ret+=query(p,toL,toR,rson);</span><br><span class="line">    <span class="keyword">return</span> ret%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//void update(int op,int toL,int toR,int todo,int lef,int rig,int rt)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("data_generator.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("out_hdu4578.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF&amp;&amp;n&amp;&amp;m)&#123;</span><br><span class="line"><span class="comment">//        mst(sum1,0);mst(sum2,0);mst(sum3,0);</span></span><br><span class="line"><span class="comment">//        mst(lazy_add,0);mst(lazy_mul,0);mst(lazy_set,0);</span></span><br><span class="line">        build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> type;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;type);</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            c%=mod; </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="keyword">if</span>(type!=<span class="number">4</span>)&#123;</span><br><span class="line">                update(type,a,b,c,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ll ans=query(c,a,b,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">                ans%=mod;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://cn.vjudge.net/problem/HDU-4614" rel="external nofollow noopener noreferrer" target="_blank">HDU4614 Vases and Flowers</a></p>
<p>题意是说，有若干个花瓶，有两种操作，分别是</p>
<ul>
<li>从花瓶A开始放F朵花，如果某个花瓶已经有花了，就跳过这个花瓶。不断尝试花瓶，直至所有花都放完了，或者A以及A以后的花瓶都被尝试了一边。输出放第一朵花的位置以及放最后一朵花的位置。</li>
<li>第二种操作则是清楚区间内的花。并输出清除了多少花</li>
</ul>
<p>思路是，空花瓶用1表示，线段树提供set操作，维护区间和。清空花瓶的操作很简单，只需要查询一下区间和，然后用区间长度减去区间和即可。对于放花的操作，可以用二分找到左边界和右边界。具体见代码及注释。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> lazy[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lazy[rt]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        sum[rt]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]=lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=lazy[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>]=lazy[rt]*(len-(len&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=lazy[rt]*(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        lazy[rt]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> todo,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span>        <span class="comment">//进行set操作    //空花瓶用1表示 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;rig&lt;=toR)&#123;</span><br><span class="line">        lazy[rt]=todo;</span><br><span class="line">        sum[rt]=(rig-lef+<span class="number">1</span>)*todo;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt,rig-lef+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        update(toL,toR,todo,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        update(toL,toR,todo,rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;rig&lt;=toR)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    pushdown(rt,rig-lef+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        ret+=query(toL,toR,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        ret+=query(toL,toR,rson);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> num,<span class="keyword">int</span> cnt)</span>        <span class="comment">//cnt为要找的空花瓶的数目 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=L+(R-L)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">        mid=L+(R-L)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(query(<span class="number">0</span>,mid,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>)-num&gt;=cnt)&#123;</span><br><span class="line">            R=mid<span class="number">-1</span>;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            L=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        build(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> op;<span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> tot=query(x,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(tot==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Can not put any one.\n"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tot&lt;y)        y=tot;    <span class="comment">//tot为从x开始最多能放的花的数目 </span></span><br><span class="line">                <span class="keyword">int</span> nu=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;=<span class="number">1</span>)</span><br><span class="line">                    nu=query(<span class="number">0</span>,x<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nu=<span class="number">0</span>;        <span class="comment">//此时x-1为负数，要特判一下 </span></span><br><span class="line">                <span class="keyword">int</span> lef=binary(x,n<span class="number">-1</span>,nu,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> rig=binary(x,n<span class="number">-1</span>,nu,y);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;lef&lt;&lt;<span class="string">" "</span>&lt;&lt;rig&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                update(lef,rig,<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> ans=(y-x+<span class="number">1</span>)-query(x,y,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                update(x,y,<span class="number">1</span>,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>);        <span class="comment">//1表示空花瓶 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/POJ-1177" rel="external nofollow noopener noreferrer" target="_blank">POJ1177 Picture</a></p>
<p>题目是让我们求若干个矩形重叠后形成的大矩形的周长。<br>扫描线题目，但一般来说扫描线都是用来求取重叠面积的，而此处是求取周长。线段树维护区间中被覆盖的长度以及区间中线段的数目。之所以要维护线段长度，是因为在计算矩形$y$方向上的周长时需要用到。每次update的时候根据线段树更新区间结果即可。<br>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lef,rig;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    seg()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    seg(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> h,<span class="keyword">int</span> tag)</span><br><span class="line">        :lef(lef),rig(rig),h(h),tag(tag)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> seg&amp; se) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h&lt;se.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">seg segs[<span class="number">5005</span>*<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>        <span class="comment">//表示一个区间 </span></span><br><span class="line">    <span class="keyword">int</span> lef,rig;    <span class="comment">//左右端点 </span></span><br><span class="line">    <span class="keyword">int</span> len;        <span class="comment">//被覆盖的长度 </span></span><br><span class="line">    <span class="keyword">int</span> cover_cnt;    <span class="comment">//被覆盖的次数 </span></span><br><span class="line">    <span class="keyword">bool</span> lc,rc;        <span class="comment">//左右端点是否被覆盖 </span></span><br><span class="line">    <span class="keyword">int</span> num;        <span class="comment">//区间中线段数目 </span></span><br><span class="line">    node()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node ns[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ns[rt].lef=lef;ns[rt].rig=rig;</span><br><span class="line">    ns[rt].len=<span class="number">0</span>;</span><br><span class="line">    ns[rt].cover_cnt=ns[rt].lc=ns[rt].rc=<span class="number">0</span>;</span><br><span class="line">    ns[rt].num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ns[rt].cover_cnt)&#123;</span><br><span class="line">        ns[rt].len=ns[rt].rig-ns[rt].lef+<span class="number">1</span>;</span><br><span class="line">        ns[rt].lc=ns[rt].rc=<span class="number">1</span>;</span><br><span class="line">        ns[rt].num=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ns[rt].lef==ns[rt].rig)&#123;</span><br><span class="line">        ns[rt].len=<span class="number">0</span>;</span><br><span class="line">        ns[rt].lc=ns[rt].rc=<span class="number">0</span>;</span><br><span class="line">        ns[rt].num=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ns[rt&lt;&lt;<span class="number">1</span>].rc&amp;&amp;ns[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lc)</span><br><span class="line">            tmp=<span class="number">1</span>;</span><br><span class="line">        ns[rt].len=ns[rt&lt;&lt;<span class="number">1</span>].len+ns[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line">        ns[rt].num=ns[rt&lt;&lt;<span class="number">1</span>].num+ns[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].num-tmp;        </span><br><span class="line">        <span class="comment">//当左儿子的右端点以及右儿子的左端点完全被覆盖时，中间会有一段被重复计算</span></span><br><span class="line">        <span class="comment">//的线段，故需要将其减去. </span></span><br><span class="line">        ns[rt].lc=ns[rt&lt;&lt;<span class="number">1</span>].lc;ns[rt].rc=ns[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].rc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span>        <span class="comment">//根据扫描线对线段树节点进行更新</span></span></span><br><span class="line"><span class="function"><span class="comment">//参数表中的lef和rig表示扫描线的左右端点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;"rt = "&lt;&lt;rt&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(lef==ns[rt].lef&amp;&amp;ns[rt].rig==rig)&#123;</span><br><span class="line">        ns[rt].cover_cnt+=val;</span><br><span class="line">        pushup(rt);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(ns[rt].lef)+(ns[rt].rig-ns[rt].lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(rig&lt;=mid)&#123;</span><br><span class="line">        update(val,lef,rig,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lef&gt;mid)&#123;</span><br><span class="line">        update(val,lef,rig,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        update(val,lef,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        update(val,mid+<span class="number">1</span>,rig,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ub=-INF;</span><br><span class="line">    <span class="keyword">int</span> lb=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        segs[cnt++]=seg(x1,x2,y1,<span class="number">1</span>);</span><br><span class="line">        segs[cnt++]=seg(x1,x2,y2,<span class="number">-1</span>);</span><br><span class="line">        ub=<span class="built_in">max</span>(ub,x2);</span><br><span class="line">        lb=<span class="built_in">min</span>(lb,x1);        </span><br><span class="line">    &#125;</span><br><span class="line">    sort(segs,segs+cnt);</span><br><span class="line">    build(lb,ub,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">        update(segs[i].tag,segs[i].lef,segs[i].rig<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        ans+=<span class="built_in">abs</span>(ns[<span class="number">1</span>].len-last);        <span class="comment">//当前的ns[1].len包括上一次统计的区间长度,因此需要减去last </span></span><br><span class="line">        last=ns[<span class="number">1</span>].len;</span><br><span class="line">        ans+=(segs[i+<span class="number">1</span>].h-segs[i].h)*<span class="number">2</span>*ns[<span class="number">1</span>].num;        <span class="comment">//ns[1]为当前扫描线下区间的线段数目 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/HDU-1255" rel="external nofollow noopener noreferrer" target="_blank">HDU1255 覆盖的面积</a></p>
<p>扫描线计算被覆盖两次及以上的覆盖面积。$cover_cnt$表示的是被完全覆盖的区间的长度。当一个区间被完全覆盖的次数大于等于2时，其二次覆盖长度就是其区间长度；当被完全覆盖的次数为1时，其二次覆盖长度为左儿子与右儿子的一次覆盖面积的和；若以上两种情况都不符合，那就由左儿子和右儿子的二次覆盖面积转移得到。</p>
<p>另外，这题需要离散化。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> lef,rig;</span><br><span class="line">    <span class="keyword">double</span> hei;</span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    seg()&#123;&#125;</span><br><span class="line">    seg(<span class="keyword">double</span> lef,<span class="keyword">double</span> rig,<span class="keyword">double</span> hei,<span class="keyword">int</span> tag)</span><br><span class="line">        :lef(lef),rig(rig),hei(hei),tag(tag)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> seg&amp; se) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hei&lt;se.hei;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">seg segs[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>        <span class="comment">//线段树节点,表示一个区间</span></span><br><span class="line">    <span class="keyword">int</span> lef,rig;</span><br><span class="line">    <span class="keyword">double</span> len,len2;</span><br><span class="line">    <span class="keyword">int</span> cover_cnt;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig)</span><br><span class="line">        :lef(lef),rig(rig)&#123;</span><br><span class="line">            len=<span class="number">0</span>;cover_cnt=<span class="number">0</span>;len2=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node ns[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="keyword">double</span> xs[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ns[rt].lef=lef;ns[rt].rig=rig;</span><br><span class="line">    ns[rt].len=ns[rt].len2=<span class="number">0</span>;</span><br><span class="line">    ns[rt].cover_cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ns[rt].cover_cnt)&#123;</span><br><span class="line">        ns[rt].len=xs[ns[rt].rig+<span class="number">1</span>]-xs[ns[rt].lef];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ns[rt].lef==ns[rt].rig)&#123;</span><br><span class="line">        ns[rt].len=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ns[rt].len=ns[rt&lt;&lt;<span class="number">1</span>].len+ns[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ns[rt].cover_cnt&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        ns[rt].len2=xs[ns[rt].rig+<span class="number">1</span>]-xs[ns[rt].lef];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ns[rt].lef==ns[rt].rig)&#123;</span><br><span class="line">        ns[rt].len2=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ns[rt].cover_cnt==<span class="number">1</span>)&#123;</span><br><span class="line">        ns[rt].len2=ns[rt&lt;&lt;<span class="number">1</span>].len+ns[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ns[rt].len2=ns[rt&lt;&lt;<span class="number">1</span>].len2+ns[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ns[rt].lef==lef&amp;&amp;ns[rt].rig==rig)&#123;</span><br><span class="line">        ns[rt].cover_cnt+=val;</span><br><span class="line">        pushup(rt);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(ns[rt].lef)+(ns[rt].rig-ns[rt].lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(rig&lt;=mid)&#123;</span><br><span class="line">        update(val,lef,rig,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lef&gt;mid)&#123;</span><br><span class="line">        update(val,lef,rig,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        update(val,lef,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        update(val,mid+<span class="number">1</span>,rig,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">double</span> arr[],<span class="keyword">double</span> key,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lef=<span class="number">0</span>;<span class="keyword">int</span> rig=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lef&lt;=rig)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]==key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&lt;key)</span><br><span class="line">            lef=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rig=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rig;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        mst(xs,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> x1,y1,x2,y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf %lf %lf %lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            segs[cnt]=seg(x1,x2,y1,<span class="number">1</span>);       <span class="comment">//下位</span></span><br><span class="line">            xs[cnt++]=x1;</span><br><span class="line">            segs[cnt]=seg(x1,x2,y2,<span class="number">-1</span>);</span><br><span class="line">            xs[cnt++]=x2;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(xs,xs+cnt);</span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;cnt;i++)</span></span><br><span class="line"><span class="comment">//            cout&lt;&lt;xs[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;"\n";</span></span><br><span class="line">        sort(segs,segs+cnt);</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cnt;i++)</span><br><span class="line">            <span class="keyword">if</span>(xs[i]!=xs[i<span class="number">-1</span>])</span><br><span class="line">                xs[idx++]=xs[i];</span><br><span class="line">        build(<span class="number">0</span>,idx<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> lx=binary(xs,segs[i].lef,idx);</span><br><span class="line">            <span class="keyword">int</span> rx=binary(xs,segs[i].rig,idx)<span class="number">-1</span>;</span><br><span class="line">            update(segs[i].tag,lx,rx,<span class="number">1</span>);</span><br><span class="line">            ans+=(segs[i+<span class="number">1</span>].hei-segs[i].hei)*(ns[<span class="number">1</span>].len2);</span><br><span class="line"><span class="comment">//            printf("ans+: %.2lf\n",(segs[i+1].hei-segs[i].hei)*(ns[1].len2));</span></span><br><span class="line"><span class="comment">//            printf("ns[1].len2: %.2lf\n",ns[1].len2);</span></span><br><span class="line"><span class="comment">//            printf("segs[i+1].hei-segs[i].hei: %.2lf\n\n",segs[i+1].hei-segs[i].hei);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vjudge.net/problem/HDU-1542" rel="external nofollow noopener noreferrer" target="_blank">HDU1542 Atlantis</a></p>
<p>扫描线最经典的应用，求矩形的面积并。线段树维护区间的被覆盖长度，然后根据扫描线高度差计算面积即可。另外，本题需要离散化。<br>代码如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> lef;<span class="keyword">double</span> rig;</span><br><span class="line">    <span class="keyword">double</span> hei;<span class="keyword">int</span> tag;</span><br><span class="line">    <span class="comment">//tag=1表示下位边,tag=-1表示上位边</span></span><br><span class="line">    seg()&#123;</span><br><span class="line">    &#125; </span><br><span class="line">    seg(<span class="keyword">double</span> lef,<span class="keyword">double</span> rig,<span class="keyword">double</span> hei,<span class="keyword">int</span> tag)</span><br><span class="line">        :lef(lef),rig(rig),hei(hei),tag(tag)&#123;</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> seg&amp; se) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hei&lt;se.hei;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">seg segs[maxn];</span><br><span class="line"><span class="keyword">double</span> X[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> vis[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">double</span> sum[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[rt])</span><br><span class="line">        sum[rt]=X[r+<span class="number">1</span>]-X[l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r)</span><br><span class="line">        sum[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> val,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=lef&amp;&amp;rig&lt;=R)&#123;</span><br><span class="line">        vis[rt]+=val;</span><br><span class="line">        pushup(lef,rig,rt);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">        update(L,R,val,lson);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">        update(L,R,val,rson);</span><br><span class="line">    pushup(lef,rig,rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">double</span> todo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Lef,Rig;</span><br><span class="line">    Lef=<span class="number">0</span>;Rig=idx<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(Lef&lt;=Rig)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=Lef+(Rig-Lef)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(X[mid]&gt;todo)</span><br><span class="line">            Rig=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Lef=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Rig;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> x1,y1,x2,y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf %lf %lf %lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2); </span><br><span class="line">            segs[cnt]=seg(x1,x2,y1,<span class="number">1</span>);</span><br><span class="line">            X[cnt++]=x1;</span><br><span class="line">            segs[cnt]=seg(x1,x2,y2,<span class="number">-1</span>);</span><br><span class="line">            X[cnt++]=x2;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(segs,segs+cnt);</span><br><span class="line">        sort(X,X+cnt);</span><br><span class="line">        idx=<span class="number">1</span>;<span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cnt;i++)</span><br><span class="line">            <span class="keyword">if</span>(X[i]!=X[i<span class="number">-1</span>])</span><br><span class="line">                X[idx++]=X[i];</span><br><span class="line">        mst(sum,<span class="number">0</span>);mst(vis,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> L=binary(segs[i].lef);</span><br><span class="line">            <span class="keyword">int</span> R=binary(segs[i].rig)<span class="number">-1</span>;</span><br><span class="line">            update(L,R,segs[i].tag,<span class="number">0</span>,idx<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            ans+=sum[<span class="number">1</span>]*(segs[i+<span class="number">1</span>].hei-segs[i].hei);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Test case #%d\n"</span>,++kase);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Total explored area: %.2lf\n\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://cn.vjudge.net/problem/HDU-3642" rel="external nofollow noopener noreferrer" target="_blank">HDU3642 Get the Treasury</a><br>题意是求在三维空间中，有若干个矩形区域，求重叠次数大于等于3的区域的体积。<br>思路是用线段树维护单个平面被覆盖次数大于等于3的平面区域的面积，然后枚举z轴上的高度差，进而算出面积（z的范围并不大，可以枚举）<br>具体见代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout&lt;&lt;<span class="meta-string">"debug"</span>&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2500</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lef,rig;</span><br><span class="line">    <span class="keyword">int</span> hei;</span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    seg()&#123;&#125;</span><br><span class="line">    seg(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> hei,<span class="keyword">int</span> tag)</span><br><span class="line">        :lef(lef),rig(rig),hei(hei),tag(tag)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> h,<span class="keyword">int</span> tt)</span></span>&#123;</span><br><span class="line">        lef=l;rig=r;hei=h;</span><br><span class="line">        tag=tt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> seg&amp; se)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hei&lt;se.hei;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lef,rig;</span><br><span class="line">    <span class="keyword">int</span> len,len2,len3;    </span><br><span class="line">    <span class="keyword">int</span> cover_cnt;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line"><span class="comment">//    node(int lef,int rig)</span></span><br><span class="line"><span class="comment">//        :lef(lef),rig(rig)&#123;len=len2=len3=cover_cnt=0;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">point</span>(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span><br><span class="line">        :x(x),y(y),z(z)&#123;&#125;</span><br><span class="line">    <span class="built_in">point</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node tree[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="built_in">point</span> ps[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> xs[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> zs[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line">seg segs[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[rt].lef=lef;tree[rt].rig=rig;</span><br><span class="line">    tree[rt].len=tree[rt].len2=tree[rt].len3=tree[rt].cover_cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[rt].cover_cnt&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">        tree[rt].len3=xs[tree[rt].rig+<span class="number">1</span>]-xs[tree[rt].lef];</span><br><span class="line">        tree[rt].len2=tree[rt].len=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tree[rt].cover_cnt&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        tree[rt].len3=tree[rt&lt;&lt;<span class="number">1</span>].len3+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len3+tree[rt&lt;&lt;<span class="number">1</span>].len2+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len2+tree[rt&lt;&lt;<span class="number">1</span>].len+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line">        tree[rt].len2=xs[tree[rt].rig+<span class="number">1</span>]-xs[tree[rt].lef]-tree[rt].len3;</span><br><span class="line">        tree[rt].len=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tree[rt].cover_cnt&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        tree[rt].len3=tree[rt&lt;&lt;<span class="number">1</span>].len3+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len3+tree[rt&lt;&lt;<span class="number">1</span>].len2+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len2;</span><br><span class="line">        tree[rt].len2=tree[rt&lt;&lt;<span class="number">1</span>].len+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line">        tree[rt].len=xs[tree[rt].rig+<span class="number">1</span>]-xs[tree[rt].lef]-tree[rt].len2-tree[rt].len3;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tree[rt].len3=tree[rt&lt;&lt;<span class="number">1</span>].len3+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len3;</span><br><span class="line">        tree[rt].len2=tree[rt&lt;&lt;<span class="number">1</span>].len2+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len2;</span><br><span class="line">        tree[rt].len=tree[rt&lt;&lt;<span class="number">1</span>].len+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==tree[rt].lef&amp;&amp;rig==tree[rt].rig)&#123;</span><br><span class="line">        tree[rt].cover_cnt+=val;</span><br><span class="line">        pushup(rt);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(tree[rt].lef)+(tree[rt].rig-tree[rt].lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(rig&lt;=mid)&#123;</span><br><span class="line">        update(val,lef,rig,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lef&gt;mid)&#123;</span><br><span class="line">        update(val,lef,rig,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        update(val,lef,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        update(val,mid+<span class="number">1</span>,rig,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        tree[i].cover_cnt=tree[i].lef=tree[i].rig=<span class="number">0</span>;</span><br><span class="line">        tree[i].len=tree[i].len2=tree[i].len3=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        init(<span class="number">2005</span>);</span><br><span class="line">        mst(xs,<span class="number">0</span>);mst(zs,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x1,y1,z1;</span><br><span class="line">            <span class="keyword">int</span> x2,y2,z2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d %d"</span>,&amp;x1,&amp;y1,&amp;z1,&amp;x2,&amp;y2,&amp;z2);</span><br><span class="line">            xs[cnt]=x1;xs[cnt+<span class="number">1</span>]=x2;</span><br><span class="line">            zs[cnt]=z1;zs[cnt+<span class="number">1</span>]=z2;</span><br><span class="line">            ps[cnt]=<span class="built_in">point</span>(x1,y1,z1);ps[cnt+<span class="number">1</span>]=<span class="built_in">point</span>(x2,y2,z2);</span><br><span class="line">            cnt+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(xs,xs+cnt);</span><br><span class="line">        sort(zs,zs+cnt);</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cnt;i++)</span><br><span class="line">            <span class="keyword">if</span>(xs[i]!=xs[i<span class="number">-1</span>])</span><br><span class="line">                xs[idx++]=xs[i];</span><br><span class="line">        <span class="keyword">int</span> idx1=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cnt;i++)</span><br><span class="line">            <span class="keyword">if</span>(zs[i]!=zs[i<span class="number">-1</span>])</span><br><span class="line">                zs[idx1++]=zs[i];</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx1<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;j+=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ps[j].z&lt;=zs[i]&amp;&amp;ps[j+<span class="number">1</span>].z&gt;zs[i])&#123;</span><br><span class="line">                    segs[k++].<span class="built_in">set</span>(ps[j].x,ps[j+<span class="number">1</span>].x,ps[j].y,<span class="number">1</span>);</span><br><span class="line">                    segs[k++].<span class="built_in">set</span>(ps[j].x,ps[j+<span class="number">1</span>].x,ps[j+<span class="number">1</span>].y,<span class="number">-1</span>);</span><br><span class="line">                    <span class="comment">// segs[k++]=seg(ps[j].x,ps[j+1].x,ps[j].y,1);</span></span><br><span class="line">                    <span class="comment">// segs[k++]=seg(ps[j].x,ps[j+1].x,ps[j+1].y,-1);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            init(idx<span class="number">-1</span>);</span><br><span class="line">            sort(segs,segs+k);</span><br><span class="line">            build(<span class="number">0</span>,idx<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            ll tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> lx=lower_bound(xs,xs+idx,segs[j].lef)-xs;</span><br><span class="line">                <span class="keyword">int</span> rx=lower_bound(xs,xs+idx,segs[j].rig)-xs<span class="number">-1</span>;</span><br><span class="line">                update(segs[j].tag,lx,rx,<span class="number">1</span>);</span><br><span class="line">                tmp+=(ll)tree[<span class="number">1</span>].len3*(ll)(segs[j+<span class="number">1</span>].hei-segs[j].hei);</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=(ll)tmp*(ll)(zs[i+<span class="number">1</span>]-zs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)</span><br><span class="line">            ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>,++kase,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">4 5 0 8 9 5</span></span><br><span class="line"><span class="comment">0 3 3 4 5 7</span></span><br><span class="line"><span class="comment">5 4 4 10 6 9</span></span><br><span class="line"><span class="comment">5 5 5 9 9 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>看了一下，虽然专题里面有区间合并的题目，但我并不是用正统的区间合并的方法做的啊……所以说这方面还需要再好好学一下呢。</p>
]]></content>
  </entry>
  <entry>
    <title>线段树与树状数组总结</title>
    <url>/2020/02/05/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://pic.downk.cc/item/5e3adbdf2fb38b8c3ccee2f7.jpg" alt><br><a id="more"></a><br>本文章为2020年寒训用资料，有部分删减</p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>问题引入：</p>
<ul>
<li>问题一：给定一个长度为$n$的数列，可以进行$m$次询问，每次询问查询区间$[l,r]$内所有数的和<ul>
<li>如果数据范围很小（例如$n\leq 1000,m\leq 100$），可以直接枚举。复杂度$O(n)$</li>
<li>如果数据范围较大（例如$n\leq 1e6,m\leq 1e3$），可以用前缀和。复杂度$O(n+m)$</li>
</ul>
</li>
<li>问题二：给定一个长度为$n$的数列，可以进行$m$次操作，操作分两种，一种是修改单点的数值，另一种是查询区间$[l,r]$内所有数的和<ul>
<li>如果数据范围很小，依然可以枚举。复杂度$O(n)$</li>
<li>但大数据范围的情况下会TLE</li>
<li>此时即使使用前缀和，在进行修改操作后需要维护前缀和，故复杂度与枚举一致。大数据范围的情况下依然会TLE</li>
</ul>
</li>
<li>问题三：给定一个长度为$n$的数列，可以进行$m$次操作，操作分两种，一种是修改区间$[l,r]$内每个数的数值，另一种是查询区间$[l,r]$内所有数的和<ul>
<li>数据范围小的话当然可以枚举……</li>
<li>如果数据范围很大呢？（例如$n\leq 1e6,m\leq 1e3$）</li>
</ul>
</li>
</ul>
<h3 id="线段树是什么"><a href="#线段树是什么" class="headerlink" title="线段树是什么"></a>线段树是什么</h3><p>线段树是一种二叉树，它的基本思想是在二叉树的节点上保存区间信息，并在树上进行区间\单点的修改和查询。下图是区间$[1,7]$对应的线段树</p>
<p><img src="https://pic.downk.cc/item/5e3ada242fb38b8c3cceb6bb.png" alt></p>
<p>上面这张图所表示的意思是，以求区间和为例，对于区间$[1,7]$，其区间和等于其左儿子$([1,4])$的区间和加上其右儿子$[5,7]$的区间和；而区间$[1,4]$的区间和又等于区间$[1,2]$和区间$[3,4]$的和。对于一个区间$[lef,rig]$，其左右儿子分别为$[lef,\lfloor(lef+rig)/2\rfloor]$，$[\lfloor(lef+rig)/2\rfloor+1,rig]$。对于线段树上的各节点，我们采取从上到下、从左往右的编号方法。具体而言，以上图为例，$[1,7]$是编号为1，$[1,4]$编号为2，$[5,7]$编号为3……</p>
<p>对于查询与修改，线段树的复杂度都是$O(\log_2n)$</p>
<h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>根据线段树的结构和节点编号方式，我们很容易得到以下建树方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</span><br><span class="line">        sum[rt]=tmp;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(lef+rig)/<span class="number">2</span>;</span><br><span class="line">    build(lef,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>,rig,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很短，但有些地方可能会让初次接触的人稍微有点疑惑：</p>
<ul>
<li><p>maxn&lt;&lt;2是什么意思？</p>
<p>此处maxn表示的是最大区间长度，maxn&lt;&lt;2等同于4 * maxn。sum是用来存我们的线段树节点的数组。为什么需要开4倍大的空间呢？首先，线段树是一棵完全二叉树，  对于一棵完全二叉树，假如有$n$个叶子节点（对应到线段树上就是区间总长度为$n$），其总节点数为$2n-1$。似乎开2倍就够了呢……但经验告诉我们，开四倍是较为保险的选择，既不会太大导致MLE，也不会太小导致越界。</p>
</li>
<li><p>rt&lt;&lt;1和rt&lt;&lt;1|1</p>
<p>由于线段树节点的编号方式，父节点和其两个子节点的编号存在这样的关系：<script type="math/tex">id_{leftson}=2\times id_{father}</script>，<script type="math/tex">id_{rigson}=2\times id_{father}+1</script></p>
<p>为了提高速度，我们使用位运算来代替乘法、加法。</p>
</li>
<li><p>pushup</p>
<p>父亲节点的信息来自于两个子节点，故在完成子节点的建立后，我们要用两个子节点来建立父亲节点</p>
</li>
</ul>
<h3 id="单点操作"><a href="#单点操作" class="headerlink" title="单点操作"></a>单点操作</h3><p>单点操作包括单点查询与单点修改</p>
<h4 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h4><p>单点查询的大致思想与二分查找类似。如果需要查询的位置$pos$在当前区间的左侧，则查找当前区间的左儿子；否则，查找当前区间的右儿子。重复这一过程，直至区间左右端点相等，则说明已经找到。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        ans=sum[rt];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(lef+rig)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid) query(pos,lef,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pos&gt;mid) query(pos,mid+<span class="number">1</span>,rig,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><p>单点修改代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> val,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">        sum[rt]+=val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(lef+rig)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid) update(pos,val,lef,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pos&gt;mid) update(pos,val,mid+<span class="number">1</span>,rig,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与单点查询基本一致，但要记得最后pushup一下来更新父节点。</p>
<h3 id="区间操作"><a href="#区间操作" class="headerlink" title="区间操作"></a>区间操作</h3><p>区间操作的总体思想是，对于带查询的区间$[L,R]$，如果当前区间$[lef,rig]$完全包含在带查询区间中，就直接将$[lef,rig]$上的信息统计到答案中。如下所示</p>
<script type="math/tex; mode=display">
\underbrace{L,L+1,\dots \overbrace{lef,lef+1,\dots ,rig-1,rig}\dots ,R-1,R}</script><p>否则，如果当前区间不是完全包含在待查询区间内，就查询左儿子或右儿子。如下所示</p>
<script type="math/tex; mode=display">
\rlap{\overbrace{\phantom{lef,lef+1,\dots,L,L+1,\dots,rig-1,rig}}} lef,lef+1,\dots, \underbrace{L, L+1,\dots,rig-1,rig,\dots,R-1,R}</script><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>借用上面所提到的总体思想，可以写出这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef&gt;=L&amp;&amp;rig&lt;=R)&#123;</span><br><span class="line">           <span class="keyword">return</span> sum[rt];     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(lef+rig)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) ret+=query(L,R,lef,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) ret+=query(L,R,mid+<span class="number">1</span>,rt&lt;&lt;<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><p>借用单点修改的思想，很容易想到，区间修改就是相当于调用多次单点修改，把区间内的数字都修改了。举个例子，对于区间$[1,7]$，如果我们要修改$[2,7]$内的数，那最终被修改的节点如下图所示<br><img src="https://pic.downk.cc/item/5e3ada522fb38b8c3ccebc1d.png" alt></p>
<p>一个很明显的问题在于，这样做的话，复杂度会比直接暴力修改还高！而且，如果我要查询的只是$[5,7]$的子区间，那就会存在不必要的修改。比如说我要查询$[1,5]$，那$[5,6]$等等的修改就没有用。</p>
<p>事实上，要修改区间$[2,7]$，我们可以仅仅修改我们需要的区间。具体而言，修改的时候只需要修改$[1,7],[1,4],[1,2],[2,2],[3,4],[5,7]$。等到需要查询这些区间以外的区间时，再去进行相应的修改。这就是懒惰标记（lazy tag）的思想</p>
<p>所谓懒惰，就是“要用的时候才用，否则就不用”。具体来说，懒惰标记用于存储父节点的修改信息，但暂时不把信息传给子节点，等到需要用到子节点时再把信息传给子节点。</p>
<p>加上了懒惰标记的区间修改代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt])&#123;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]+=lazy[rt];</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>]=lazy[rt&lt;&lt;<span class="number">1</span>]*(len-(len&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        lazy[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> val,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef&gt;=L&amp;&amp;rig&lt;=R)&#123;</span><br><span class="line">        sum[rt]+=val*(rig-lef+<span class="number">1</span>);</span><br><span class="line">        lazy[rt]+=val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=(lef+rig)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) update(L,R,val,lef,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) update(L,R,val,mid+<span class="number">1</span>);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上懒惰标记后，同样是修改$[2,7]$这一区间，被修改的区间如下所示：</p>
<p><img src="https://pic.downk.cc/item/5e3ada6a2fb38b8c3ccebf3e.png" alt></p>
<p>另外，在引入了懒惰标记后，单点查询、区间查询的代码也要更改（其实就是加上pushdown而已）。具体如下：</p>
<p>单点查询：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)&#123;</span><br><span class="line">           <span class="keyword">return</span> sum[rt];     </span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(lef+rig)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef&lt;=mid) ret+=query(pos,lef,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rig&gt;mid) ret+=query(pos,mid+<span class="number">1</span>,rig,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区间查询：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=lef&amp;&amp;R&lt;=rig)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(lef+rig)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) ret+=query(L,R,lef,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) ret+=query(L,R,mid+<span class="number">1</span>,rig,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="减法运算和乘法运算"><a href="#减法运算和乘法运算" class="headerlink" title="减法运算和乘法运算"></a>减法运算和乘法运算</h3><p>上面所提到的都是修改与查询都是基于加法的，那如果是减法、乘法、除法呢？</p>
<ul>
<li><p>如果是减法的话就直接加上负数即可。</p>
</li>
<li><p>如果是乘法或除法的话，就要另当别论。</p>
<p>（此处只讨论区间查询与区间修改，如果区间的会了，单点肯定也会吧 :D）</p>
<ul>
<li><p>对于乘法，只需要像这个样子修改update：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> val,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lef&gt;=L&amp;&amp;rig&lt;=R)&#123;</span><br><span class="line">        lazy[rt]*=val;</span><br><span class="line">        sum[rt]*=lazy[rt];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=(lef+rig)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) update(L,R,val,lson);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) update(L,R,val,rson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样修改pushdown：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt]!=<span class="number">1</span>)&#123;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]*=lazy[rt];</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*=lazy[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>]=sum[rt&lt;&lt;<span class="number">1</span>]*lazy[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*lazy[rt];</span><br><span class="line">        lazy[rt]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外要记得初始化lazy中所有数为1</p>
<p>PS：思考一下，如果是乘法和加法同时进行，即区间修改操作中，既可以将区间上的数乘以一个数，也可以将区间上的数加上一个数，那要怎么维护sum和lazy呢？</p>
</li>
</ul>
</li>
</ul>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>所谓离散化指的是，在某些情况下，由于数据范围过大，直接保存数据的做法会导致MLE；但要解出题目其实并不需要保存实际的数据，只需要保存数据之间的相对大小即可。举个例子，现在要在一条长度为$1e9$的线段上进行区间染色，颜色与颜色之间会相互覆盖，求最终线段上可以看到多少种颜色。显然，我们不可能开一个长度为$4e9$的数组来存线段树节点，也不可能开一个长度为$4e9$的数组来存懒惰标记。如何解决这一问题呢？注意到，我们现在其实并不关心被染色的线段具体有多长，而只关心线段之间的关系（相对大小，位置关系）。所以我们可以为每一个需要染色的区间的左右端点分配一个id，并通过id来建立线段树。所有的修改与查询都在这棵”id线段树“上进行。离散化的实际实现一般通过sort()和unique。</p>
<p>下面用一道例题来讲解：</p>
<p><a href="http://poj.org/problem?id=2528" rel="external nofollow noopener noreferrer" target="_blank">Mayor’s posters</a></p>
<p>题目大意是说，有一堵长为10000000，现在要在墙上贴$n(1\leq n\leq 10000)$张海报（海报与海报之间会相互覆盖），问贴完所有海报后，能看到的海报有多少张？</p>
<p>与上面提到的染色问题思路一致，将每张海报离散化后，用离散化得到的id建立线段树，并通过query查询能看到的海报的数目。完成离散化后，通过lower_bound()查询左右端点对应的id。</p>
<p>参考代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset((a),(b),sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">"debug\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lef,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,rig,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">10000</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> lazy[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lef;</span><br><span class="line">    <span class="keyword">int</span> rig;</span><br><span class="line">&#125;;</span><br><span class="line">node ps[<span class="number">20000</span>+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt]!=<span class="number">0</span>)&#123;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]=lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=lazy[rt];</span><br><span class="line">        lazy[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> toL,<span class="keyword">int</span> toR,<span class="keyword">int</span> todo,<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=lef&amp;&amp;toR&gt;=rig)&#123;</span><br><span class="line">        lazy[rt]=todo;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(toL&lt;=mid)</span><br><span class="line">        update(toL,toR,todo,lson);</span><br><span class="line">    <span class="keyword">if</span>(toR&gt;mid)</span><br><span class="line">        update(toL,toR,todo,rson);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> lef,<span class="keyword">int</span> rig,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[lazy[rt]])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            vis[lazy[rt]]=<span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lef==rig)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=lef+(rig-lef)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(lef&lt;=mid)</span><br><span class="line">        query(lson);</span><br><span class="line">    <span class="keyword">if</span>(rig&gt;mid)</span><br><span class="line">        query(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lsh[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        mst(lsh,<span class="number">0</span>);</span><br><span class="line">        mst(lazy,<span class="number">0</span>);mst(vis,<span class="number">0</span>);</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;ps[i].lef,&amp;ps[i].rig);</span><br><span class="line">            lsh[idx++]=ps[i].lef;lsh[idx++]=ps[i].rig;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(lsh,lsh+idx);</span><br><span class="line">        <span class="keyword">int</span> cnt=unique(lsh,lsh+idx)-lsh;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> L=lower_bound(lsh,lsh+cnt,ps[i].lef)-lsh+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R=lower_bound(lsh,lsh+cnt,ps[i].rig)-lsh+<span class="number">1</span>;</span><br><span class="line">            update(L,R,i+<span class="number">1</span>,<span class="number">1</span>,cnt+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        query(<span class="number">1</span>,cnt+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>拓展内容包括：</p>
<ul>
<li><p>区间除、维护区间平方和、维护区间立方和、区间位运算…</p>
</li>
<li><p>扫描线</p>
</li>
<li>权值线段树</li>
<li>主席树</li>
<li>etc…</li>
</ul>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>所谓树状数组，就是用数组来模拟树形结构，常用于解决一些区间问题（区间加、区间求和等）。相较于线段树，其优点在于常数更小，且代码更短。缺点在于功能比较有限，对于一些复杂的区间问题很难解决，甚至是无法解决。可以说，能用树状数组解决的问题都能用线段树解决，但能用线段树解决的问题不一定能用树状数组解决。</p>
<h3 id="辅助数组c与lowbit"><a href="#辅助数组c与lowbit" class="headerlink" title="辅助数组c与lowbit"></a>辅助数组c与lowbit</h3><p>首先，定义一个序列$a_n$，其长度为$n(1\leq n\leq1e6)$，可进行$m(1\leq m \leq 1e3)$次操作，每次操作要么是对一个数加上一个数值（单点修改），要么是查询一段区间内的总和（区间查询）。</p>
<p>这一问题当然可以用上面所说的线段树来解决，但现在我们引入树状数组。</p>
<p>首先定义函数$lowbit(x)$，有</p>
<script type="math/tex; mode=display">
lowbit(x)=x\&(-x)</script><p>$lowbit(x)$的具体含义在于，求出<script type="math/tex">x</script>最低位1所对应的值。比方说，<script type="math/tex">lowbit(10100_2)=100_2=4_{10}</script>，<script type="math/tex">lowbit(10001111_2)=1_2=1_{10}</script>，<script type="math/tex">lowbit(100010_2)=10_2=2_{10}</script></p>
<p>再定义一个辅助数组$c_i$，有</p>
<script type="math/tex; mode=display">
c_i=a_{i}+a_{i-1}+\dots+a_{i-lowbit(i)+1}</script><p>也就是说，c[i]表示的是, 从a[i]开始，一直到 a[i-lowbit(i)+1] 这一长度为lowbit(i) 的连续区间的总和。如下图</p>
<p><img src="https://pic.downk.cc/item/5e3adb222fb38b8c3cced2a6.png" alt></p>
<p>构建出来的树状数组大致长下面这个样子</p>
<p><img src="https://pic.downk.cc/item/5e3adb452fb38b8c3cced59d.jpg" alt></p>
<h3 id="修改与查询"><a href="#修改与查询" class="headerlink" title="修改与查询"></a>修改与查询</h3><p>此处只考虑单点修改和区间查询。</p>
<ul>
<li><p>单点修改：当我们要修改<script type="math/tex">a_j</script>的时候，因为有<script type="math/tex">c_i=a_i+a_{i-1}+\dots+a_{i-lowbit(i)+1}</script>，所以修改一个数可能会导致多个<script type="math/tex">c_i</script>的改变。所以我们这么编写单点修改的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        c[i]+=val;</span><br><span class="line">        i+=lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于区间查询，$c_i$的定义让我们想到，是否可以通过求前缀和的方法求区间和。因此，查询的代码可以这样编写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ans+=c[i];</span><br><span class="line">        i-=lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过观察修改、查询的代码，以及树状数组的结构，我们可以看出，树状数组其实巧用二进制来对整个序列进行分段。以一个长度为7的序列为例，有</p>
<script type="math/tex; mode=display">
\begin{aligned}
lowbit(1)&=1,c_1=a_1;\\
lowbit(2)&=2,c_2=a_2+a_1;\\
lowbit(3)&=1,c_2=a_3;\\
lowbit(4)&=4,c_4=a_4+a_3+a_2+a_1;\\
lowbit(5)&=1,c_5=a_5;\\
lowbit(6)&=2,c_6=a_6+a_5;\\
lowbit(7)&=1,c_7=a_7;
\end{aligned}</script><p>我们把这些数据套到query()代码中，可以发现，加上的$c[i]$分别是$c[7],c[6],c[4]$，也就是$a[7],a[6]+a[5],a[4]+a[3]+a[2]+a[1]$这三段。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统三（二）——指令</title>
    <url>/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="https://pic.downk.cc/item/5f928ffc1cd1bbb86bf44e2f.jpg" alt></p>
<h4 id="MIPS寄存器"><a href="#MIPS寄存器" class="headerlink" title="MIPS寄存器"></a>MIPS寄存器</h4><p><img src="https://pic.downk.cc/item/5f928fc01cd1bbb86bf44392.png" alt></p>
<h4 id="MIPS指令表"><a href="#MIPS指令表" class="headerlink" title="MIPS指令表"></a>MIPS指令表</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">加法</td>
<td style="text-align:center">add $s1,$s2,$s3</td>
<td style="text-align:center">$s1=$s2+$s3</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">减法</td>
<td style="text-align:center">sub $s1,$s2,$s3</td>
<td style="text-align:center">$s1=$s2-$s3</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">立即数加法</td>
<td style="text-align:center">addi $s1,$s2,20</td>
<td style="text-align:center">$s1=$2+20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">取字</td>
<td style="text-align:center">lw $s1,20($s2)</td>
<td style="text-align:center">$s1=memory[$s2+20]</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">存字</td>
<td style="text-align:center">sw $s1,20($s2)</td>
<td style="text-align:center">memory[$s2+20]=$s1</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">取半字</td>
<td style="text-align:center">lh $s1,20($s2)</td>
<td style="text-align:center">memory[$s2+20]=$s1</td>
<td style="text-align:center">从地址20($s2)开始取半字（16biwordts）（h==halfword）</td>
</tr>
<tr>
<td style="text-align:center">取无符号半字</td>
<td style="text-align:center">lhu $s1,20($s2)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">存半字</td>
<td style="text-align:center">sh $s1,20($s2)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">取字节</td>
<td style="text-align:center">lb $s1,20($s2)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">取无符号字节</td>
<td style="text-align:center">lbu $s1,20($s2)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">存字节</td>
<td style="text-align:center">sb $s1,20($s2)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">取链接字</td>
<td style="text-align:center">ll $s1,20($s2)</td>
<td style="text-align:center"></td>
<td style="text-align:center">是原子交换的前半部分</td>
</tr>
<tr>
<td style="text-align:center">存条件字</td>
<td style="text-align:center">sc $s1,20($s2)</td>
<td style="text-align:center"></td>
<td style="text-align:center">是原子交换的后半部分</td>
</tr>
<tr>
<td style="text-align:center">取立即数的最高位</td>
<td style="text-align:center">lui $s1,20</td>
<td style="text-align:center">$$s1=20*2^{16}$</td>
<td style="text-align:center">取立即数并放到高16位</td>
</tr>
<tr>
<td style="text-align:center">与</td>
<td style="text-align:center">and $s1,$s2,$s3</td>
<td style="text-align:center">$s1=$s2 &amp; $s3</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">或</td>
<td style="text-align:center">or $s1,$s2,$s3</td>
<td style="text-align:center">$s1=$s2 \</td>
<td style="text-align:center">$s3</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">或非</td>
<td style="text-align:center">or $s1,$s2,$s3</td>
<td style="text-align:center">$s1=~($s2 \</td>
<td style="text-align:center">$s3)</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">立即数与</td>
<td style="text-align:center">andi $s1,$s2,20</td>
<td style="text-align:center">$s1=$s2 &amp; 20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">立即数或</td>
<td style="text-align:center">ori $s1,$s2,20</td>
<td style="text-align:center">$s1=$s2\</td>
<td style="text-align:center">20</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">逻辑左移</td>
<td style="text-align:center">sll $s1,$s2,10</td>
<td style="text-align:center">$s1=$s2&lt;&lt;10</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">逻辑右移</td>
<td style="text-align:center">srl $s1,$s2,20</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">相等时跳转</td>
<td style="text-align:center">beq $s1,$s2,25</td>
<td style="text-align:center">if($s1==$s2) goto PC+4+100</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">不相等时跳转</td>
<td style="text-align:center">bne $s1,$s2,25</td>
<td style="text-align:center">if($s1!=$2) goto PC+4+100</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">小于时置位</td>
<td style="text-align:center">slt $s1,$s2,$s3</td>
<td style="text-align:center">if($s2&lt;$s3) $s1=1  else $s1=0</td>
<td style="text-align:center">比较是否小于</td>
</tr>
<tr>
<td style="text-align:center">无符号数比较小于时置位</td>
<td style="text-align:center">sltu $s1,$s2,$s3</td>
<td style="text-align:center">if($s2&lt;$s3) $s1=1  else $s1=0</td>
<td style="text-align:center">比较是否小于无符号数</td>
</tr>
<tr>
<td style="text-align:center">无符号数比较小于立即数时置位</td>
<td style="text-align:center">slti $s1,$s2,20</td>
<td style="text-align:center">if($s2&lt;20) $s1=1  else $s1=0</td>
<td style="text-align:center">比较是否小于常数</td>
</tr>
<tr>
<td style="text-align:center">无符号数比较小于无符号数时置位</td>
<td style="text-align:center">sltiu $s1,$s2,20</td>
<td style="text-align:center">if($s2&lt;20) $s1=1  else $s1=0</td>
<td style="text-align:center">比较是否小于无符号常数</td>
</tr>
<tr>
<td style="text-align:center">跳转</td>
<td style="text-align:center">j 2500</td>
<td style="text-align:center">goto 10000</td>
<td style="text-align:center">跳转到目标地址</td>
</tr>
<tr>
<td style="text-align:center">跳转到寄存器所指位置</td>
<td style="text-align:center">jr $ra</td>
<td style="text-align:center">goto \ra$</td>
<td style="text-align:center">用于switch语句，以及过程调用</td>
</tr>
<tr>
<td style="text-align:center">跳转并链接</td>
<td style="text-align:center">jal 2500</td>
<td style="text-align:center">$ra=PC+4; goto 10000</td>
<td style="text-align:center">用于过程调用</td>
</tr>
</tbody>
</table>
</div>
<p><strong>MIPS32指令集文档：<a href="https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00086-2B-MIPS32BIS-AFP-6.06.pdf" rel="external nofollow noopener noreferrer" target="_blank">https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00086-2B-MIPS32BIS-AFP-6.06.pdf</a></strong></p>
<h4 id="三种指令格式"><a href="#三种指令格式" class="headerlink" title="三种指令格式"></a>三种指令格式</h4><ul>
<li><p>R-型</p>
<p>|  op   |  rs   |  rt   |  rd   | shamt | funct |<br>| :—-: | :—-: | :—-: | :—-: | :—-: | :—-: |<br>| 6bits | 5bits | 5bits | 5bits | 5bits | 6bits |</p>
<p>其中：</p>
<ul>
<li>op：操作码</li>
<li>rs：第一个源寄存器编号</li>
<li>rt：第二个源寄存器编号</li>
<li>rd：destination目的寄存器编号</li>
<li>shamt：移位位数（00000表示不移位），仅在位移指令中使用</li>
<li>funct：功能码，用于选择op操作中的具体函数，如运算操作中的加法函数</li>
<li>R-型指令包括：add,sub,and,or,nor,slt,sltu,sll,srl,jr</li>
</ul>
</li>
<li><p>I-型指令</p>
<p>|  op   |  rs   |  rt   | constant or address |<br>| :—-: | :—-: | :—-: | :————————-: |<br>| 6bits | 5bits | 5bits |       16bits        |</p>
<p>其中：</p>
<ul>
<li>op：操作码</li>
<li>rs：第一个源操作数寄存器号，参与运算使用</li>
<li>rt：第二个源操作数寄存器号，参与运算使用</li>
<li>16位立即数</li>
<li>I-型指令包括：addi,lw,sw,lh,sh,lb,sb,ll,sc,lui,andi,ori,beq,bne,slti,sltiu</li>
</ul>
</li>
<li><p>J-型指令</p>
<p>|  op   | address |<br>| :—-: | :——-: |<br>| 6bits | 26bits  |</p>
<ul>
<li>目标地址计算方法：dst=PC+4+address&lt;&lt;2（下一条指令的地址时当前PC加上4后，取最高的四位，再加上J型指令编码中的26位左移2位（×4）的结果）</li>
<li>J-型指令有：j, jr, jal</li>
</ul>
</li>
<li><p>MIPS中的同步</p>
<ul>
<li><p>背景：处理器共享存储器同一区域，P1写，P2读。P1写的结果是P2要读的值，如果P1和P2不同步，将会发生数据竞争</p>
</li>
<li><p>解决方法：依赖硬件提供同步指令，即原子读/写内存操作</p>
</li>
<li><p>MIPS中靠ll和sc这两个指令实现同步</p>
<blockquote>
<p>LL 指令的功能是从内存中读取一个字，以实现接下来的 RMW（Read-Modify-Write） 操作；SC 指令的功能是向内存中写入一个字，以完成前面的 RMW 操作。LL/SC 指令的独特之处在于，它们不是一个简单的内存读取/写入的函数，当使用 LL 指令从内存中读取一个字之后，比如 LL d, off(b)，处理器会记住 LL 指令的这次操作（会在 CPU 的寄存器中设置一个不可见的 bit 位），同时 LL 指令读取的地址 off(b) 也会保存在处理器的寄存器中。接下来的 SC 指令，比如 SC t, off(b)，会检查上次 LL 指令执行后的 RMW 操作是否是原子操作（即不存在其它对这个地址的操作），如果是原子操作，则 t 的值将会被更新至内存中，同时 t 的值也会变为1，表示操作成功；反之，如果 RMW 的操作不是原子操作（即存在其它对这个地址的访问冲突），则 t 的值不会被更新至内存中，且 t 的值也会变为0，表示操作失败。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机系统三</category>
      </categories>
      <tags>
        <tag>计算机系统三</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统三（一）——计算机概要与技术</title>
    <url>/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%A6%81%E4%B8%8E%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p><img src="https://pic.downk.cc/item/5f924bd31cd1bbb86be6ec2b.jpg" alt><br><a id="more"></a></p>
<h4 id="八个伟大思想"><a href="#八个伟大思想" class="headerlink" title="八个伟大思想"></a>八个伟大思想</h4><ul>
<li>面向摩尔定律的设计</li>
<li>使用抽象简化设计</li>
<li>加速大概率时间</li>
<li>通过并行提高性能</li>
<li>通过流水线提高性能</li>
<li>存储器层次</li>
<li>通过冗余提高可靠性</li>
</ul>
<h4 id="集成电路的成本"><a href="#集成电路的成本" class="headerlink" title="集成电路的成本"></a>集成电路的成本</h4><ul>
<li>$每芯片的价格=每晶圆的价格/(每晶圆的芯片数\times 成品率)$</li>
<li>$每晶圆的芯片数\approx 晶圆面积/芯片面积$</li>
<li>$成品率=1/(1+(单位面积的瑕疵数\times芯片面积/2))^2$（经验公式）</li>
<li>芯片面积与缺陷率非线性相关<ul>
<li>晶圆成本和面积是固定的</li>
<li>缺陷率取决于制造过程</li>
<li>芯片面积取决于结构和电路设计</li>
</ul>
</li>
</ul>
<h4 id="响应时间和吞吐量"><a href="#响应时间和吞吐量" class="headerlink" title="响应时间和吞吐量"></a>响应时间和吞吐量</h4><ul>
<li><p>响应时间（也叫执行时间）</p>
<p>计算机完成某任务所需的总时间</p>
</li>
<li><p>吞吐量（也叫带宽）</p>
<p>单位时间段内完成的任务数</p>
</li>
</ul>
<h4 id="时钟周期、时钟频率与CPI（计算题）"><a href="#时钟周期、时钟频率与CPI（计算题）" class="headerlink" title="时钟周期、时钟频率与CPI（计算题）"></a>时钟周期、时钟频率与CPI（计算题）</h4><ul>
<li><p>时钟周期：从一个上升沿到下一个上升沿的时间</p>
</li>
<li><p>时钟频率=1/时钟周期</p>
</li>
<li><p>对于时钟频率，1ns的时钟周期对应1GHz的时钟频率，所以0.25ns的时钟周期对应4GHz的时钟频率</p>
</li>
<li><p>CPU时间=CPU时钟周期数×时钟周期=CPU时钟周期数×1/时钟频率</p>
</li>
<li><p>CPI：clocks per instruction，每条指令占用的平均时钟周期数</p>
</li>
<li><p>如果有n种不同类型指令，则</p>
<p>总cpu时钟周期数=$\sum_{i=1}^n(CPI_i\times C_i)$</p>
<p>加权平均CPI：CPU=$总CPU时钟周期数/指令数=\sum_{i=1}^n(CPI_i\times\frac{C_i}{指令数})$</p>
</li>
<li><p>能耗正比于：$1/2\times负载电容\times电压^2$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机系统三</category>
      </categories>
      <tags>
        <tag>计算机系统三</tag>
      </tags>
  </entry>
</search>

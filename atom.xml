<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>-xGeminix-</title>
  
  <subtitle>TayE&#39;s Blog☄️</subtitle>
  <link href="https://xtayex.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://xtayex.gitee.io/"/>
  <updated>2023-01-01T09:52:06.707Z</updated>
  <id>https://xtayex.gitee.io/</id>
  
  <author>
    <name>ReTayE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022年终总结</title>
    <link href="https://xtayex.gitee.io/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://xtayex.gitee.io/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2022-12-31T12:08:00.000Z</published>
    <updated>2023-01-01T09:52:06.707Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9289e8bf30c17d930599c92452a0207d27d353aaad94845d94d38832a19292c0">4c4fb793a45258e3086db9482db91c6c2a9e27a3846a5eddc358fffabea44d5ca27709cefa7931ef4bb89d7720e16cb8ad1526ae15cdcba04d30fb6022b5d97356b7c1b000e89cab734eb6a36d50e6308484aabc23dba4f794e254e09e8fe9c74075830bf260e4ec2a51b24c0ad30f800d392f4c45742f420733eefa3bc5fb6fca0c30531d101d42544c82e2c25f08fd2df38df70d189c77813af951b09e6078418cfe1ca13f68d7554c115838ea20553918ba9b7fbf2310e805982823e6b83e83568b635fd0f4e92bba332c6878675d67964c558a2e7c73043390600dcd19cc7ef3e9cccf58f633a4bcce0632e387508a101d0eb7827e9bccc276467ab10c071ba7ece35b51667531bfc8e6482ca7e1e3684c15068a3b195181b8a6f07c0c727aad19bc1700d2e16913d190c9a9b27a4d5bad37bfbb2fba735c1319e357f405b4c9b288ef02f0af3dd7116d3525d6d3d8d5453c6b4cd84107041bb03546669bfed2342b7434fad3db31c0b4765f0b3acbff301e22c96ecc828c13ac8f34bbf82a245819adc8f9b1a246c401cbe57dbff6ed79b482b24ae88e66038c81cfc9afba4b45559a7d8ab0e426c17a1d715fa7fad2b1aabd2eb6453d9d2872349ce96f07cf9c4176239761e3e992948f2db92b95a6809ed7b6db44d08775ced1c1642a821498437ae04464ee46db25dc7224654ed567c6c4e61363ebfbbbfee70e5cdd579061c0eaaefcd0bffdbeffde17d735959045c1ef79544c803ae512b3862255b9450f27e8edc08b6dfe55a6f5f175dd136f41cca26fe19835873e9976b61ebb3511c5731cf798000fa80def99253ddd3a14e8d9ea48e42d4e143a22923f9eb932f15951d1795b4ea0e4602f84876bf14d81402220162a4a9291606a7b6ecf2216306c363d2358f8a78ae6f8866e307fc02430924a3d3160cd48da8ee52e0d3a515000f90804140e4203d7acd1b284278832640659d4791631faff35f4a0817856fc3e774b2afbc73a1b6b49b6516f0145f69c9946ea27d08f0578289aed7cf7a73bd32b4c01cf329cdb44cbd622a84df7f0af7c8a77145c96e733266665ae97349cd3d80e9cd096fe05832bce3da1b698e0ef78735873a780342ac7fff8fd120d0ac6700287073875d29ab5090598d51aaf9a2c19362db4bfa2ee2fcb7ad3936e1eec46bf843c30cd3edcd68f08ccddc8c8f74fc81ea9a6377c1263740cb6cfca662a0bdd4ec98b56dc3976822f4c18088d178ebf31433b19fffc25f7edea65ec0e1cb1c3c4f889f0f958ddd64adf026a3fe986b605dc4e9198d9eac05884741318c91afbd3a268bfda76535d958c8f40bc119abaf1bd69b374df41896513f839a89b9e36da14e2116bcfd18d43656cfc8ceee21f5ed7483b16e22f592526f88a4b3ae9e7c541e8ce0f7417f72504b72c4f282d72b91eb181b93d092c86f9cd73223b87896276a0e6fbf2adddce7e8238c821683ea0423a36c4c52d343b0096e856faaaecaa1f6f7fe2c429b978f9545a197d07436c91f1bf4782cdf4c6c442196f717f847304095cfb9a8d53f8e8a6bc34b9930f72c350b51587ca56c1e30ce6006f37a8b9bb66c896123807932c0508096ceb19065d07e7bf4833a74130ca12af94222ed12e5282214cee227be25d842bc04b2d6154bb18d551c54ce2e305f9aff533eaeafd413342c9a79cd5e5db77b010f8f0647d4ca7b747bf4507356d841cc20e274663afdc114e4d1f31435d982d4dcd6d87bae3c57cdd73c27baf7b7f57406e60bc249d70c87e341bfa27471e3b4c8d8fa7f9646f2ae974ba36915adabbc988ea0f3d606e836da3820f2b0123b85334fa40575721b7303d4f513aa09fa2e7e2cd2519d3134ba0002e2c14521e2bf1a18b57ec19c2111b14db8c8a60eef1b5f7e49aee1433e14f8b4fdc72a84f114b481fe15c90395ef76dfc40b5cafce47736d7601bf52b933640f60317e285fa857004f561812fa8b4dfe0e4602c65d0be6064ab219a52cefa8cf046e2992f7230c7bfaad21a4f59c617eb4929977875661695d4883fc757fe1c9648096fe0372dcb388e6900cdf32ac46094609dd8c849dc26b899d5e566dac17ea273498a62a8f6154caa07f0a7004b80e6e4d2bd29daadd745307b94c5df04e3d01b950635fbd8cf0fd3e9d275045acdcf9c790cd93cb61e6c0e6fbb2757d710f29ea496e4b6c6f3d9e5b1b1ddc0c3758a6b0199239dcd0b695e828e1524608983c8f415a3a84dcbf71d28afd910b422266c383d38dec2542afd5b8e2577805eb8d24e2afc019a5bc01e74150ad6d91e22f95e90dcca1e067b6f8fdd25aa5f403b6fcf41853a68f725e8b1cdc2cd5446cac4c9a0e9c9ee67b3f16b1b467186d86a0c73cf7f9cfd32da4ea9f8f3d5bf7acef21482cdf30bb275616a2125e28bda208e7566ee1a740b7d1d8a04e6c8d801704380535963e5b68dbb3397a5e397a6d731499ed2f9e7b1c8b66175ba03244470bea9eea291393f7ca63805e5502d226861231bd70a64168d18852a9cb98552d9d88e897084f291921dcfbc3a2fcd9c44dc91f3b60212a5c7e8380b25f054f47ecf3d6fd21e1d84b936952bbebc6148be31fe7b52e08b0fdf80f3943b9b1e684ecdcf12bd2fa2a1614c4987a06dbc361e3a2a153055c6aa202c104f217d25b2c7b937c969b33b879a86aca0ba063442eca86c9b2188b3835b742cabac64ba48b6d20505c066b4d3c76def5f2331d94d40924be100810722349e074ef18dbd012ee18bae344bb0b3768ca6e0e25cd608779782f99f8d0bcce6cd8b399a02e9974350971efa545900ad122064e15f531c2a72205d805d066eaf2611e65f11bdf29466a577f3a7b2a8ec7e791c1e92ceb3687aeb0f83227fb88fb9bcca4057340a31c9ca97d4a8083ffd86fc8192495d805d29f0c560488e8df9059b2700b952f8c9ba11e367a7a2599f5429872fec45c1361042775072b13e22b6d452d5d310bf93f9e5e30d9c1eaa449bc21c64a6377506e0143ec43d63bd1cc6eb364f08fb10edf51d036ec81b1f487ebef7d72e78a93c7497c75a1cda708b4ca278a68f484913a8f6e964190dea79fd3a899435c077313c532ee8c10bc89ed56af1868f586d8131d898c935983967e7b7c0df7c4d4c453a73cefd69f3d604f926d6cabccc3284435cf60c2499503911d7f79eb97133a8cc409e1e036a63f5306d4c615cb51628f1863ac993ca05c57e35b1a14bee07afd9075cf331a65c8c9a3b5dfd7f43bcc666181ebf76d3eeb56bbf8ee59a3e5f2a157edb88e91b93379a4f9c513b92e88e2a90b7368cab9290fab1549387b3671ef65f65533978cda249c1be444614a3382c57c0c6ff1032b80ffd33664c0023b39a0055f7e87d2716375364ea807685acef5701c7206c6bf7e7b08ad36636c64452df8a877c3d36543121398c5e967dc3a6910ed9c9c97ba1c4182b8f30cc17ebc0b2c982c8c08a3177e6f3b42c4ddce82f196627a924a2977ebb3541f76fb3d1dd54f9ece5a55be8af67c1e29a2b1f0291c2bf73de3006f4c1c13b14d428bdd3100f20527999b85c30ba373cab0d15ad5c489f9a1833e7d75cd872df32ea48912aa757dd6780690526f878fe4ea51c1e605595c4ce65e817a9c240b0b403a72dc67cd94d313840be8d267b6daf5ef41aea37e45439b5fe503a174fbf564b291755df84784907ac4fbef992a5e13946828dab84d07f8fcf9bbe4b75e962c51c9cd782e59f8671bcf121fa770eb0b9ce2563938756a589eddb8f179efd25a20a27282996d2f2187e9b197a93076d5b83ae0806731979a923f48cf3e032688cada016f94cbdd00b545957442e8f51f86fd1d81755020cb0b301c795482abf99d76463fe353c5b40fb542150c2913e015b1851ce03d92e4baca976e3913a2a66e72ae415cbb1b6a79aff43f3164fa38e7688fe1dee1dad15fe7db6d912071e60a7ea99b05486ce93b58e6f1a514c438447e370b6f6747243e8a8b0bc261a350d6ef56990e15ed21e72729a06f66822dc20b17aa35968685d5c243a42efb39162ad732f726213a1d40f11fd1b2e323a00e5b6fd4c9f125d07dc06b9597ff9236d83c26b3eb1a44c89dce1922a289e22a4a40ca2fad6bdf0f323397f8dee90c0e4a4889897b46f3dcdcf2f6011f8e34721983adc61f428e220114db2be058b86c15f212a00243ed847a52a709bdc42472e0687d4781cc2d6266059798ae20f7bbab732b509adff7f33fb95dce04da9ea1acfef879b373285371e8ef11224b18aa5ffd6c3030fa241d8624877532bf95b379e7612027e06196dbb21d65fb07cb28614fca8f4a1c951fbec5f56e56bba1fbf847e2c2f773a07600ad1e990d53fb8da0c551da2c9a41a9fbd335c6b6b7e812e345821ccf1af148c969c9b19223411552bf0afd2da2fb3b39b4b7f604b82ba777ea4d963f98825287d89de2acf8d27943abdcc6d3dd9390b956b4de93579f21b8946b58875ebb97ebd5483ae2bd78d786006a6bf6cf3932bf5cf64d8a68ec31271e459614d80ca0ec23a4905293eb341d8464d5789e2d8b61f8beab19a52d76528b37d9f149d2f7240cb9b657b57a463831ab7409771765d62f53bd041eb1e504337ecf1a9aa5b39eff224ad58959f42a0b505f7632db16240c9abc0ce2f357a22f1ccc3ef743f6cc34b009347fdca954a52e1355eb122a19a474a7669e851ecc73de504c43233e420d48944b7959922ec95a659e9202599914113445ab771fb7fbb8c849af8fd4fc328acb1804cecc9e02ca02109aee7633b261adce40ca84cd1d6802d659e4a98e24b76d83745714771c4fb6fc205388dd598ee43e340210de5ef4ced76f1f90269a6b84e56506e4333e7deaa0119a097fd9862b76b35da9d64f4bf61daec34c295e52e87158a271d65d1a025875b18036507508fd56ad71493e0c502d97888f24d09dd42a639d3fda8903e29c4aaebb93f5d9434f961fdad5cdd9abde87c3b011f97069932deba37684db4fff5db9b9f1384b989b3bf1153cd074f78151cf666bfef65b7d8e7127c6793fad0771ce50e2a74739285b0cb4391aa24e6e8f67df8ab98c48b66a1d747c542ba9be09df4f6b8cac7dd15cb3561eb7b50cd3eeab328fa9633e8d27f6189fab767f4e9c3f4a87d3bde8303a8f1f84fe1697f11d514356c0d81042def7811003b11e547144de1720b9132421d7241e3f889bd33b2b981835c536dd9f597c991a7f89b587165d22be39938ac1e80d0d1585c2a5e73daf87cb7b1153a0ac7822282dcb01ad859cf01f5e237e7492de30792a9fd4ae70682d8fb77100c6480b8b86f68ec5079e6d299cd538ba4fd0982385be60d0bfa578f28e9559ee60f12aff4554e17db735c2b3a3d8ad44a5e7c81b3f0d8bb1cde2a3bf15c0fc838f6b4afcc2b612cb7958ed40fd5fce7fdd7c552849c1a69f03e3da32edc9b08768ceb61c589b564ef8f02875f7d3cd1d9aa20bc95baa09ec74d881d67c7016443af1d66215e76a90e03cb7a088bfd94e287d5b577e6f4a297499fc9ad9cd5a90d7d3436bc7631ee30b835980c71d7b341ead9d92365e0e35c85710656b2de873b4b3ce1e42a0c9cb607f47ad70dfdb4905a548bd7cf8909cb9c6e7ed2745c4202a543f2601e327a7a1e9ebec1b0441a9b5bd92da4728fea5ba70398df74de4f7064ad20b9df4e843bab868970b8c3babb5b3e6a047624673a0102deeda26720047753ffa6553807af6637f0e613ca7cfd0281877373b17effff718b9b77d3baf4a658de5dee396929acedad90186dfc1f9d5be4f24a07936f80d3b8e2f8869751c20dbd1599762efc2d8eaeebd6b59fd993d8a6cf77b6f111ace014eef74ca0e66b16aaa7bb7b7c8fe8e804f2c97623f7dfd2a3a26853c9eeebce9e947898234f17bef0c665e3ceb387740a67f45d476a671201f2e9e456e845ebf299881d05fa249eba15923dbe03c6006141cea7d450d29d3a1804f069db1ec2d6f15d51ed1f2cf729d5de492b85ebbe2f2aba17a233663e0650ebaa6882fdf556e53c1c7c60125e332153785b686d9951463d4f944b5a796fb7546c57bfefc0f83c39032c85fd3dfbb51d1c03956613f73537f588eb29c3cf0797ac8ada3acbe0d942b16ad62618d9fac56aed4f5804e23bd2aaf1774bf4243518bdd81719314c03b1d628acf0574144d02e03f19f60cb1b4ed79961f23dd58e815fdb6d69eb930a3a706d7236e64f6b3aff841b80400c571cbb137d4596a30aa85bf78cc6443666f5aef83a41987b79828a1d8ed5388678ef2383e8d3de4bf8ecfd4ac8f4db674ed71d2ed2c16c28e7e859ce15103b34fc6e20a8da7213e7346e53053fa9c53d818683c3ecd019e4bc63a803d7f9873accfd08542c371ca0a9fb650efca7fc42b52665c8a117b3cfda1f3a3ff86949feaac5c44048650068570786bf565fccd76b17a2c7746bcb0d3bd2f1b7bc5f9a6899cd16354087664c467c858373eef7d0208df33f7ec7d2f4b0a889b680350d2a6d7e4325b4ecf5d27923dba20c495d3c7e608efbc9d9f67977e26a4bbccc0894dab3cd8525f39952855e27f6f8348c19381e3b7ff0141d69a3e5e9304c1330cf07f5b83d81ddcd35f5c6792a64d3e2a613189796a6efbf95f66e4f74dca4e0092ea376aecb538d27822ee05b2f6b9a97b73844ee6a1367d506787c3c23d11d4515e3ed92c6d8f17a046a5723ff766a9b4df870cfd5cbadbccb157a220b0835dde40c9dbceab6b7e6b451e7ed60e5ce045d96d4a3b85c54c98847487ec0eef592c9e1e44f59c348092917b42fa81aa2ce55183e400bd6361bffac629fd614dd34075fb4c8100f5dc5cb2457617b49aee40cbe59de5e80c10e6596a9b440b46960f0fd4cf43244964c5739d95c2aafa6000bb05996f60ad26dd541eb6421c4881fd14ce359b14f096cf9ce0edd617c2d6cb8a31ff10b440e859a2a95e12a26cd3c4afe33acc3a31d001ae59e486c1a784ee2c5a82f74e6527a2599f73a893c0157844385424d59a62f6a3a90d5cfde3e6a257104b1adf20a32cf04cfb77e569ffd8221aa6d40b83ae85edb2f37f2f510129042e94a053d686b17cba4f0ca0e8ed2669ccba1fbe00ea2a7d54fd87b572e0936bef49d9f45ba74700e242b5be5ceabad5f3ae9f1ce99b674be47d7f1b5678f948ddcaf9de9310c05431fe7131c95e255a0f6641f2f6b6ded230a5e9909b89801524103294847c7e580e367295d57f936ab4ca742e892eeb69f94fa2e16a9ce3afc7da4c2c87dfc74e6c9e41b8dd173749e5f53a071bc1955dd49cf6bc977078e58d3cc8a09a37e81aa5ccd19885ab5c66187cdbb05427f8c4e24b46d76d2c8056e164f89a44a53b6af3b493ce796b3461abbf07cca90da8364ca87e2891c1a58a0a3a5882bc1d8e9b5ee211bc69158d91743950f91bb6cce5918098332e756788f390c0319f39a9ca7b94cf2933c8f79c34b5aab8036f7b9cec18929bdf97576af3a075badb1d7d8af89f1b94ce6349f268aed013eeaef19e7b1de3d76ef14bfdd2f10f4e3343276517f378e5c6d8eee52791e461187146dbc02ef8f5a5836c6fc56324eb672f007103b79c10180ed83c6154569727d447a069cc64aa2a725a9a40609f071860e2a706ecf66f611d17f79c14aa0580a781afdad3045a1bdf3014f32118777ed024ba01cd0e208dadb8f82a487f350ea36de1615f3776bf15911bf9f7e9d5fbd8a021d1942d2fc78e2805537623f3f080059e5626c5d2e9d0310684f77accb81817d7e2601ba5b3ce793a3a68fe63ccca07f46cab5d2b0ae43990fcf7dd03831f2e27502581b5aa5e8bf90b184320ff1da55ac7ea6c78ce9234816e9477c659c091fc882f67fb79a95d6cfb3e8f83a37c363f9961b3f7cd0ff7f554ee3604dd63f2e8b2799b009367484d93f205d8bc926910347ea03e986af9b5bcdb9404dad5bce74722478abb34bd6d6e4282895c7f3abb2f118e7468a8a8a021ff04696d6d72a9e1447da828adfb4c70816405f8a579ad6616b090a5c25db71b38697946004f0bcab88896140cc7d9039dfb8506952f2308210272d5bda8e1d291059d4b76f67893f9911cea37bd85ed788c4a3430b0ae6ae127f85fbc9522514cfd2629daf13d6ed7b3678fd22b382725a6d101cfa4ed6117de95d0969d1876308b42da526277e26d1a89968a4287032dc1ca6b55c6e392a920b3122169f31c2b2fc9318edce835405d20ca01a3b0e0aeb4434da62b8689a8aae6e3cd8046ee55cd44b9a8e848b473c9b50ef5c8f3c89ff239f4f55eb8bfdfd531c6ee60a18e430cbae979d9635e762553976611d7a3e03829b94ace5e284e214879d5c78148bc79d1d2f6102c584de4cc8b249bb9ce801236452e552deee462b3b08d1d5d579bb067842f2cd132703559ed4da979477efa6deba04302dd9c4c231b1e9207feb7b2eea9ae28639cd2b7e9b0df6cbf2e29a908f7de6b35806374498ace6daab35cfc38970d7dcfb3c1051cbff55174d5f8e71b2891a4561af1f2b10bfdd1336f8a6b2ddda49ff72f0a81ff89b813a7e469320cbecd45e7473c15bfeccd3adb31a4e0d2b79b6b1b4db072b54ad44d824ae19a69a7ffe316122ffe95e1ec988c1f62bde3380519e5021b1d2928367df23ffcd808064150a1d4de48aeddb7160ca677278d4f9aeb642ef7645275172039b62288154c5a71021d5049a1bf6370eddc7e8154dfe2d690eb2543876a982b4a45117e0010e74594786fe74959a167f73db3573b81f305f0a75eabfb6a0605ff4f215af8e7bf05672d1b47f8d9fcd6b172e662919b03cb278283cab0c7c703b1061a4d63aa589023c537e4410bac76cd93ce12c359ebda4c38ac034c32105f9fe4f59e35fe74eec21856d2e063baa19b09c84e40ddd8a46b7b9446b5046b2f099cdaf8b0647a60a445b2d3d6d8f49bf40f3764a0bcd2d4e2af16136ce5705d400a37704b10ba670bb6cf8cabe924dcaaa821421695328bb776cfc03004af5935f2ce69bea7efe9d41d4da3a20436c97181ec70fb93dd2efa44d9c2d9bbabd5d83f376e5a3a85e31338a2b317c70abd7bfc473b996304116edea0abaaf2eeb71ad5773d40b066d6ad1f4918065361da9bbd91dc9842158459f5b84526692ed5adea0279fe274f4e2ae7c5e9b44e5f07cf1193556f1210d647e43335a95b3d3d76b8305dd4af1b1ea9bf546b7a71b8d9a0fcaf308241e3f60063ba9eda7f4cbd4e7bf75215fb6484c0a0a31dfc8f85a72816a405592f6bbdc5124896b8a9e9f93275a5f8aa14329653c0bf5e9cd67e08e25979e9d42637ee420aa1cd3f0843db9168d9029b142ac60c6f2b49df6b02c1611d6004a5137383146a5d94e308a01923e329092ee08315b9e04a2ddecc0a4d25c2345275773b0948e432e3ee6c3e79fe9b8bf42af7fd7dd032168cfb5a9bc4a86093c3c7f9aa86c6ff52610f0bbd2275409ea5ae4ce9d1b52e7d4da250247199a973b0cb2a30a85e6c0fe072729824d4d8e087c175dd58d8ae2ed6d56cc9e3e1824549c5139f754921cbb76119f6c01a26faef5992ee0f6544366fd838ee6025d443842776199e1c4c9f5999a202318aa474305f5dc8c8567f505eada9dd4fe1813ad664a8002e70b2c73c30445073545ddafac21d4ae9e45b11d833c7870e7a4fe25bce1588cc4d9bfb8979b14f5afd985a12cdf5f0858f579d4a6803220ef29f284c56d09743f724a0c20e99b1471ce95139d92271f9b0947c9cc199f4c8c01b55c6caaa3049ef8d7a7054b2be901f223dd3346d130a06e665c0510362df8233e80d3a60a864a317d4875fc081d91dd18b8c3d5d9557b40ef5115af4d6a659737df8c295a9e5f2c52d64120e52af3831d98632a7a087ead24c0df3cfe2ec0f5e588bb242a25f9f9fcfa4580e885bbaac106dfe7e0456f3b2d872f6ffba4d1ef03e6d9b2ff41e16b85211d8c5e6e05014bbdd3ce76ac3005783328bcae555af83951b0a2fb87335761078c5cab88affbb81d527c0f2426119b739f6093d72d2a602f86b161db321215d87c93693acb7d159eff0a3073bc466ee0eb815394328f06e075f208836c5add4c943447f792206643654e865a88c9d6598fbcc846f442e8910b044f47f9f7b3b870542f860612115e8895d23f1c60e19dcb86229de9d72259820b465a53aa1dbd2af0a77d12198a6173d41a707a6dfafebf0f400ef46bd8531b262b8a2ada5067e684c0e05e9c065eedb3d2d158e8893cf45da52d920507948c7f59fec308873c3bd881c88cb81f1450a8c39d8836b4ed0b7df8c23cd9f61a852246212a44c43b8ac60ee3cb6c0c8432e98e96dae731ca09904e15bf3456f6e44ae92bcdbbd144b9a9e3ca3f3fdeeee13e2ac0dc94aee5fe8b4ffbe0ec0afc64db5b0c6259f209dba7f470639e1291ef8d99706e4b29f373146463a6ef4b7992b11018a8d457609af5d8dcb8e04dbd71f42e01c215755827333552d27116d28b8a0485265d40b8aa2a6a3e4af8913e0691720aacb07008ca9be2b6524b03a4df15f07b025db7322d06d87e37e660e7c8721b16921b1d228249b1aee407437a8292df185e7d9350bbec450624313a0a10f10905701bdb3785b6a652b2175a36cc96c7939a3e709cc8ab2d673660853d9b0a41e3b8096ee7eb7b0b734e1a653c51afed6b036596dbd7ae8fe7a8944ccafc8dce5498a98b047cd9fdaa37301547a95d308234355311764483b2498b8447ba34248648944e47912c5083933fe3c91f9404849c149c88268b552cbe85c8d94af2b192a504c87e838ea0975937f143d1f602f1f0f29b216ed2aac019d6084e25320db9b615233b2a501461377ecfbb5137f60b82c5d4f4efd982b721c27aba4925d92f66e4372904802725028a2336523ac20e0284e576c68ccdbdc1afb66b360bdd98fecbd93cb260ef46613bb5fce5f52e786e87a3a51113479f3246976836bbc7803f0cd979bd21f8497af84cc29e0b63d619e533f57015679028da5421bdb2dc1007132f7118840a9405d7cfdcfef9af979fe1a541b690858d0bbf85265bd8132f5667ea6bd72ca511ad0be36ab780fed84b20816a060affc2568ad22d5fc3c8db2e19fe937d7a9bcbe5e2d1474248793b124aa98073170d45ea7bce32eabeb11c1375d01bae74b2ad3d38c7cad06b6294559fa992b1e7352f5e9172aa1b21319143a935f06582e40b66144916abb2902d567355e44dec89363d9cd61b72a60fb4a51a2497560e1e09a526239572bbe84ee9bd29a90a9dbea3e7a08712dda7b8ee5ffee3afb19b960847e9040642f0191cea6a460b3e50f74a40f3be44e041da15d988d9d5c494bdadbb330ecbdb20cbfc5c70689cfc5020fc8a638384dc607624d8a2e4ba870502a75069958a3653b1576cec5d7a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    
    <category term="年终总结" scheme="https://xtayex.gitee.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>上海探店 - 蔡师傅</title>
    <link href="https://xtayex.gitee.io/2022/10/04/%E4%B8%8A%E6%B5%B7%E6%8E%A2%E5%BA%97-%E8%94%A1%E5%B8%88%E5%82%85/"/>
    <id>https://xtayex.gitee.io/2022/10/04/%E4%B8%8A%E6%B5%B7%E6%8E%A2%E5%BA%97-%E8%94%A1%E5%B8%88%E5%82%85/</id>
    <published>2022-10-04T12:47:00.000Z</published>
    <updated>2022-10-04T12:55:02.359Z</updated>
    
    <content type="html"><![CDATA[<p>今天从浦东机场下飞机后还没吃东西，就想着到外面吃一点吧。刚好想起之前在小红书看到有一家叫蔡师傅的阳春面店，据说量大管饱，性价比挺高，于是打算去看看</p><p><img src="https://s2.loli.net/2022/10/04/PlhniSZHWuaT6OE.jpg"></p><p>我点了一个雪菜肉丝面，一个煎鸡蛋和一个素面。雪菜肉丝面中规中矩，算是好吃；荷包蛋也没什么好说的；但是他家的素鸡确实非常好吃，厚厚的，很多孔，吸饱了汤汁，真的非常好吃。这三样总共花了17.5，在上海确实非常便宜了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天从浦东机场下飞机后还没吃东西，就想着到外面吃一点吧。刚好想起之前在小红书看到有一家叫蔡师傅的阳春面店，据说量大管饱，性价比挺高，于是打算去看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/10/04/PlhniSZHWuaT6OE</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>哈哈，好一个国庆出行</title>
    <link href="https://xtayex.gitee.io/2022/10/04/%E5%93%88%E5%93%88%EF%BC%8C%E5%A5%BD%E4%B8%80%E4%B8%AA%E5%9B%BD%E5%BA%86%E5%87%BA%E8%A1%8C/"/>
    <id>https://xtayex.gitee.io/2022/10/04/%E5%93%88%E5%93%88%EF%BC%8C%E5%A5%BD%E4%B8%80%E4%B8%AA%E5%9B%BD%E5%BA%86%E5%87%BA%E8%A1%8C/</id>
    <published>2022-10-04T08:54:00.000Z</published>
    <updated>2023-01-01T09:52:18.199Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="75b6c228abb99646a7e9ab57be0429471c50b5938e153fa4b6cb3ff332b48c17">4c4fb793a45258e3086db9482db91c6cd8a9ea749f25a1de82f2a4a9877f688432e7a6af20b5d0f67adf399fd0b41e586ee25eb40cbaf5a3f147d196de4ba7bd85366a66513a4bfb5a317b8a52eee5782cc1dae5cb74476a9e8e4916088af3868a7177722f8dfd5d51790dbde0ea4500ace32e04a589652bd6d2e602e07dee36da31920450c4df902220c929b0551802ae6d2c08bae80e8f9858097542a6d50cd62f6c13981075d3c4cea0eb5e07d84fd187b48961120dd0830bd923064b2a953833985366078627880a4fead05e8f1d7368d8f7431353e25255a245c43fc983731a0836244ac070dfc53ec0c76b8b7457a733b7611149404315121059a844dd8786dfca763f04b5e714956348339cbd2bac11685f2e41ac5d7d2eb8229e74ad55d8dd4ab8f9f9c378268582f4602a1d6c33824e162c86811d508086ff747430483bdbd3a54a58fa644f78f2aa24835ae8b40c7d1d40e946183e6ec38440753ec74cd859232e74e5ab16c16ddb8c6687c9253b0be4abdeebcefb310ee05fd12047ac174b7f16f57461473daa07d2c15cb7b4096081dc1997a0372bf9e20aa846c72f45607628977f12948b1df39bc7e921946437d6365035f8baec0368657e5061ed8cc1193397df973dd0ac4c2e57d1905232a8ce2be93ea8fab8d8ea2b7edf5d1974bff2782bf63988ba9097d0af50a3ed3e055ead06d00a8625203e752f94bdd1697c73b55f7d336aa3184dd0bb72e844718c42c5a4bb9407ea2dff315f58df81cc48ca1556d72e1a841b6d846f08c01aafb837dc1e291a6dabdb4e6d50bd6081f12eaa4b7ea18c77b987b8047e4d97bb3ee2a7c07d68cb3f1c21bc173b02a3415cdf88ead3c2ed6a0160683b3568d9fd9d6b06a3df8b4fe32c2105d18267d070907e757c8a1957ada9a40e3afa1c8ad4c7ee5ffd6bc022cb0d834f58f1de9e2033d66892d1db58a7538b0514f7eaa1d286f974205d0446ecf74480c69e90ddfbac29df5a395cdb229d6fd44d274dad0570b0f8b756c8eb9c0b6150bfefadc35dc9fa249d24f3cf3a60a73a2743e8b951953836b362aff1cb544810bcf2d684ee202ee704a236170b9bf7e274f2aa18577a5cc7c21b8690a7ab9dbb5c181dc03d66377b74a4c16a72874696ef21dbe0dbfff5c18190bbf661218e505eb6bd2eb5fc6db79ff2df61a0e1d333b6add497e9af36e67bf9272397427be0cfd8c4e08b5a5ad2f2282f5295c81087950467d7aa24351369a4e25a8df19a307b07e4d46aa21e48b95d3eb8f45ff02d560f5816b3edb58cfa1092a97ac59eec381d03fe2ac0b7a5a2cc2ac4ea162225d471a8bb729abbebcf85a08aa150ecbb410c92913b89f3d44d12e156450bd61324a19a899e59081c1fa3c19db22c2ae66295e36b1e35cc2be525a135d6c5547f108d66f437c0c2198a5897db6a2a1efdc143fa1155aa7a2576b12d56320590be19b450d925e2987c79098958c34487e8f6ace972c246843aa84234ac4e6b032f7217608415849a11fc00ab2fd13c2189ca1c5819b2082eed88f8a79edc6c276c435bf465cce47de45ac218ae2aa98893adc61ded5d58f98dc5ba3f5c027ec1a8b5edbc47c772f77ed544c7c64c27ad691b68707e1113d60ed9e462f6aa90594c754ab18f450f0028eb6b519285994af1999a1095343bf1e0afe6f4cb4f1a2c129e47cba475135e40f5ed4d5fb0489f134bd027747cfbcbd2322f2eedf56eaf5d62206cc9fb6023a07a744aac9ec22f6c3a93288252c403b741ab418b9c13ded909113f22c5f3efcc003a134623a9665c31658a1ccbe79c8a813ff374237a390be95ef185bca6f782cfa7de9f30b4cedfe40a611f360708bf1e4873fb9151976484cf6ce29b999286846ff0b1642b9185b101b4e4b7e7f5b0da2d6d40e6450b4c444b953ca504983cb1f94c497b6cb5c97ba724d1b925dfa307a6572e21ee93a0ab775cba491aba8295923845a6ff720888bc2eb9607519fb030fb47bc4d68f5e302072a880f3a6b883c996914250ef60a4a2121705d99542b89f9435e160f04c0720c8d5675484961e84d14ff51f3144e98da05967a6c9a1d5b85f395a9502a0ffae94eb6eef24065a81f3036f1c2e1e67a707cb5ffaa70d040d68ca9a099088ae1fb5f68c10971bb9ebb0e748db9516d6dbc612960b515b4592e5c41aa080742f93b5012fe7a6600d4581fb82ad38506b76e996114fcc770afb43dccf5bc98867825e48fedb1b4f7861d9fca8c29835ab9eaccf735e25ce13ac7a6495fed462f20f6f49ab3f0e1cc754435ff190532bbdd743fe1b987fb8182007837ef0aeb56b58fcc1b0c859db96865c3c4f807a5590b6dc59329f1a0f57a43bc44d34e8dd96d1a6cca24421479eb4d7359145211e1316c6837e2d019721524041de809a8679f384eeea2058e17e4f4a8560ac5b90608b8ab86e838a4ab0c36445d99adba7e1eee70d478bebb56364bbcb820f6821cf1c41195f99bdd0b18a8aca600158fa9c0e908bc9a34ff354b5c983fee3021e5a7002a456e3d0b55858d4f2e0a9330c138464460d96b838185b54cc19f15d2330353a1ed8e4987c15188308c481bf4db51d072d9bc4701a71507a03c9938ab60ffb9f0ff84b2264632607c8e5162d28591634f0f4d538879bd22e4ae7c4d45586757b38222ac5c2c2ef33f6b1d0c3569c60fd6a559bc38bdafec27e68be9fa9b9f026ee75adb33c1eb569961075dea011fafdb98d9009c73eb995cd4e327e3586eff4ec8049f14252f928bb8f1a686be58c715562059f4e487a8b9ac3be367ee334d43faff99d20707eee4d5a9b2af5971306aacfa7fb244e96eaec1c50aea5a3d480fc24178bc3a39d2d0710bd880ada22fa95757abec137422ff499eef0ba56f1e248de8719bdd399259c94133422e453b969f027b52ced53c8b15eb7da1db9d356b8ccef5d9ff170a4a991ae7507b5459d1b05a11008d3ffde15f0f832f2819fda6ca968e55b3c4193c058a891043b0f4f155b511ca42ed4d0c9f90aa3e6fe40aee8079be8e96b173a54200d25300d0f1a1bfbefd442610af57d87582b46673063ed1670af0e459a2761770d5ac1b5d63fe18fd73ecc9b8097cf8b33ba9d5439222c3b80f2e5f4f205812f3a0b68959961ce19bd368d565dd5f81418520a1bde6ec99e31018e2a058475c900a178bc35c71f74ee579495932579bd271e9990825dd2b19fefaad4d76c8ae8f788b9f7b13347ad4668d3e8f1aee0a0a2dec76ce6f368d99a437e2ed68604a753120fc604e422482ada70e8288348e92c1865a89e14672283beb22d3168deda4804ae0d1fccd09edfa8c2095fbfbeb2123f353aac5bd8e5794950e176d62ac6644cf8f245814445bb3dbaeb52645d73a5fbb6670be829a0c5075dff97825e45dca5d5b74cfbe82b34bcc646398e79e5cb0e8a11fe005aedfb5d183c890981bef474878294ad7153c524884d23acc68333204accb741f3762af9dbb9a2b745bdd4f89967438de2fe54006604068ded6c5832910363d4da67029adb350bf784d0fdc41ffdbc23507691a0572347329b219f7151591b3a6555f5e69decc84e2b99ee19a5e959bbd4fcb46749ed4110786edbe4d1ca3fa4bfc569779d84e61229253c4152b9a73de3e3ec38ba115e76a0a733bac7a63c0ce38531c96e744daab739f4e24c371211e1203694ddeb4f80a96097d9c0a5b3b046ee4646e55b6e66945be6fff230b05d44aee223cb4df0d5edba4b8140262d8990b6eb6a4fd88c00a7cf06cec2c14f7ea7c6b0ab0984fb56d76a7e094d274d544777bf33dc0c2926998d2340078688192149a4ad4cf31f5f6f319bfa54eede0e926109daa4a811f5204974f0e61b7a04f8c60f355b8e24f16f2ff02184e4ff6be5fcad609bbc0dde9aba9e45e092bf285c85556560efe6e09a7d249382a901c08cc19eec42b4b5096eddf8eba3ff346ce2fa962c93b60bf610bd7a0e5ad5fc8c02f9349fd39d4747af0bd1528c9fd02aee234ee8f1f4ad8b6d1b1a511af964c1d1cfac5e4106cb86f59ad58777b8386ae7ecb20d3d67ba6fcd1927ca731c8c771e5111d5744a4de1344e1680757bffc2af451cb7e5927fc8bf34e9f079bc3f4793e96dfba849b2ad36e5fc48f2a234b73a10f825f659f99c8434775e0dc9dce5b37555c7d5682a026d1faf9567809e5bafa33b7486e8b05feb4fd26e4a87e5207215816b04866b3f5f87fdd8542d16b32b59d122276ac1d7b62094b8c88309ffa06ad02f8f28d1f663ce6a7236d149e9d93d08f86494b699933ba01b65078da42d69f19804fa6fdcfbce6a6273b937d9cea410244c4a14e0eb46a7099aab522fd8b95dd0bcbb7a8a64d41e94a41661318c5b2ccc50056b61cce2b8cd153e0f96817d376a282669438c032bed04ab8f3d9617dedf0177e8da341cd811ee233c53adeaa79ef0712a515073caf3632a8d5708afff9726f40b83700277eda1f45eddd3166df3e8670d39f12428cef98d9e3c8adba594e4a98f965b5fafa85401aa7744f462a672ab1682113e22943f1835bdc95e67f9bb06648632c90d0cf8397b9897fb5e871010359dc27e136e89e8d0594238ed2d864c76557d41d9ae423fa88b3ec78a10e1d4e1c51aa5cb8dfb9fe4ce0823c2c2b1d490e902ac17712c3965b06b9778d14c39eb004ed660aa41fbb64b2ad3d04eef1898857b0abe1034fa6aaebed360d84e87d001dd8cff696b396ce6b97275f2432089058e9dc92a66a333ac1fca9d25a26755f78b30f10cdaffae81250e13d191d35a97b7023659ebadc48df39ae890b009387f7a0276c0c6f4319b717b936d92bdd6a1403ab7c731242bd292760ea95714382a881bad8a3d42b7d98cc0e513ed0d45e7e9b59df4f76dec313962295d58409fd734699a47ecb899ab50e4d04ae6b7db05cd3c592a149048e89543ebcc6ac3bd20479056d5bf4d18858473be30ddccb7d54b345e1700d48112ab92d46cb77f7c79760e0e55341b0e0ca90f870d7a3e4ded826ec63730a9dc02a74777ac85cb6a90b544c5c938f0abf603dddd340212aa11204b29ce1cb37bc0687f389924e694d48996e15c8bd1f26b35bfc7aa9b2977d629faf715ebc9f83db6820d1f19dc21b97cf488ff2749e5a6b25819116d9e637d7286a14b6eaef9e680c52040202715263d0c66cd6e46cd8513d1e9499b745978b4ddaa82e23410c8efa9a27bade068ec6fde68a0d4cb3e97ffa98b56ba5d632a1f9b7a91f5d4ed170011153626c0091d09955df6b59d0e8c19702428f60f302fe7c3b561860a66886420780a9b8a3e758dfbea693fbcc747eb258585f803ffd2ff928d22a5f74f0d8b9e1b58a7e963818d7a75ade464e87a64cddba6ed401de8a532a4e9520d124660be044f499cda6a0c2c6de67d324b09a312889afcc415b91a4c60f777dd5a1df020014cd32a7035f0db248ce1d2bf7b7e35fe2f3381cb3b6a410cc65e1d95074f51355968f1ebf97b2093210bfc9ae2165ec83ec4f552352e87efad8c68b6b5a8b046da4c952315aea47a15dabafa41caed44951c101f6df63f463ec28ff6a176204b8307f498ace07425a3baec39a4cc0c1ff50a0a68e934317b04ce67fcc7c8d30f4eee76ab4c8a2fe56f9bdfd57cdd937ee18f464d05ae6424f32069c7dc45fb9ae06f783217bd9d51313c86cdc9c5738735de00b05d24dd265767e0d85d6a5d00628272d594168527f8c241803b9e510fba9a27e59f83f9d378efb28727ef89a0e9d955683c18adf3f4c0ed89289f3e7a9e5c9558123e989fe9d31fa7831e740cf2554a0dc4ec6bc6e5b7c7d5b911a9f178a5cf7d08d9fe5b4a6d21a6cdc0ce487bf7f541f06f0dbd909c0a6fd99914f9a8eac49f78e4316f5b3fa5dc83ddb71e44eddf531bebe323a2f591276a929ed6d9d170cda24919002c7d864531ddc2738737d3a7d46438457bc84565875183f0bdbf943accda93c58d433f2503ef859d978f432979a8af81f6b9335484938fbc86eb6a1b412c056ef7326cf3808dfe5ab699f046774750d499de8d811075f2e8777847c917cdb93cbcb239778d2616b836d19159941237ddc20f1782db2c5063a30a1c6fe1d8a2253fe1708043157068fdb38560c5665097bc5a2635471017e342d755b28fff3c3fdcec87c1ca3d5ca0618cf404a52fe0e4028933e5dff257c77a8b0329a980d0f5fade6d1cac64142d4ed8f5a55cbe3071da96af86dd6adc4f771459b3619e62eac089a6072113a3a919b95af00504d16217659d9cd2ba0b5329da96202de002de5af401bdf507a32351b47cb3772af1ee3cc0025b16558979a772cf1456170f8fd05ef1ee722427f06c67b32a60beb4eb4daa47d1006582fba71dba62938ba1e5f6ffd773312c46949d568c23843ba61911f63cf69aed691c66e660da1d4baf134a9b479df65d1d841d50e68bac14ede51be44fdffd528373c45282d52f7310287c5cb0d97e4471dcc75558eeb57b820ad04eaae1930f78e693739768c4d7ecec7943c6833d2c68a7f8f8fe64b62e22a0e064e7bad9ce74cf7c7179e398d946e5ac6623621e6b3f090749c2d5974ada1374d1be8451f6ff43836ea17a8c2c65b0ac3dcf4a846e7f038559908bbc56211a3d0e5400376404b1281868e5ab2b25ee9735c75d72fa9ab0732eed7af8dee6210a8b2c1e3c079ee6f13b5d5c5888ddecbd1fa3dbb469ed0c47ec3c22fe8701b5e8f4d9fdec062cfa0296533e28b87a561b6d6c555be5b1b614c7ee51e94db26a8f2207e239b87a1cf35eb1351eff43e83d0be51edd056f0845e49162dd8dc1917d11b0527c149855f44772eebdd467bce845a527bd678d3e65e5bcb1e72f061d238c6856eb656c7584ed4c412c353cbbe60a9aed973584eb19371889b884c01ffde5f87ab69425439744e4e871808162e2cc23927cd00fd245d5d9eb31a98b06e00dda7b17368e8bece6af3b1a774773c68d5710bdcf91ed8960f2e8844bf2a5369b10d6ef3da27c7296c269f64b882120938e92aa1f874a4fcebd25ed425ea9d62606f42302fb18b027dbd38a895c69c31bf26b3b9ea3577fc3df1c1ca62e08632cd26c478aa2e864d2bbad032319b0d483e33c0e99ebbaf28acaabaf17efa3676e9498b5f599b9ca7dd651a9f574f2d91430c94ecbd7bf75fe91d79ba563f3fc52402546cb737f4ea10b22f32f54d26df6439da8caa6b0e9e4cdb5994e9e3cda81313436a9b3141462d98048445812b9dcaee74b9a3631fc9ee4deb36889fa7b00d605a59b7b334725183a060d5c68cbeb4b2f667addd84492c60335b2df7aa9f4b6bfb98c75b479dd73cc93541285468804efe4329bdab68ca41b8abab23a968a29949f70643dc8d44f5b69ee905835d8f2ff92c19964b434d6973e603669915c3a9f88abc046a92b39d3c59d79780435fea0d90e918fe3420e690be329e4917b8b1f515f27386b672308c5c246cf2efebaacecb90b5dc13c451ecb2074d8ae6f735b3790abccce734d2511e24b7db158f1a1cb5338c655e58ad9ff632dbaaf81bff0d8280698cb0c4b1cbd2ec497bd8d17f5f6b7a83869ee3aab8b9e7a9f4e8655621d4387d9dd50a61eed6f10d49397b41ba390ab574db22a10cbb4fed51ca28fb0d53ee210f541e2c5588c98275c334682c5b149c68f951a1c3f96821a0627b44483776733bb847681a59019d0c4532e4ea8d123624190fdd9eb7893ff8180a1659a83ac10912bfee3bc3cfef19947a0c33a7a406e19ab0e455546f52cea293d77041dd77fdc9b04e190dbf6e2b185fe4182a5f0a817c358c6ff0baa25da28c2986a9d42508a24d72deaad71613977184036a55300cca1c9ad3b250581f3f28cf3490da50e36d67283838c95e52e454acddce55576ff427d24ad6298d2b768b160e4ab140a903b79cec3c7186b5db4c41956405c80c79b3e48de704a6781577b1c019b0c83cbdaf267443c344c5b93972a2b88c36ef69dce88ba0a9b4716b6c6741ab63c9259beb68bede95507f6b6255fcb908f4e05e5a7880108eae4695c64708b4ccf5b58f17d79765d1f945abda0126156681bb8e106e863413d54c755033e5fa2f289b861fe28c057ff3c1210893342c1ef3ec11c763770ef40118d64f7d4fa33e5f494f17ffe48c8e05c9cc0be588380725fe9f4c06d1334ae461c70f5497d4ea32c2fa75431f919339fc0e22ff481cc0a44468886095f12c858a066878845cd0bb3112adfc638e0b57b4f1e965251919aba64c19b806f119b343c728011d4c259f4c31e99335b4844196eb512ec639c9fba60debbe5cc70c7f7a0dd82bd4d0d473710853699d562cceaa4b4f4dbd0adb7b65bad3886f03db55f7b724d8586be735f1643a8becfd7b1307f4374ec65b89fc44be57929c8955f9b30a0c3a3fee4822d54b907b99170774082367f6475e67b4bc5fbfd35cf23426503ef01ea0a8020005e2a8405f5cf32b99e19ff4365b435b7d52b05865c07d7cb98223a8d42bd195269df096e010c49f1221aab71ad740ddbbb5d11ee609d4c439d4b864461fb51109c7f8fa3db9b12afc81f89bf3530d112ade646c7c201f100b60a7226bb579b93dc9164677138cae47da9e8542add50c53f19f2141c52d18a1f4745adf4b61e5a602368ee79459190f763c1210d9ebad0b25291cb4e406384babbc82f163a162bfbd3d900b55e169e0db60f8796008eab74c041003da251d0ae404625e90f0f0a8610ea7a6be3211977129910419cdcbeb4366f20c4bf7170a808d4cfcd97bf1e0ba3c7c1b42d3d408639d06645cc29f59fc19522f265c1150b3df3f0d54473772f90478ba9c686e32df822c7bdb687141b4465d3535f5ac2c4c4d991cd52fe9201a4e4b4dcf0659b0c16ef2369eeaab81845c4f3c631182cc8e01a1237f0925d564659337cc730fdddbf54ad2395b71393584e7fe62930af3823e76e3212654f038e5e71130f5ace4c58400d3d3644d38b01c5de1dee2e8b9ee7c8c5c7a768aff065fd016c1a5f2062b9a803c33e6d4c9968b2b066749897550dc2841064b8fb6750e537ec4c6cd27a7e6e7f9bf64b28042c8d0d4e4e986f40e60fd442c3c68203ace01518e5d4098e6204c010de4c6a50dac81e7491b15a88e3a99dc247de4863866a34464ac9910b3ad539a04ef9e6a6eb3e351ac8f01e659ba0fd497be4eed1d5efe7277a293b815d06fc69314e634f0f55f32c9fe5f383a84c11be2f2c0eebe9d59de2b30b519dfa5bbbbafcdbd27122f7144f98b793579b8c5807dc7b987e6471b3245eeb8edcbcb4085dd9754638db3b518ad0580a9958cec42fbedee52cd8c08beb85ab4dd3cf5e4bcb8baace727220035136edb7d0fea2aa3cbb970051a99368fec7901b6710770005b00133f98a9db748c92120c7df5f39c89ef99f1cd53bbf1061a754545e95104e396aa86d12d48ddabfdfba3b4f5ab95e34616c198c66cd153d7c34e122511d117c0be1f269ffd0efe78d726ec7b0db7c4baa5e994a2d2605ebfe4ce09e5e37176bb4ae07ca5b1d7bdd75f301c5b4cf314156248d4b5469d578321adfbe3588a23294ce56f496eaa87d0d83bd9e7010a8b0bc39be42a9976c6cbdd09f5336d5c60c8e03d26f34e0051d444b8de9c75f18e39a2f70c761518d0db30cd1ecdd1399a7c986f9b7475e3d8197e678724cd1a7eed9d439d25215a8414045fb282f9792c40f28ed3746d1b1d7ab3f7f3b336687887c233950adf904336fa1b4d946ad0ae1e67411f10f4833d593623b1be3aee81788015b1a244881d741b74d0d592165bf4c3e3d13d82d0819f3c1762dec19a20b3688e19ac18f0e1e4a0bf7f446a95657fabb0ed3ec1a415622d3be0cd578c6e3d3a7ab0cfbca453b8a937a134fd1196dc5ac281368d7f8da8e08a956ef68fbb6542c27f35a5c9bd8ba1e43a70769d97bbb7dc80d2e57c42607d98bd9e46ff1c6620da758fbf9a556ede4ff0f78cebf6620d645ce03e39da06ac8c4f24fed8d81e7b21bf792518453438e3cd12cdc4938c8d6859ca8fdc60aa40ad157b8663821186643be533d279e85e3f834cecdbe079d06ca7740a3e598068b672db9401f515c877206f14620c37ae039b7dddf6ed96f5a6658cb98c7763a36e7628d5506bd3558a7ce2ae0c0ddbb57acf38a343944e8afac4c55b364bce403b29c8e73dd7378710aab4b58224e9482757357ccb493ed1d30c4ca9de3cbce14ad22bd5a790f1aa50e93d3285a7260b69b50ef421184abf58e2e4d02b191ad4bc8803b87f74b4083cc565495e4b107c49c470f102c654c5203267922893844553f7fdfb52dc9e7d72f55e6e0e4654a9120ce87a19a9479e64939c3331568a54e62b00280ae8a622d6db2c26297bfaf395b4396bba26d134a27e032c1b0587b4a363ad8fe7e09f97720fdd69fb8477415e9852fd38b491bf46d87d05e1f518bbfce67a424de972afdb36202fef8b5788a8f3642d83783c327a31e879e5da2048d67b02b337c1d3beb875eff882f54a216aafcc454f77f1df8ae2957e13c73edbbede6b26b5d0c50d4c87ac76df27638d3440e381adb738ce626ef2b3ce13277f3a5234187d2093811ceeda66a43eb849c45105553a73d41d6fea3a70c433819c97f6de44bc988a671c8a331f14b78fba4e7c9bd521ce5dfb5556ba133e99db34f6e461c65243e46b6dc8afab555ea1ca2d683b15b579cd7ccb043b05b94b553550bde809e3377833b6fef671986b6fee3c32a54ee3471fc249fdb086528a8cadfc3fefcd1d246c4714357500551f59c112b34ac7379b1c3cbd02934e73b3a1b59e4f344eb58b8991ab6d6174bd96d248c03fc395fe2715cc465edb0bc05b10f97dc6ec2bf959023d2b2e142495d86f7efee4621147fc38c7ad9fd85b9d699b3ce7d0f67cbbd460433fe3e8f1cb52b581c95087e67c29399fb88ce83c46ba6b225ea213383004665aa737b082fa4befebcbcc1ecca0d4deebb77de35052fd20c5e999f6357e56e5dcacc1bf51e902e1a451299a01b441345bd134dded8681725787f0b3575ce950bed6f6c54935b828afe011e31a2238f5802a1b3a1e4e90ba392c7fd3998f4975d16b934d89e41913b7b33dde8f4551b90df863aedd97933f49376fc5908655720a373895d73ea38a9804bee2972a087d5890a259f9227aa778dc07ba60a32b9a2ac5347e599b1bedd2ba511e38009bcaca883698807a53af7cd9f408b8daa6bf92819d1940dd3fa08e94b7f4f80014efccbb2f3316d23319a3bfbcd4540c6d3f13c255034700eddd815e35a4e70b079b660bcdd12ecd106517aba7ebdc2e9108a10d10b2d7bb94cc83f4cbee3635b44d37af4891c70ab21ded1792b04307e831e43ef083d9c452e0d572ab9b960e8208475e7753c18698b931cfebe067b3078fe8f36660fcd333d0e00325dcb7d78f01e205ee946f721a48c9db3625952dcafeeeac7c6f788fd90a50f6e89e34726c2710fb2e0219b9e1adb4ca72e1f73510ec495a69c768450d215541eaa802a7508dc012d572d0a46b707c29dce17e0b39a22816a966c935f42dab9bff691b50160da019008d934ffdb58e59e44e9add363066726443556571696b318f0e89da7819cf69d519df56ef14be1f4de9bb4a2024bfe64e803b03d7e399799dfff75ccd1abd6419afc118fe7458f39d94ded4691684e449ae57c4fdb781f11964e85e507401436b11721e8c121d1ed37b652353b53da72331cce981ad195112ba48b64417674d063b5bad5d9547a14c6dcb8ed32802a5e81ec2339cff3c2e038e459e85ba4efcfd4fe58f7a02d42c8883883b5e5747751371a4e1dc6e4e52fb0691e66619454736f1e3974ba5de46e6cbd646848aea962b0fba2f8b4dbf8cf78a478c706877afab5f9453b782da9ab0a95a0b27a2f173e6a04955c433ea44dd5ed34b574f1cdd49e6e49d5250f2f94740241dddc66c7127ee69945955e711a51392711199936689965e38a1d227ec64209f656ad0c7bf70fa599e3e56260afde64d1c90598c47c52bb18d0d323844bc03d2832a91f8deff758c53a9a91a6a5d430197f007a86a4bb8ca889af14a654d071e9be785fd22ac42b11b1dd7410c76bc35d29d7e869017481634e121945be9384a08ace3e019c1b589a79e72d0ab93a017585568fd71f68ecdfd586f6222c29fdc622ffb39d56005710ce2b57915b997cc209ed5f9d8d33a8faab3f91765c9bfc6a01e7899f69e6732d680e269dd20a5881e39915457f648a47609ee2e14b54cbb73dec79521698949b0fdbf3182f16fb1233fa5e263204405b3a5304fc752c9066c4844b74d5278f8dfaf0db38a1a5b5313f4fcdd041cc2ed13ef8601072f78980d3cab148c2f9c62972af33a3c31dddb6c2a3d4c070d47b6857674a3e97e03ac4b6938d0ad83303b9f81fbde81fb6eb752911475dbfb4e70589a5d2b3dea12c9481cbbc829174dfd5733ce5b71b6a82f7fcf12b3fe623581114bc1511b3546070466037032ce99ad426476e1e174f0936166200e564572a5069ed156bcd61454e5d3b6805f88b660fedac9bc273673bdd331844e8d41ed49e37364555025949bb846ca4ed8292500bca197e25c07af8ebce383b72da7e7938d5af5217b51769bf551fd2065301dd833bc6fc4462c9cac71a9357505ff43631854c3ddf667251387d93412270451f6e1e81d8b6b0147ba8d86689067f46140aa408b37b59eeebcb31bee274f3fa0d9ccb1ae49308c7284ed93c3002706b262bb39669b986863ba6c900313cdd5407f2a612cadd4b90b4c9e8436419ee8e24ce14f9b582c16069f79ea545c1e29cd6d372755d8b2d566f672a12bc8de1d121da8b31256ecc8fe9932ba526ef131d59406b00180e09ed2c790e64d288b61a914f4470d6f9ae7cd9938c437624972fa9e3781d2b502655c7fb35240528f69c8af4a12fce3b8fe9afb1c49213ad21389c10286c906abcc98b81241160494717fa50a92a794bd11d9622313a0ef3959ed212e0214cf637fb9377965f2dfb127d027081a443f7147dc001743d7911f0438c76ac39f7506f36a20f09e7db1a71375aad4a8fc8e2db49fb510e2b2e1de9c2ede8b4a329234472aeb90ba830149fa0f4df98c359a235819fcda0ceb66f3c8a3d786bfa936a06c25ef0438dc7eae32d763f3ce7d2a5ed937fb164b0ecb0ff9ccbef1e439878b359fbf2bf839f53fd44899a592ce96a372ffb26df162996291043566705c2a9d7f45a824b83a69eb2d65fded2a19a1607cf954ee1fefad7c6928230e8706a10475ec367cad43aba11e3461c60db24a47cef17aaa4ea0584ef9823be1fcf4dea0629ef6769e0bca7ca3588ef700de3ccb8e0321bb2110fbb55f0748a1dd431b18e3b3077553697ef964d56efe7c668b73d343c81512012b6599d91d61939cfcd7e3c15d1569e6725a01306eef0c62f5e9fb5bb3b8d530044cf6cb92f30211ed1a3a7195408149a203fd155159c6b5941513e74a63eec62e08b641261db34643f293871492112fa5fcab5c12116b4b02fa16d670dc0247c2a846a6fcce5959baabcbb5f9b66161b998b88c49c8261608fc250378174791d259030987ff48f7f3553876f03cb65c53ab40f4e986236b363d7dee6d331cbf39d6738b8ea5a1701389b2b31b40a6c15dc755bcdacb9a5215385daee146daa11ed200993cc96ea9dc8a02cdb7668c31cf1b00677903c70a290f54039592a65b5b70481966f3d3b542c2b1ca5e058135a5582834c41c745753cc825a04e57f6ac88ab4442db8cd435e873a9ed54550ecb867c8dccc2a11017d77263c578ac1a991774272a778286d3bcdbeea7860be44800f57a4593cf581a971780ac2071b91499c531a54df1080a34b9c420c549a6ea250296842295521edd35bf750fd9cf8b82901c43d57d0bb72898ad4560e509539a96d5ac422d3961b1b37f965732a5a79f8f3b43fa392163d8e7406197dc4c93531e501e01e8b3e7c7550e3194143ff77ddd01a64998a2e1b68b07ac6d6d587c96d43d508ae3c64c6f14c7fa15a778c19ced8ab4401802ca38b1d6629cafed3f48b1ffad284d45748f1cb0f23285c077b85569f896e209311660d4475f089b74e6f4df950ad40bc0c361e16f02056067613099b77690e8287f3fb4f1d90eaa0cbf24aadc59b0be3ee4c43238d8ed79989742b8a89342cffdbf7d776f78c0e2a09592eaf6dc7d09b708c783e3da590a845834421d1e0a0df8f279428765f1e2f21e3a054f60a8c5d0d6eb9d1d38695fd5c465f08d468bfd2c30c03158ab7bccb7ad726e60ef1a8323e67271328deb1739c4d4f035deb2fd7ee3014206bc129d48c3eca1617e5fd7243904477cadc2eb981b0f2cb2c7b023f05e1415f0b81766fdec831fc0d86a9efa005b8261fe6421689f1068204dd18ab2f8a3919267ead096d2d5938e3e1cd773b8a8c4cfb02f497dad7cee97db496acd34dd3b52e62afe60829ad67ca166c0de1eb7d5af575a029c4af8d0c7d921c3041a63ccde4139306f3891a7541bfe3d7ccba3691cfcb7fb0e24cb4aff0851467ae9387e0052c3c5ae893a4590f580110f744dfc6c3c21ec4f75a0431b5842665b65bb6dedcbf1978242c77a17d339bc0cf88b16b69206661924d505fee955f4258ea12de4b19e2b1b5856dc0a3869fb0a113f45eab6ef1f4babca7249f3f95682f2588ba22be1c0d1579db0d1600306e32934b7ed918e18403959cfd1a1d39eaa4fd28c299efea5d8903eb3eed940afd7fe1bbdc47055accf3b0041bfb6304bed132fc485faa3466c606f9e3667f1a46fc64e49b76008ee43bad7573e36c80315cbca68a1c05598489e8b93ef01e809a65c2bb4ca239800896c5c9f8f51c59be51829d58e79f64b61cdaef24bcc8034019c6bd25c221a4f9a1d992e04cdad795537abd21da9d0e38581017bd2e56ab1f0bc4d05d2dd24359d52bef8b257ea740ca8469b714cef</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    <category term="生活" scheme="https://xtayex.gitee.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="国庆" scheme="https://xtayex.gitee.io/tags/%E5%9B%BD%E5%BA%86/"/>
    
    <category term="出行" scheme="https://xtayex.gitee.io/tags/%E5%87%BA%E8%A1%8C/"/>
    
    <category term="见面" scheme="https://xtayex.gitee.io/tags/%E8%A7%81%E9%9D%A2/"/>
    
    <category term="游记" scheme="https://xtayex.gitee.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统三（二）——指令</title>
    <link href="https://xtayex.gitee.io/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4/"/>
    <id>https://xtayex.gitee.io/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4/</id>
    <published>2020-10-23T08:08:00.000Z</published>
    <updated>2022-09-27T13:46:54.947Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5f928ffc1cd1bbb86bf44e2f.jpg"></p><span id="more"></span><h4 id="mips寄存器">MIPS寄存器</h4><p><img src="https://pic.downk.cc/item/5f928fc01cd1bbb86bf44392.png"></p><h4 id="mips指令表">MIPS指令表</h4><table><colgroup><col style="width: 22%"><col style="width: 14%"><col style="width: 24%"><col style="width: 39%"></colgroup><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">示例</th><th style="text-align: center;">含义</th><th style="text-align: center;">注释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">加法</td><td style="text-align: center;">add \<span class="math inline">\(s1,\\\)</span>s2,\<span class="math inline">\(s3 | \\\)</span>s1=\<span class="math inline">\(s2+\\\)</span>s3</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">减法</td><td style="text-align: center;">sub \<span class="math inline">\(s1,\\\)</span>s2,\<span class="math inline">\(s3 | \\\)</span>s1=\<span class="math inline">\(s2-\\\)</span>s3</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">立即数加法</td><td style="text-align: center;">addi \<span class="math inline">\(s1,\\\)</span>s2,20</td><td style="text-align: center;">\$s1=\<span class="math inline">\(2+20 | | | 取字 | lw \\\)</span>s1,20(\<span class="math inline">\(s2) | \\\)</span>s1=memory[\$s2+20] | | | 存字 | sw \<span class="math inline">\(s1,20(\\\)</span>s2) | memory[\$s2+20]=\<span class="math inline">\(s1 | | | 取半字 | lh \\\)</span>s1,20(\<span class="math inline">\(s2) | memory[\\\)</span>s2+20]=\<span class="math inline">\(s1 | 从地址20(\\\)</span>s2)开始取半字（16biwordts）（h==halfword）</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">取无符号半字</td><td style="text-align: center;">lhu \<span class="math inline">\(s1,20(\\\)</span>s2)</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">存半字</td><td style="text-align: center;">sh \<span class="math inline">\(s1,20(\$s2) | | | | 取字节 | lb \\\)</span>s1,20(\<span class="math inline">\(s2) | | | | 取无符号字节 | lbu \\\)</span>s1,20(\<span class="math inline">\(s2) | | | | 存字节 | sb \\\)</span>s1,20(\<span class="math inline">\(s2) | | | | 取链接字 | ll \\\)</span>s1,20($s2)</td><td style="text-align: center;"></td><td style="text-align: center;">是原子交换的前半部分</td></tr><tr class="even"><td style="text-align: center;">存条件字</td><td style="text-align: center;">sc \<span class="math inline">\(s1,20(\\\)</span>s2)</td><td style="text-align: center;"></td><td style="text-align: center;">是原子交换的后半部分</td></tr><tr class="odd"><td style="text-align: center;">取立即数的最高位</td><td style="text-align: center;">lui \<span class="math inline">\(s1,20 | \\\)</span>s1=20*2^{16}</td><td style="text-align: center;">取立即数并放到高16位</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">与</td><td style="text-align: center;">and \<span class="math inline">\(s1,\\\)</span>s2,\<span class="math inline">\(s3 | \\\)</span>s1=\<span class="math inline">\(s2 &amp; \\\)</span>s3</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">或</td><td style="text-align: center;">or \<span class="math inline">\(s1,\\\)</span>s2,\<span class="math inline">\(s3 | \\\)</span>s1=\<span class="math inline">\(s2 bitor \\\)</span>s3</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">或非</td><td style="text-align: center;">or \<span class="math inline">\(s1,\\\)</span>s2,\<span class="math inline">\(s3 | \\\)</span>s1=~(\<span class="math inline">\(s2 bitor \\\)</span>s3)</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">立即数与</td><td style="text-align: center;">andi \<span class="math inline">\(s1,\\\)</span>s2,20</td><td style="text-align: center;">\<span class="math inline">\(s1=\\\)</span>s2 &amp; 20</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">立即数或</td><td style="text-align: center;">ori \<span class="math inline">\(s1,\\\)</span>s2,20</td><td style="text-align: center;">\<span class="math inline">\(s1=\\\)</span>s2 bitor 20</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">逻辑左移</td><td style="text-align: center;">sll \<span class="math inline">\(s1,\\\)</span>s2,10</td><td style="text-align: center;">\<span class="math inline">\(s1=\\\)</span>s2*4（左移两位）</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">逻辑右移</td><td style="text-align: center;">srl \<span class="math inline">\(s1,\\\)</span>s2,20</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">相等时跳转</td><td style="text-align: center;">beq \<span class="math inline">\(s1,\\\)</span>s2,25</td><td style="text-align: center;">if(\<span class="math inline">\(s1==\\\)</span>s2) goto PC+4+100</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">不相等时跳转</td><td style="text-align: center;">bne \<span class="math inline">\(s1,\\\)</span>s2,25</td><td style="text-align: center;">if(\$s1!=\<span class="math inline">\(2) goto PC+4+100 | | | 小于时置位 | slt \\\)</span>s1,\<span class="math inline">\(s2,\\\)</span>s3</td><td style="text-align: center;">if(\<span class="math inline">\(s2&lt;\\\)</span>s3) \<span class="math inline">\(s1=1 else \\\)</span>s1=0</td></tr><tr class="odd"><td style="text-align: center;">无符号数比较小于时置位</td><td style="text-align: center;">sltu \<span class="math inline">\(s1,\\\)</span>s2,\<span class="math inline">\(s3 | if(\\\)</span>s2&lt;\<span class="math inline">\(s3) \\\)</span>s1=1 else \<span class="math inline">\(s1=0 | 比较是否小于无符号数 | | 无符号数比较小于立即数时置位 | slti \\\)</span>s1,\<span class="math inline">\(s2,20 | if(\\\)</span>s2&lt;20) \<span class="math inline">\(s1=1 else \\\)</span>s1=0</td><td style="text-align: center;">比较是否小于常数</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">无符号数比较小于无符号数时置位</td><td style="text-align: center;">sltiu \<span class="math inline">\(s1,\\\)</span>s2,20</td><td style="text-align: center;">if(\<span class="math inline">\(s2&lt;20) \\\)</span>s1=1 else \<span class="math inline">\(s1=0 | 比较是否小于无符号常数 | | 跳转 | j 2500 | goto 10000 | 跳转到目标地址 | | 跳转到寄存器所指位置 | jr \\\)</span>ra</td><td style="text-align: center;">goto \$</td></tr><tr class="odd"><td style="text-align: center;">跳转并链接</td><td style="text-align: center;">jal 2500</td><td style="text-align: center;">\$ra=PC+4; goto 10000</td><td style="text-align: center;">用于过程调用</td></tr></tbody></table><p><strong>MIPS32指令集文档：https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00086-2B-MIPS32BIS-AFP-6.06.pdf</strong></p><h4 id="三种指令格式">三种指令格式</h4><ul><li>R-型</li></ul><table><thead><tr class="header"><th style="text-align: center;">op</th><th style="text-align: center;">rs</th><th style="text-align: center;">rt</th><th style="text-align: center;">rd</th><th style="text-align: center;">shamt</th><th style="text-align: center;">funct</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">6bits</td><td style="text-align: center;">5bits</td><td style="text-align: center;">5bits</td><td style="text-align: center;">5bits</td><td style="text-align: center;">5bits</td><td style="text-align: center;">6bits</td></tr></tbody></table><p>其中：</p><ul><li>op：操作码</li><li>rs：第一个源寄存器编号</li><li>rt：第二个源寄存器编号</li><li>rd：destination目的寄存器编号</li><li>shamt：移位位数（00000表示不移位），仅在位移指令中使用</li><li>funct：功能码，用于选择op操作中的具体函数，如运算操作中的加法函数</li><li><p>R-型指令包括：add,sub,and,or,nor,slt,sltu,sll,srl,jr</p></li><li><p>I-型指令</p></li></ul><table><thead><tr class="header"><th style="text-align: center;">op</th><th style="text-align: center;">rs</th><th style="text-align: center;">rt</th><th style="text-align: center;">constant or address</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">6bits</td><td style="text-align: center;">5bits</td><td style="text-align: center;">5bits</td><td style="text-align: center;">16bits</td></tr></tbody></table><p>其中：</p><ul><li>op：操作码</li><li>rs：第一个源操作数寄存器号，参与运算使用</li><li>rt：第二个源操作数寄存器号，参与运算使用</li><li>16位立即数</li><li><p>I-型指令包括：addi,lw,sw,lh,sh,lb,sb,ll,sc,lui,andi,ori,beq,bne,slti,sltiu</p></li><li><p>J-型指令</p></li></ul><table><thead><tr class="header"><th style="text-align: center;">op</th><th style="text-align: center;">address</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">6bits</td><td style="text-align: center;">26bits</td></tr></tbody></table><ul><li>目标地址计算方法：dst=PC+4+address&lt;&lt;2（下一条指令的地址时当前PC加上4后，取最高的四位，再加上J型指令编码中的26位左移2位（×4）的结果）</li><li><p>J-型指令有：j, jr, jal</p></li><li><p>MIPS中的同步</p><ul><li><p>背景：处理器共享存储器同一区域，P1写，P2读。P1写的结果是P2要读的值，如果P1和P2不同步，将会发生数据竞争</p></li><li><p>解决方法：依赖硬件提供同步指令，即原子读/写内存操作</p></li><li><p>MIPS中靠ll和sc这两个指令实现同步</p><blockquote><p>LL 指令的功能是从内存中读取一个字，以实现接下来的 RMW（Read-Modify-Write） 操作；SC 指令的功能是向内存中写入一个字，以完成前面的 RMW 操作。LL/SC 指令的独特之处在于，它们不是一个简单的内存读取/写入的函数，当使用 LL 指令从内存中读取一个字之后，比如 LL d, off(b)，处理器会记住 LL 指令的这次操作（会在 CPU 的寄存器中设置一个不可见的 bit 位），同时 LL 指令读取的地址 off(b) 也会保存在处理器的寄存器中。接下来的 SC 指令，比如 SC t, off(b)，会检查上次 LL 指令执行后的 RMW 操作是否是原子操作（即不存在其它对这个地址的操作），如果是原子操作，则 t 的值将会被更新至内存中，同时 t 的值也会变为1，表示操作成功；反之，如果 RMW 的操作不是原子操作（即存在其它对这个地址的访问冲突），则 t 的值不会被更新至内存中，且 t 的值也会变为0，表示操作失败。</p></blockquote></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f928ffc1cd1bbb86bf44e2f.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机系统三" scheme="https://xtayex.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%89/"/>
    
    
    <category term="计算机系统三" scheme="https://xtayex.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%89/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统三（一）——计算机概要与技术</title>
    <link href="https://xtayex.gitee.io/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%A6%81%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    <id>https://xtayex.gitee.io/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%A6%81%E4%B8%8E%E6%8A%80%E6%9C%AF/</id>
    <published>2020-10-23T03:17:00.000Z</published>
    <updated>2022-09-27T13:46:54.907Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5f924bd31cd1bbb86be6ec2b.jpg"> <span id="more"></span></p><h4 id="八个伟大思想">八个伟大思想</h4><ul><li>面向摩尔定律的设计</li><li>使用抽象简化设计</li><li>加速大概率时间</li><li>通过并行提高性能</li><li>通过流水线提高性能</li><li>存储器层次</li><li>通过冗余提高可靠性</li></ul><h4 id="集成电路的成本">集成电路的成本</h4><ul><li><span class="math inline">\(每芯片的价格=每晶圆的价格/(每晶圆的芯片数\times 成品率)\)</span></li><li><span class="math inline">\(每晶圆的芯片数\approx 晶圆面积/芯片面积\)</span></li><li><span class="math inline">\(成品率=1/(1+(单位面积的瑕疵数\times芯片面积/2))^2\)</span>（经验公式）</li><li>芯片面积与缺陷率非线性相关<ul><li>晶圆成本和面积是固定的</li><li>缺陷率取决于制造过程</li><li>芯片面积取决于结构和电路设计</li></ul></li></ul><h4 id="响应时间和吞吐量">响应时间和吞吐量</h4><ul><li><p>响应时间（也叫执行时间）</p><p>计算机完成某任务所需的总时间</p></li><li><p>吞吐量（也叫带宽）</p><p>单位时间段内完成的任务数</p></li></ul><h4 id="时钟周期时钟频率与cpi计算题">时钟周期、时钟频率与CPI（计算题）</h4><ul><li><p>时钟周期：从一个上升沿到下一个上升沿的时间</p></li><li><p>时钟频率=1/时钟周期</p></li><li><p>对于时钟频率，1ns的时钟周期对应1GHz的时钟频率，所以0.25ns的时钟周期对应4GHz的时钟频率</p></li><li><p>CPU时间=CPU时钟周期数×时钟周期=CPU时钟周期数×1/时钟频率</p></li><li><p>CPI：clocks per instruction，每条指令占用的平均时钟周期数</p></li><li><p>如果有n种不同类型指令，则</p><p>总cpu时钟周期数=<span class="math inline">\(\sum_{i=1}^n(CPI_i\times C_i)\)</span></p><p>加权平均CPI：CPU=<span class="math inline">\(总CPU时钟周期数/指令数=\sum_{i=1}^n(CPI_i\times\frac{C_i}{指令数})\)</span></p></li><li><p>能耗正比于：<span class="math inline">\(1/2\times负载电容\times电压^2\)</span></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f924bd31cd1bbb86be6ec2b.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机系统三" scheme="https://xtayex.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%89/"/>
    
    
    <category term="计算机系统三" scheme="https://xtayex.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%89/"/>
    
  </entry>
  
  <entry>
    <title>2020杭电多校第六场 I题</title>
    <link href="https://xtayex.gitee.io/2020/08/07/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA-I%E9%A2%98/"/>
    <id>https://xtayex.gitee.io/2020/08/07/2020%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA-I%E9%A2%98/</id>
    <published>2020-08-07T07:49:00.000Z</published>
    <updated>2022-09-27T13:46:54.895Z</updated>
    
    <content type="html"><![CDATA[<p><span style="color: grey;">没有封面图</span> <span id="more"></span></p><p>题意：对于给定的<span class="math display">\[b\]</span>进制数<span class="math display">\[y\]</span>，定义<span class="math display">\[f(y)\]</span>表示其<span class="math display">\[y\]</span>在<span class="math display">\[b\]</span>进制下的数位和。现在有这样的一个命题：对于任意的<span class="math display">\[b\]</span>进制数<span class="math display">\[y\]</span>和给定的<span class="math display">\[b\]</span>进制数<span class="math display">\[x\]</span>，如果<span class="math display">\[f(y)\]</span>整除<span class="math display">\[x\]</span>，则<span class="math display">\[y\]</span>也整除<span class="math display">\[x\]</span>。判断给定<span class="math display">\[b\]</span>和<span class="math display">\[x\]</span>下命题正确性。</p><p>思路：结论是，当<span class="math display">\[b\equiv 1 \pmod x\]</span>时，命题成立。原因在于，对于<span class="math display">\[b\]</span>进制的数<span class="math display">\[y\]</span>，可以将其表示为<span class="math display">\[y=c_0*b^0+c_1*b^1+c_2*b^2+\dots+c_{n-2}*b^{n-2}+c_{n-1}*b^{n-1}\]</span>。可以发现，如果<span class="math display">\[b\equiv 1\pmod x\]</span>，那么由于有<span class="math display">\[A\equiv B \pmod p\Leftrightarrow f(A)\equiv f(B)\pmod x\]</span>，所以，在这种情况下，有 <span class="math display">\[\begin{equation}c_0*b^0+c_1*b^1+c_2*b^2+\dots+c_{n-2}*b^{n-2}+c_{n-1}*b^{n-1}\equiv c_0+c_1+c_2+\dots+c_{n-2}+c_{n-1}\pmod x\end{equation}\]</span></p><p><span class="math display">\[c_0+c_1+c_2+\dots+c_{n-2}+c_{n-1}\]</span>就是题目中的<span class="math display">\[f(y)\]</span>。所以，结论成立。</p><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb1-6" title="6"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb1-7" title="7"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb1-8" title="8"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb1-9" title="9"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb1-10" title="10"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb1-11" title="11"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb1-12" title="12"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a><a class="sourceLine" id="cb1-13" title="13"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb1-14" title="14"><span class="pp">#define mst</span>(a,<span class="pp"> </span>b)<span class="pp"> </span>memset((a),<span class="pp"> </span>(b),<span class="pp"> </span><span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb1-15" title="15"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb1-16" title="16"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb1-17" title="17"><span class="pp">#define lson </span>lef,<span class="pp"> </span>mid,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb1-18" title="18"><span class="pp">#define rson </span>mid<span class="pp"> </span>+<span class="pp"> </span><span class="dv">1</span>,<span class="pp"> </span>rig,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span><span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb1-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</a><a class="sourceLine" id="cb1-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb1-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb1-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb1-23" title="23"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb1-24" title="24">{</a><a class="sourceLine" id="cb1-25" title="25">    <span class="dt">int</span> T;</a><a class="sourceLine" id="cb1-26" title="26">    scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>, &amp;T);</a><a class="sourceLine" id="cb1-27" title="27">    <span class="cf">while</span> (T--) {</a><a class="sourceLine" id="cb1-28" title="28">        ll b, x;</a><a class="sourceLine" id="cb1-29" title="29">        scanf(<span class="st">"</span><span class="sc">%lld</span><span class="st"> </span><span class="sc">%lld</span><span class="st">"</span>, &amp;b, &amp;x);</a><a class="sourceLine" id="cb1-30" title="30">        <span class="cf">if</span> (b &lt; x) {</a><a class="sourceLine" id="cb1-31" title="31">            puts(<span class="st">"F"</span>);</a><a class="sourceLine" id="cb1-32" title="32">        } <span class="cf">else</span> {</a><a class="sourceLine" id="cb1-33" title="33">            <span class="cf">if</span> (b % x == <span class="dv">1</span><span class="bu">LL</span>)</a><a class="sourceLine" id="cb1-34" title="34">                puts(<span class="st">"T"</span>);</a><a class="sourceLine" id="cb1-35" title="35">            <span class="cf">else</span></a><a class="sourceLine" id="cb1-36" title="36">                puts(<span class="st">"F"</span>);</a><a class="sourceLine" id="cb1-37" title="37">        }</a><a class="sourceLine" id="cb1-38" title="38">    }</a><a class="sourceLine" id="cb1-39" title="39">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-40" title="40">}</a></code></pre></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;span style=&quot;color: grey;&quot;&gt;没有封面图&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/categories/ACM/"/>
    
    <category term="思维" scheme="https://xtayex.gitee.io/categories/ACM/%E6%80%9D%E7%BB%B4/"/>
    
    <category term="数学" scheme="https://xtayex.gitee.io/categories/ACM/%E6%80%9D%E7%BB%B4/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/tags/ACM/"/>
    
    <category term="思维" scheme="https://xtayex.gitee.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
    <category term="数学" scheme="https://xtayex.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1389 B&amp;C</title>
    <link href="https://xtayex.gitee.io/2020/08/06/Codeforces-1389B-Array-Walk/"/>
    <id>https://xtayex.gitee.io/2020/08/06/Codeforces-1389B-Array-Walk/</id>
    <published>2020-08-06T00:43:43.000Z</published>
    <updated>2022-09-27T13:46:54.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="b.-array-walk">B. Array Walk</h2><p>题意：给定一个长度为<span class="math inline">\(n\)</span>的序列，从下标1开始，走<span class="math inline">\(k\)</span>步，其中最多<span class="math inline">\(z\)</span>步向左。每走到一个位置就取一次这个位置的数。问可以取到的最大总和是多少。</p><span id="more"></span><p>思路：考虑dp，<span class="math inline">\(dp[i][j]\)</span>表示走了<span class="math inline">\(i\)</span>步，<span class="math inline">\(j\)</span>步为向左时的最大总和。则当<span class="math inline">\(dp[i][j]\)</span>可以由走了<span class="math inline">\(i-1\)</span>步、现在向右走以及走了<span class="math inline">\(i-1\)</span>步、现在向左走这两个状态转移而来</p><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb1-6" title="6"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb1-7" title="7"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb1-8" title="8"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb1-9" title="9"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb1-10" title="10"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb1-11" title="11"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb1-12" title="12"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a><a class="sourceLine" id="cb1-13" title="13"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb1-14" title="14"><span class="pp">#define mst</span>(a,<span class="pp"> </span>b)<span class="pp"> </span>memset((a),<span class="pp"> </span>(b),<span class="pp"> </span><span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb1-15" title="15"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb1-16" title="16"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb1-17" title="17"><span class="pp">#define lson </span>lef,<span class="pp"> </span>mid,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb1-18" title="18"><span class="pp">#define rson </span>mid<span class="pp"> </span>+<span class="pp"> </span><span class="dv">1</span>,<span class="pp"> </span>rig,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span><span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb1-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</a><a class="sourceLine" id="cb1-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb1-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb1-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb1-23" title="23"><span class="dt">int</span> a[maxn], dp[maxn][<span class="dv">6</span>];</a><a class="sourceLine" id="cb1-24" title="24"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb1-25" title="25">{</a><a class="sourceLine" id="cb1-26" title="26">    <span class="dt">int</span> T;</a><a class="sourceLine" id="cb1-27" title="27">    scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>, &amp;T);</a><a class="sourceLine" id="cb1-28" title="28">    <span class="cf">while</span> (T--) {</a><a class="sourceLine" id="cb1-29" title="29">        <span class="dt">int</span> n, k, z;</a><a class="sourceLine" id="cb1-30" title="30">        scanf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>, &amp;n, &amp;k, &amp;z);</a><a class="sourceLine" id="cb1-31" title="31">        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {</a><a class="sourceLine" id="cb1-32" title="32">            scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>, &amp;a[i]);</a><a class="sourceLine" id="cb1-33" title="33">        }</a><a class="sourceLine" id="cb1-34" title="34">        dp[<span class="dv">0</span>][<span class="dv">0</span>] = a[<span class="dv">1</span>];</a><a class="sourceLine" id="cb1-35" title="35">        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= k; i++) {</a><a class="sourceLine" id="cb1-36" title="36">            <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= z; j++) {</a><a class="sourceLine" id="cb1-37" title="37">                dp[i][j] = dp[i - <span class="dv">1</span>][j] + a[<span class="dv">1</span> + i - <span class="dv">2</span> * j];</a><a class="sourceLine" id="cb1-38" title="38">                <span class="cf">if</span> (j &gt; <span class="dv">0</span>)</a><a class="sourceLine" id="cb1-39" title="39">                    dp[i][j] = max(dp[i][j], dp[i - <span class="dv">1</span>][j - <span class="dv">1</span>] + a[<span class="dv">1</span> + i - <span class="dv">2</span> * j]);</a><a class="sourceLine" id="cb1-40" title="40">            }</a><a class="sourceLine" id="cb1-41" title="41">        }</a><a class="sourceLine" id="cb1-42" title="42">        <span class="dt">int</span> ans = <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-43" title="43">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= z; j++) {</a><a class="sourceLine" id="cb1-44" title="44">            ans = max(ans, dp[k][j]);</a><a class="sourceLine" id="cb1-45" title="45">        }</a><a class="sourceLine" id="cb1-46" title="46">        printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, ans);</a><a class="sourceLine" id="cb1-47" title="47">    }</a><a class="sourceLine" id="cb1-48" title="48">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-49" title="49">}</a></code></pre></div><h2 id="c.-good-string">C. Good String</h2><p>题意：如果将一个字符串循环左移一位与循环右移一位后，得到的两个新字符串相等，则称该字符串为good string。给定一个字符串<span class="math inline">\(s\)</span>，问需要至少删除<span class="math inline">\(s\)</span>中多少个字符，才能使其变成good string。</p><p>思路：容易发现，good string只有两种情况：1、整个字符串只有一种字符；2、字符串形如<span class="math inline">\(ababab...\)</span>，且长度为偶数。对于第一种情况，只需要找出出现次数最多的字符即可；对于第二种情况，因为字符只有10种，暴力枚举一下可以组成good string的两种字符就行。</p><div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb2-3" title="3"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb2-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb2-5" title="5"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb2-6" title="6"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb2-7" title="7"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb2-8" title="8"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb2-9" title="9"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb2-10" title="10"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb2-11" title="11"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb2-12" title="12"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a><a class="sourceLine" id="cb2-13" title="13"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb2-14" title="14"><span class="pp">#define mst</span>(a,<span class="pp"> </span>b)<span class="pp"> </span>memset((a),<span class="pp"> </span>(b),<span class="pp"> </span><span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb2-15" title="15"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb2-16" title="16"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb2-17" title="17"><span class="pp">#define lson </span>lef,<span class="pp"> </span>mid,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb2-18" title="18"><span class="pp">#define rson </span>mid<span class="pp"> </span>+<span class="pp"> </span><span class="dv">1</span>,<span class="pp"> </span>rig,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span><span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb2-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</a><a class="sourceLine" id="cb2-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb2-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb2-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb2-23" title="23"><span class="dt">char</span> s[maxn];</a><a class="sourceLine" id="cb2-24" title="24"><span class="dt">int</span> cnt[<span class="dv">10</span>] = { <span class="dv">0</span> };</a><a class="sourceLine" id="cb2-25" title="25"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb2-26" title="26">{</a><a class="sourceLine" id="cb2-27" title="27">    <span class="dt">int</span> T;</a><a class="sourceLine" id="cb2-28" title="28">    scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>, &amp;T);</a><a class="sourceLine" id="cb2-29" title="29">    <span class="cf">while</span> (T--) {</a><a class="sourceLine" id="cb2-30" title="30">        mst(cnt, <span class="dv">0</span>);</a><a class="sourceLine" id="cb2-31" title="31">        scanf(<span class="st">"</span><span class="sc">%s</span><span class="st">"</span>, s + <span class="dv">1</span>);</a><a class="sourceLine" id="cb2-32" title="32">        <span class="dt">int</span> len = strlen(s + <span class="dv">1</span>);</a><a class="sourceLine" id="cb2-33" title="33">        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= len; i++) {</a><a class="sourceLine" id="cb2-34" title="34">            cnt[s[i] - <span class="ch">'0'</span>]++;</a><a class="sourceLine" id="cb2-35" title="35">        }</a><a class="sourceLine" id="cb2-36" title="36">        <span class="dt">int</span> maxi = <span class="dv">0</span>;</a><a class="sourceLine" id="cb2-37" title="37">        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= <span class="dv">9</span>; i++) {</a><a class="sourceLine" id="cb2-38" title="38">            maxi = max(maxi, cnt[i]);</a><a class="sourceLine" id="cb2-39" title="39">        }</a><a class="sourceLine" id="cb2-40" title="40">        <span class="dt">int</span> ans2 = <span class="dv">0</span>;</a><a class="sourceLine" id="cb2-41" title="41">        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= <span class="dv">9</span>; i++) {</a><a class="sourceLine" id="cb2-42" title="42">            <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= <span class="dv">9</span>; j++) {</a><a class="sourceLine" id="cb2-43" title="43">                <span class="dt">int</span> l=<span class="dv">0</span>;</a><a class="sourceLine" id="cb2-44" title="44">                <span class="cf">for</span>(<span class="dt">int</span> k=<span class="dv">1</span>;k&lt;=len;k++){</a><a class="sourceLine" id="cb2-45" title="45">                    <span class="cf">if</span>(l%<span class="dv">2</span>==<span class="dv">0</span>){</a><a class="sourceLine" id="cb2-46" title="46">                        <span class="cf">if</span>(s[k]==i+<span class="ch">'0'</span>) l++;</a><a class="sourceLine" id="cb2-47" title="47">                    }<span class="cf">else</span>{</a><a class="sourceLine" id="cb2-48" title="48">                        <span class="cf">if</span>(s[k]==j+<span class="ch">'0'</span>) l++;</a><a class="sourceLine" id="cb2-49" title="49">                    }</a><a class="sourceLine" id="cb2-50" title="50">                }</a><a class="sourceLine" id="cb2-51" title="51">                <span class="cf">if</span>(l&amp;<span class="dv">1</span>) l--;</a><a class="sourceLine" id="cb2-52" title="52">                ans2=max(ans2,l);</a><a class="sourceLine" id="cb2-53" title="53">            }</a><a class="sourceLine" id="cb2-54" title="54">        }</a><a class="sourceLine" id="cb2-55" title="55">        <span class="co">//printf("ans2 = %d\n", ans2);</span></a><a class="sourceLine" id="cb2-56" title="56">        ans2 = len - ans2;</a><a class="sourceLine" id="cb2-57" title="57">        <span class="dt">int</span> ans1 = len - maxi;</a><a class="sourceLine" id="cb2-58" title="58">        printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, min(ans2, ans1));</a><a class="sourceLine" id="cb2-59" title="59">    }</a><a class="sourceLine" id="cb2-60" title="60">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb2-61" title="61">}</a></code></pre></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;b.-array-walk&quot;&gt;B. Array Walk&lt;/h2&gt;
&lt;p&gt;题意：给定一个长度为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的序列，从下标1开始，走&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;步，其中最多&lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;步向左。每走到一个位置就取一次这个位置的数。问可以取到的最大总和是多少。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JS中的展开语法</title>
    <link href="https://xtayex.gitee.io/2020/08/04/JS%E4%B8%AD%E7%9A%84%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://xtayex.gitee.io/2020/08/04/JS%E4%B8%AD%E7%9A%84%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-08-04T06:47:57.000Z</published>
    <updated>2022-09-27T13:46:55.103Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5f29068a14195aa594529081.jpg"> <span id="more"></span></p><p>看代码的时候遇到了下面这样一段：</p><div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">function</span> <span class="at">generateSkeleton</span>() <span class="op">{</span></a><a class="sourceLine" id="cb1-2" title="2">  <span class="co">// 文字节点</span></a><a class="sourceLine" id="cb1-3" title="3">  <span class="op">;</span>[...<span class="va">document</span>.<span class="at">querySelectorAll</span>(<span class="st">'*'</span>)]</a><a class="sourceLine" id="cb1-4" title="4">    .<span class="at">filter</span>(</a><a class="sourceLine" id="cb1-5" title="5">      (node) <span class="kw">=&gt;</span></a><a class="sourceLine" id="cb1-6" title="6">        <span class="op">!</span>[<span class="st">'script'</span><span class="op">,</span> <span class="st">'style'</span><span class="op">,</span> <span class="st">'html'</span><span class="op">,</span> <span class="st">'body'</span><span class="op">,</span> <span class="st">'head'</span><span class="op">,</span> <span class="st">'title'</span>].<span class="at">includes</span>(</a><a class="sourceLine" id="cb1-7" title="7">          <span class="va">node</span>.<span class="va">tagName</span>.<span class="at">toLowerCase</span>()</a><a class="sourceLine" id="cb1-8" title="8">        )</a><a class="sourceLine" id="cb1-9" title="9">    )</a><a class="sourceLine" id="cb1-10" title="10">    .<span class="at">map</span>((node) <span class="kw">=&gt;</span> [...<span class="va">node</span>.<span class="at">childNodes</span>].<span class="at">filter</span>((node) <span class="kw">=&gt;</span> node <span class="kw">instanceof</span> Text))</a><a class="sourceLine" id="cb1-11" title="11">    .<span class="at">flat</span>(<span class="kw">Infinity</span>)</a><a class="sourceLine" id="cb1-12" title="12">    .<span class="at">forEach</span>((node) <span class="kw">=&gt;</span> <span class="op">{</span></a><a class="sourceLine" id="cb1-13" title="13">      <span class="kw">let</span> span <span class="op">=</span> <span class="va">document</span>.<span class="at">createElement</span>(<span class="st">'span'</span>)</a><a class="sourceLine" id="cb1-14" title="14">      <span class="va">node</span>.<span class="va">parentNode</span>.<span class="at">insertBefore</span>(span<span class="op">,</span> node)</a><a class="sourceLine" id="cb1-15" title="15">      <span class="va">span</span>.<span class="at">appendChild</span>(node)</a><a class="sourceLine" id="cb1-16" title="16">      <span class="va">span</span>.<span class="at">style</span> <span class="op">=</span> <span class="vs">`</span></a><a class="sourceLine" id="cb1-17" title="17"><span class="vs">        background: #f2f2f2;</span></a><a class="sourceLine" id="cb1-18" title="18"><span class="vs">        color: transparent !important;</span></a><a class="sourceLine" id="cb1-19" title="19"><span class="vs">      `</span></a><a class="sourceLine" id="cb1-20" title="20">    <span class="op">}</span>)</a><a class="sourceLine" id="cb1-21" title="21"><span class="op">}</span></a></code></pre></div><p>(代码链接：https://zhuanlan.zhihu.com/p/166009071)</p><p>发现有“...”这样的语法。查了一下文档，原来这是js中的展开语法。MDN上的定义为:</p><blockquote><p><strong>展开语法(Spread syntax),</strong> 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。</p></blockquote><p>以上面代码中的</p><div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1">...<span class="va">document</span>.<span class="at">querySelectorAll</span>(<span class="st">'*'</span>)</a></code></pre></div><p>为例，在chrome中的运行结果是：</p><p><img src="https://pic.downk.cc/item/5f29032d14195aa59450fba2.jpg"></p><p>在这里，...把一个nodelist展开来，作为Array的构造参数。</p><p>再看一个在String中应用的一个例子</p><p><img src="https://pic.downk.cc/item/5f29040c14195aa5945151b3.jpg"></p><p>不难明白，“...“的作用其实就是把nodelist，string等可迭代的东西展开来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f29068a14195aa594529081.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>【OpenGL学习笔记】一、VBO，VAO与EBO</title>
    <link href="https://xtayex.gitee.io/2020/07/25/%E3%80%90OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81VBO%EF%BC%8CVAO%E4%B8%8EEBO/"/>
    <id>https://xtayex.gitee.io/2020/07/25/%E3%80%90OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81VBO%EF%BC%8CVAO%E4%B8%8EEBO/</id>
    <published>2020-07-25T01:22:00.000Z</published>
    <updated>2022-09-27T13:46:54.907Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5f1b8a4e14195aa594516bd0.png"> <span id="more"></span> ### 前言 VBO、VAO和EBO是OpenGL中三个很基础的概念，但一开始时总是分不清他们的区别与联系。 ### 正文 * VBO：顶点缓冲对象</p><ul><li><p>是在显卡存储空间中开辟的一块内存缓存区，用于存储顶点的各类属性（顶点坐标、顶点法向量、顶点颜色等）</p></li><li><p>渲染时，可以直接从VBO中取出顶点的各类属性数据</p></li><li><p>每个VBO都有其唯一标识ID</p></li><li><p>使用glGenBuffers开辟VBO并分配id</p><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">unsigned</span> <span class="dt">int</span> VBO;</a><a class="sourceLine" id="cb1-2" title="2">glGenBuffers(<span class="dv">1</span>,&amp;VBO);</a></code></pre></div></li><li><p>通过glBindBuffer将某种类型的顶点数据绑定到某个VBO上（可以暂时理解为告诉该VBO它要存储的数据的类型，当然这是不准确的，因为同一类型的顶点数据一次只能绑定一个VBO）。绑定的类型必须是以下几种中的一种</p><ul><li>GL_ARRAY_BUFFER</li><li>GL_ELEMENT_ARRAY_BUFFER</li><li>GL_PIXEL_PACK_BUFFER</li><li>GL_PIXEL_UNPACK_BUFFER</li></ul><div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">unsigned</span> <span class="dt">int</span> VBO;</a><a class="sourceLine" id="cb2-2" title="2">glGenBuffers(<span class="dv">1</span>,&amp;VBO);</a><a class="sourceLine" id="cb2-3" title="3">glBindBuffer(GL_ARRAY_BUFFER,VBO);</a></code></pre></div></li><li><p>通过glBufferData将数据传送到绑定的VBO中</p><div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1">glBufferData(GL_ARRAY_BUFFER,<span class="kw">sizeof</span>(vertices),vertices,GL_STATIC_DRAW);</a></code></pre></div></li><li><p>使用glVertexAttribPointer告知OpenGL如何处理某个VBO中的数据</p><div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1">glVertexAttribPointer(<span class="dv">0</span>,<span class="dv">4</span>,GL_FLOAT,GL_FALSE,<span class="dv">0</span>,(<span class="dt">void</span>*)<span class="dv">0</span>);</a></code></pre></div><ul><li>第一个参数指定顶点属性位置，与顶点着色器中的layout(location=0)对应</li><li>第二个参数指定一个顶点属性组的大小（数据元素个数）</li><li>第三个参数指定顶点属性数据类型</li><li>第四个参数指定数据是否要被标准化</li><li>第五个参数是步长，指定连续顶点属性组之间的间隔。比方说三个GL_FLOAT数据表示一个坐标点，那就把他们作为一个属性组，步长就是3*sizeof(float)</li><li>第六个参数是数据起始位置距离缓冲区中起始位置的偏移量</li></ul></li><li><p>使用glEnableVertexAttribArray开启glVertexAttribPointer。由于glVertexAttribPointer默认是关闭的，所以使用时要用顶点属性位置的值为参数，通过glEnableVertexAttribArray来开启这一功能</p><div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1">glEnableVertexAttribArray(<span class="dv">0</span>)</a></code></pre></div></li><li><p>VAO：顶点数组对象</p><ul><li><p>保存了很多VBO的引用，相当于把很多VBO统一到一个对象中进行管理</p></li><li><p>使用glGenVertexArrays得到一个VAO，并分配id</p><div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1">glGenVertexArrays(<span class="dv">1</span>,&amp;VAO);</a></code></pre></div></li><li><p>使用glBindVertexArray绑定VAO。绑定后，后面所有VBO的引用都会被保存在这一个VAO中。</p></li><li><p>VAO的存在意义是减少绑定的工作量。因为每次绘制某些之前都需要绑定顶点的所有信息到对应的VBO中。这样做未免有点太麻烦，尤其是数据量很大的情况下。使用VAO，可以把所有顶点信息都绑定到VBO后，再通过VAO把所有顶点信息绑定到一个对象上(VAO)，后面只需要绑定VAO这一个对象即可。</p></li></ul></li><li><p>EBO：索引缓存对象</p><ul><li>存储顶点的索引，避免因为某些点重复存储导致的空间浪费</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f1b8a4e14195aa594516bd0.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OpenGL学习笔记" scheme="https://xtayex.gitee.io/categories/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机图形学" scheme="https://xtayex.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://xtayex.gitee.io/tags/OpenGL/"/>
    
    <category term="OpenGL学习笔记" scheme="https://xtayex.gitee.io/tags/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2020牛客多校第三场</title>
    <link href="https://xtayex.gitee.io/2020/07/19/2020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA/"/>
    <id>https://xtayex.gitee.io/2020/07/19/2020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA/</id>
    <published>2020-07-19T14:17:00.000Z</published>
    <updated>2022-09-27T13:46:54.883Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5f14552214195aa594e12634.jpg"> <span id="more"></span></p><h3 id="a-贪心">A 贪心</h3><p>给定四种状态，状态0没有钓鱼也不能做鱼饵；状态1可以做鱼饵，但是没有鱼；状态三有鱼但不能做鱼饵；状态四有鱼也可以做鱼饵。没有鱼的状态下，如果有鱼饵，可以钓鱼。</p><p>做法是简单贪心。有鱼的时候直接钓鱼，没鱼但能做鱼饵就做鱼饵，没鱼且不能做鱼饵就看看有没有鱼饵可以用来钓鱼。从左到右扫一遍，如果最后发现鱼饵有剩下，那就答案加上<strong>鱼饵数/2</strong>，表示原本做鱼饵的状态，一半用来做鱼饵，一般用这些做出来的鱼饵钓鱼</p><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb1-6" title="6"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb1-7" title="7"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb1-8" title="8"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb1-9" title="9"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb1-10" title="10"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb1-11" title="11"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb1-12" title="12"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a><a class="sourceLine" id="cb1-13" title="13"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb1-14" title="14"><span class="pp">#define mst</span>(a,<span class="pp"> </span>b)<span class="pp"> </span>memset((a),<span class="pp"> </span>(b),<span class="pp"> </span><span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb1-15" title="15"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb1-16" title="16"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb1-17" title="17"><span class="pp">#define lson </span>lef,<span class="pp"> </span>mid,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb1-18" title="18"><span class="pp">#define rson </span>mid<span class="pp"> </span>+<span class="pp"> </span><span class="dv">1</span>,<span class="pp"> </span>rig,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span><span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb1-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e6</span> + <span class="dv">5</span>;</a><a class="sourceLine" id="cb1-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb1-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb1-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb1-23" title="23"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb1-24" title="24">{</a><a class="sourceLine" id="cb1-25" title="25">    <span class="dt">int</span> T;</a><a class="sourceLine" id="cb1-26" title="26">    scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>, &amp;T);</a><a class="sourceLine" id="cb1-27" title="27">    <span class="cf">while</span> (T--) {</a><a class="sourceLine" id="cb1-28" title="28">        <span class="dt">int</span> n;scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;n);</a><a class="sourceLine" id="cb1-29" title="29">        <span class="dt">int</span> ba=<span class="dv">0</span>,ans=<span class="dv">0</span>;<span class="dt">int</span> tmp;</a><a class="sourceLine" id="cb1-30" title="30">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){</a><a class="sourceLine" id="cb1-31" title="31">            scanf(<span class="st">"%1d"</span>,&amp;tmp);</a><a class="sourceLine" id="cb1-32" title="32">            <span class="cf">if</span>(tmp==<span class="dv">2</span>||tmp==<span class="dv">3</span>) ans++;</a><a class="sourceLine" id="cb1-33" title="33">            <span class="cf">else</span> <span class="cf">if</span>(tmp==<span class="dv">1</span>) ba++;</a><a class="sourceLine" id="cb1-34" title="34">            <span class="cf">else</span>{</a><a class="sourceLine" id="cb1-35" title="35">                <span class="cf">if</span>(ba&gt;<span class="dv">0</span>) ba--,ans++;</a><a class="sourceLine" id="cb1-36" title="36">            }</a><a class="sourceLine" id="cb1-37" title="37">        }</a><a class="sourceLine" id="cb1-38" title="38">        printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>,ans+ba/<span class="dv">2</span>);</a><a class="sourceLine" id="cb1-39" title="39">    }</a><a class="sourceLine" id="cb1-40" title="40">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-41" title="41">}</a></code></pre></div><h3 id="b-简单思维题">B 简单思维题</h3><p>刚看完题目的时候以为是线段树or Splay区间搬移，但想到签到题不太可能需要用到复杂的数据结构。后来wxdl说有很简单的思路，于是我就去看其他题了。赛后发现，实际上只需要移动指针即可维护答案。</p><div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb2-3" title="3"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb2-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb2-5" title="5"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb2-6" title="6"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb2-7" title="7"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb2-8" title="8"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb2-9" title="9"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb2-10" title="10"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb2-11" title="11"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb2-12" title="12"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb2-13" title="13"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a><a class="sourceLine" id="cb2-14" title="14"><span class="pp">#define mst</span>(a,b)<span class="pp"> </span>memset((a),(b),<span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb2-15" title="15"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb2-16" title="16"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb2-17" title="17"><span class="pp">#define lson </span>lef,mid,rt&lt;&lt;<span class="dv">1</span></a><a class="sourceLine" id="cb2-18" title="18"><span class="pp">#define rson </span>mid+<span class="dv">1</span>,rig,rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span></a><a class="sourceLine" id="cb2-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn=<span class="fl">2e6</span>+<span class="dv">5</span>;</a><a class="sourceLine" id="cb2-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb2-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb2-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb2-23" title="23"><span class="dt">char</span> s[maxn];</a><a class="sourceLine" id="cb2-24" title="24"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb2-25" title="25">{</a><a class="sourceLine" id="cb2-26" title="26">    scanf(<span class="st">"</span><span class="sc">%s</span><span class="st">"</span>,s);</a><a class="sourceLine" id="cb2-27" title="27">    <span class="dt">int</span> len=strlen(s);</a><a class="sourceLine" id="cb2-28" title="28">    <span class="dt">int</span> q;scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;q);</a><a class="sourceLine" id="cb2-29" title="29">    <span class="dt">int</span> p=<span class="dv">0</span>;</a><a class="sourceLine" id="cb2-30" title="30">    <span class="cf">while</span>(q--){</a><a class="sourceLine" id="cb2-31" title="31">        <span class="dt">char</span> op[<span class="dv">2</span>];<span class="dt">int</span> x;</a><a class="sourceLine" id="cb2-32" title="32">        scanf(<span class="st">"</span><span class="sc">%s</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>,op,&amp;x);</a><a class="sourceLine" id="cb2-33" title="33">        <span class="cf">if</span>(op[<span class="dv">0</span>]==<span class="ch">'M'</span>){</a><a class="sourceLine" id="cb2-34" title="34">            <span class="cf">if</span>(x&gt;<span class="dv">0</span>){</a><a class="sourceLine" id="cb2-35" title="35">                p=(p+x)%len;</a><a class="sourceLine" id="cb2-36" title="36">            }<span class="cf">else</span>{</a><a class="sourceLine" id="cb2-37" title="37">                x=abs(x);</a><a class="sourceLine" id="cb2-38" title="38">                p-=x;</a><a class="sourceLine" id="cb2-39" title="39">                p=(p%len+len)%len;</a><a class="sourceLine" id="cb2-40" title="40">            }</a><a class="sourceLine" id="cb2-41" title="41">        }<span class="cf">else</span> <span class="cf">if</span>(op[<span class="dv">0</span>]==<span class="ch">'A'</span>){</a><a class="sourceLine" id="cb2-42" title="42">            x--;</a><a class="sourceLine" id="cb2-43" title="43">            printf(<span class="st">"</span><span class="sc">%c\n</span><span class="st">"</span>,s[(p+x)%len]);</a><a class="sourceLine" id="cb2-44" title="44">        }</a><a class="sourceLine" id="cb2-45" title="45">    }</a><a class="sourceLine" id="cb2-46" title="46">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb2-47" title="47">}</a></code></pre></div><h3 id="c-简单计算几何">C 简单计算几何</h3><p>给出右手的形状，并说明左手和右手是对称的。现在给出一组20个点的坐标，问这些坐标表示的是左手还是右手。</p><p>题目中一个很重要的条件是，测试数据中的手和题面中的手相比，只会平移和旋转，而不会放大缩小。同时又观察到，图中由一条长为6的边、一条长为1的边和一条长为3的边组成的手指只有拇指。所以可以搞一个宽度为4的窗口，找到这样的四个点：两组相邻点的距离分别是6和3。这样就能找到拇指的位置。找到之后，用叉乘判断下在拇指左侧的点多还是右侧的点多即可。</p><div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb3-2" title="2"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb3-3" title="3"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb3-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb3-5" title="5"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb3-6" title="6"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb3-7" title="7"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb3-8" title="8"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb3-9" title="9"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb3-10" title="10"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb3-11" title="11"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb3-12" title="12"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb3-13" title="13"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a><a class="sourceLine" id="cb3-14" title="14"><span class="pp">#define mst</span>(a,b)<span class="pp"> </span>memset((a),(b),<span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb3-15" title="15"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb3-16" title="16"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb3-17" title="17"><span class="pp">#define lson </span>lef,mid,rt&lt;&lt;<span class="dv">1</span></a><a class="sourceLine" id="cb3-18" title="18"><span class="pp">#define rson </span>mid+<span class="dv">1</span>,rig,rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span></a><a class="sourceLine" id="cb3-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn=<span class="fl">1e5</span>+<span class="dv">5</span>;</a><a class="sourceLine" id="cb3-20" title="20"><span class="at">const</span> <span class="dt">double</span> eps=<span class="fl">1e-3</span>;</a><a class="sourceLine" id="cb3-21" title="21"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb3-22" title="22"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb3-23" title="23"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb3-24" title="24"><span class="dt">int</span> sgn(<span class="dt">double</span> x)</a><a class="sourceLine" id="cb3-25" title="25">{</a><a class="sourceLine" id="cb3-26" title="26">    <span class="dt">double</span> Eps=<span class="fl">1e-8</span>;</a><a class="sourceLine" id="cb3-27" title="27">    <span class="cf">if</span>(fabs(x)&lt;Eps){</a><a class="sourceLine" id="cb3-28" title="28">        <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-29" title="29">    }</a><a class="sourceLine" id="cb3-30" title="30">    <span class="cf">if</span>(x&lt;<span class="dv">0</span>) <span class="cf">return</span> -<span class="dv">1</span>;</a><a class="sourceLine" id="cb3-31" title="31">    <span class="cf">else</span> <span class="cf">return</span> <span class="dv">1</span>;</a><a class="sourceLine" id="cb3-32" title="32">}</a><a class="sourceLine" id="cb3-33" title="33"><span class="kw">struct</span> point{</a><a class="sourceLine" id="cb3-34" title="34">    <span class="dt">double</span> x;</a><a class="sourceLine" id="cb3-35" title="35">    <span class="dt">double</span> y;</a><a class="sourceLine" id="cb3-36" title="36">    point(){}</a><a class="sourceLine" id="cb3-37" title="37">    point(<span class="dt">double</span> _x,<span class="dt">double</span> _y){</a><a class="sourceLine" id="cb3-38" title="38">        x=_x;y=_y;</a><a class="sourceLine" id="cb3-39" title="39">    }</a><a class="sourceLine" id="cb3-40" title="40">    point <span class="kw">operator</span>-(<span class="at">const</span> point&amp; b)<span class="at">const</span>{</a><a class="sourceLine" id="cb3-41" title="41">        <span class="cf">return</span> point(x-b.x,y-b.y);</a><a class="sourceLine" id="cb3-42" title="42">    }</a><a class="sourceLine" id="cb3-43" title="43">    <span class="dt">double</span> <span class="kw">operator</span>^(<span class="at">const</span> point&amp; b)<span class="at">const</span>{</a><a class="sourceLine" id="cb3-44" title="44">        <span class="cf">return</span> x*b.y-y*b.x;</a><a class="sourceLine" id="cb3-45" title="45">    }</a><a class="sourceLine" id="cb3-46" title="46">};</a><a class="sourceLine" id="cb3-47" title="47"><span class="kw">struct</span> line{</a><a class="sourceLine" id="cb3-48" title="48">    point s,e;</a><a class="sourceLine" id="cb3-49" title="49">    line(){}</a><a class="sourceLine" id="cb3-50" title="50">    line(point _s,point _e){</a><a class="sourceLine" id="cb3-51" title="51">        s=_s;e=_e;</a><a class="sourceLine" id="cb3-52" title="52">    }</a><a class="sourceLine" id="cb3-53" title="53">    <span class="dt">int</span> relation(point p){</a><a class="sourceLine" id="cb3-54" title="54">        <span class="dt">int</span> c=sgn((p-s)^(e-s));</a><a class="sourceLine" id="cb3-55" title="55">        <span class="cf">if</span>(c&lt;<span class="dv">0</span>) <span class="cf">return</span> <span class="dv">1</span>;</a><a class="sourceLine" id="cb3-56" title="56">        <span class="cf">else</span> <span class="cf">if</span>(c&gt;<span class="dv">0</span>) <span class="cf">return</span> <span class="dv">2</span>;</a><a class="sourceLine" id="cb3-57" title="57">        <span class="cf">else</span> <span class="cf">return</span> <span class="dv">3</span>;</a><a class="sourceLine" id="cb3-58" title="58">    }</a><a class="sourceLine" id="cb3-59" title="59">};</a><a class="sourceLine" id="cb3-60" title="60">point ps[<span class="dv">22</span>];</a><a class="sourceLine" id="cb3-61" title="61"><span class="dt">double</span> sqr(<span class="dt">double</span> x)</a><a class="sourceLine" id="cb3-62" title="62">{</a><a class="sourceLine" id="cb3-63" title="63">    <span class="cf">return</span> x*x;</a><a class="sourceLine" id="cb3-64" title="64">}</a><a class="sourceLine" id="cb3-65" title="65"><span class="dt">double</span> dist(<span class="at">const</span> point&amp; pa,<span class="at">const</span> point&amp; pb)</a><a class="sourceLine" id="cb3-66" title="66">{</a><a class="sourceLine" id="cb3-67" title="67">    <span class="cf">return</span> sqrt(sqr(pa.x-pb.x)+sqr(pa.y-pb.y));</a><a class="sourceLine" id="cb3-68" title="68">}</a><a class="sourceLine" id="cb3-69" title="69"><span class="dt">bool</span> check(<span class="at">const</span> point&amp; pa,<span class="at">const</span> point&amp; pb,<span class="at">const</span> point&amp; pc,<span class="at">const</span> point&amp; pd)</a><a class="sourceLine" id="cb3-70" title="70">{</a><a class="sourceLine" id="cb3-71" title="71">    <span class="dt">double</span> dis1=dist(pa,pb);</a><a class="sourceLine" id="cb3-72" title="72">    <span class="dt">double</span> dis2=dist(pc,pd);</a><a class="sourceLine" id="cb3-73" title="73">    <span class="co">//printf("dis1 = %lf, dis2 = %lf, %lf, %lf\n",dis1,dis2,fabs(dis1-3.0),fabs(dis2-6.0));</span></a><a class="sourceLine" id="cb3-74" title="74">    <span class="cf">if</span>((fabs(dis1-<span class="fl">6.00</span>)&lt;eps&amp;&amp;fabs(dis2-<span class="fl">3.00</span>)&lt;eps)||(fabs(dis1-<span class="fl">3.00</span>)&lt;eps&amp;&amp;fabs(dis2-<span class="fl">6.00</span>)&lt;eps)) <span class="cf">return</span> <span class="dv">1</span>;</a><a class="sourceLine" id="cb3-75" title="75">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-76" title="76">}</a><a class="sourceLine" id="cb3-77" title="77"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb3-78" title="78">{</a><a class="sourceLine" id="cb3-79" title="79">    <span class="dt">int</span> T;scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;T);</a><a class="sourceLine" id="cb3-80" title="80">    <span class="cf">while</span>(T--){</a><a class="sourceLine" id="cb3-81" title="81">        <span class="dt">double</span> X,Y;</a><a class="sourceLine" id="cb3-82" title="82">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">20</span>;i++){</a><a class="sourceLine" id="cb3-83" title="83">            scanf(<span class="st">"</span><span class="sc">%lf</span><span class="st"> </span><span class="sc">%lf</span><span class="st">"</span>,&amp;X,&amp;Y);</a><a class="sourceLine" id="cb3-84" title="84">            ps[i].x=X;ps[i].y=Y;</a><a class="sourceLine" id="cb3-85" title="85">        }</a><a class="sourceLine" id="cb3-86" title="86">        <span class="dt">int</span> pos;</a><a class="sourceLine" id="cb3-87" title="87">        <span class="dt">int</span> idx1,idx2,idx3,idx4;</a><a class="sourceLine" id="cb3-88" title="88">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">20</span>;i++){</a><a class="sourceLine" id="cb3-89" title="89">            idx1=i;idx2=(i+<span class="dv">1</span>)%<span class="dv">20</span>;</a><a class="sourceLine" id="cb3-90" title="90">            idx3=(i+<span class="dv">2</span>)%<span class="dv">20</span>;idx4=(i+<span class="dv">3</span>)%<span class="dv">20</span>;</a><a class="sourceLine" id="cb3-91" title="91">            <span class="cf">if</span>(check(ps[idx1],ps[idx2],ps[idx3],ps[idx4])){</a><a class="sourceLine" id="cb3-92" title="92">                pos=i;</a><a class="sourceLine" id="cb3-93" title="93">                <span class="cf">break</span>;</a><a class="sourceLine" id="cb3-94" title="94">            }</a><a class="sourceLine" id="cb3-95" title="95">        }  </a><a class="sourceLine" id="cb3-96" title="96">        <span class="co">//printf("pos = %d\n",pos);</span></a><a class="sourceLine" id="cb3-97" title="97">        line L(ps[pos],ps[(pos+<span class="dv">1</span>)%<span class="dv">20</span>]);</a><a class="sourceLine" id="cb3-98" title="98">        <span class="dt">int</span> lef=<span class="dv">0</span>;</a><a class="sourceLine" id="cb3-99" title="99">        <span class="dt">int</span> rig=<span class="dv">0</span>;</a><a class="sourceLine" id="cb3-100" title="100">        <span class="cf">for</span>(<span class="dt">int</span> i=(pos+<span class="dv">2</span>)%<span class="dv">20</span>;i!=pos;i=(i+<span class="dv">1</span>)%<span class="dv">20</span>){</a><a class="sourceLine" id="cb3-101" title="101">            <span class="dt">int</span> rela=L.relation(ps[i]);</a><a class="sourceLine" id="cb3-102" title="102">            <span class="cf">if</span>(rela==<span class="dv">1</span>) lef++;</a><a class="sourceLine" id="cb3-103" title="103">            <span class="cf">else</span> <span class="cf">if</span>(rela==<span class="dv">2</span>) rig++;</a><a class="sourceLine" id="cb3-104" title="104">        }</a><a class="sourceLine" id="cb3-105" title="105">        <span class="cf">if</span>(lef&lt;rig) puts(<span class="st">"right"</span>);</a><a class="sourceLine" id="cb3-106" title="106">        <span class="cf">else</span> puts(<span class="st">"left"</span>);</a><a class="sourceLine" id="cb3-107" title="107">    }</a><a class="sourceLine" id="cb3-108" title="108">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-109" title="109">}</a></code></pre></div><h3 id="f-数论拓展欧几里得">F 数论、拓展欧几里得</h3><p>题意是说，给出两个整数<span class="math inline">\(a,b\)</span>，<span class="math inline">\(c,d,e,f\)</span>都是未知数，求方程<span class="math inline">\(\frac{c}{d}-\frac{e}{f}=\frac{a}{b}\)</span>的任意一个解。同时，需要满足以下两个条件：</p><ul><li><span class="math inline">\(d&lt;b\ and\ f&lt;d\)</span></li><li><span class="math inline">\(1\leq c,e\leq 4\times 10^{12}\)</span></li></ul><p>思路是这样的，分三种情况讨论：</p><ul><li><p><span class="math inline">\(\gcd(a,b)&gt;1\)</span></p><p>设<span class="math inline">\(g=\gcd(a,b)\)</span>，则有<span class="math inline">\(\frac{(a+1)/g}{b/g}-\frac{a/g}{b/g}=\frac{a}{b}\)</span>。因为<span class="math inline">\(g&gt;1\)</span>，所以<span class="math inline">\(b/g&lt;b\)</span>，所以直接令<span class="math inline">\(c=(a+1)/g,d=b/g,e=a/g,f=b/g\)</span>即可。</p></li><li><p><span class="math inline">\(\gcd(a,b)=1\)</span>，且<span class="math inline">\(b\)</span>的质因数至少有两个</p><p>设此时的<span class="math inline">\(b=p_1^{x_1}p_2^{x_2}p_3^{x_3}\dots p_n^{x_n}\)</span>，令<span class="math inline">\(d=p_1^{x_1},f=\frac{b}{d}\)</span>，则有<span class="math inline">\(df=b\)</span>。问题转化为求解不定方程<span class="math inline">\(cf-de=a\)</span>。用exgcd求解即可。</p></li><li><p><span class="math inline">\(\gcd(a,b)=1\)</span>，且<span class="math inline">\(b=p^x\)</span>（<span class="math inline">\(p\)</span>是素数）。也就是说<span class="math inline">\(b\)</span>是1或者一个指数的幂次</p><p>此时无解，原因是，如果<span class="math inline">\(b\)</span>是1，那么<span class="math inline">\(d,f\)</span>就只能取0，这显然是不可能的。如果<span class="math inline">\(b=p^x\)</span>，则可以设<span class="math inline">\(d=p^u,f=p^{x-u}\)</span>。exgcd有解的充要条件是<span class="math inline">\(\gcd(d,f)\mid a\)</span>，所以有<span class="math inline">\(\gcd(d,f)=p^{\min\{u,x-u\}}\)</span>。但因为<span class="math inline">\(\gcd(a,b)=1\)</span>，所以<span class="math inline">\(a\)</span>的质因子中没有<span class="math inline">\(p\)</span>，也就是说<span class="math inline">\(\gcd(d,f)\nmid a\)</span>，exgcd不可能有解。</p></li></ul><p>拓展欧几里得解不定方程<span class="math inline">\(ax+by=c\)</span>，最后的解一定要乘以<span class="math inline">\(\frac{c}{\gcd(a,b)}\)</span>！因为求解这个方程的时候，实际上是在求解<span class="math inline">\(ax'+by'=\gcd(a,b)\)</span>，因此要左右两边都同乘上<span class="math inline">\(\frac{c}{\gcd(a,b)}\)</span>这个因子，才是最终的解！数论忘得一干二净orz</p><h3 id="l-签到题">L 签到题</h3><p>温暖的签到题，代码就不放了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f14552214195aa594e12634.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/categories/ACM/"/>
    
    <category term="多校" scheme="https://xtayex.gitee.io/categories/ACM/%E5%A4%9A%E6%A0%A1/"/>
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/tags/ACM/"/>
    
    <category term="多校" scheme="https://xtayex.gitee.io/tags/%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>2020牛客多校第一场</title>
    <link href="https://xtayex.gitee.io/2020/07/16/2020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA/"/>
    <id>https://xtayex.gitee.io/2020/07/16/2020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA/</id>
    <published>2020-07-16T14:08:00.000Z</published>
    <updated>2022-09-27T13:46:54.867Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5f105fed14195aa594b51c3b.jpg"> <span id="more"></span></p><h3 id="a">A</h3><p>令<span class="math display">\[C_i=\min_{j&gt;i,s_j=s_i}\{j-i\}\]</span>，则题目中所说的B-Suffix Array等价于<span class="math inline">\(C_1,C_2,C_3,...，C_n\)</span>。因此，只需要求出<span class="math inline">\(C\)</span>后，对<span class="math inline">\(C\)</span>算一下后缀数组即可。</p><p>代码如下：</p><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb1-6" title="6"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb1-7" title="7"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb1-8" title="8"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb1-9" title="9"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb1-10" title="10"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb1-11" title="11"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb1-12" title="12"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a><a class="sourceLine" id="cb1-13" title="13"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb1-14" title="14"><span class="pp">#define mst</span>(a,<span class="pp"> </span>b)<span class="pp"> </span>memset((a),<span class="pp"> </span>(b),<span class="pp"> </span><span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb1-15" title="15"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb1-16" title="16"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb1-17" title="17"><span class="pp">#define lson </span>lef,<span class="pp"> </span>mid,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb1-18" title="18"><span class="pp">#define rson </span>mid<span class="pp"> </span>+<span class="pp"> </span><span class="dv">1</span>,<span class="pp"> </span>rig,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span><span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb1-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</a><a class="sourceLine" id="cb1-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb1-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb1-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb1-23" title="23"><span class="dt">int</span> wa[maxn], wb[maxn], wv[maxn], wss[maxn], rak[maxn], height[maxn], cal[maxn], n, sa[maxn &lt;&lt; <span class="dv">1</span>];</a><a class="sourceLine" id="cb1-24" title="24"><span class="dt">char</span> s[maxn];</a><a class="sourceLine" id="cb1-25" title="25"><span class="dt">int</span> cmp(<span class="dt">int</span>* r, <span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> l)</a><a class="sourceLine" id="cb1-26" title="26">{</a><a class="sourceLine" id="cb1-27" title="27">    <span class="cf">return</span> r[a] == r[b] &amp;&amp; r[a + l] == r[b + l];</a><a class="sourceLine" id="cb1-28" title="28">}</a><a class="sourceLine" id="cb1-29" title="29"><span class="dt">void</span> da(<span class="dt">int</span>* r, <span class="dt">int</span>* sa, <span class="dt">int</span> n, <span class="dt">int</span> M)</a><a class="sourceLine" id="cb1-30" title="30">{</a><a class="sourceLine" id="cb1-31" title="31">    <span class="dt">int</span> i, j, p, *x = wa, *y = wb, *t;</a><a class="sourceLine" id="cb1-32" title="32">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; M; i++)</a><a class="sourceLine" id="cb1-33" title="33">        wss[i] = <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-34" title="34">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; n; i++)</a><a class="sourceLine" id="cb1-35" title="35">        wss[x[i] = r[i]]++;</a><a class="sourceLine" id="cb1-36" title="36">    <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt; M; i++)</a><a class="sourceLine" id="cb1-37" title="37">        wss[i] += wss[i - <span class="dv">1</span>];</a><a class="sourceLine" id="cb1-38" title="38">    <span class="cf">for</span> (i = n - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; i--)</a><a class="sourceLine" id="cb1-39" title="39">        sa[--wss[x[i]]] = i;</a><a class="sourceLine" id="cb1-40" title="40">    <span class="cf">for</span> (j = <span class="dv">1</span>, p = <span class="dv">1</span>; p &lt; n; j &lt;&lt;= <span class="dv">1</span>, M = p) {</a><a class="sourceLine" id="cb1-41" title="41">        <span class="cf">for</span> (p = <span class="dv">0</span>, i = n - j; i &lt; n; i++)</a><a class="sourceLine" id="cb1-42" title="42">            y[p++] = i;</a><a class="sourceLine" id="cb1-43" title="43">        <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; n; i++)</a><a class="sourceLine" id="cb1-44" title="44">            <span class="cf">if</span> (sa[i] &gt;= j)</a><a class="sourceLine" id="cb1-45" title="45">                y[p++] = sa[i] - j;</a><a class="sourceLine" id="cb1-46" title="46">        <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; n; i++)</a><a class="sourceLine" id="cb1-47" title="47">            wv[i] = x[y[i]];</a><a class="sourceLine" id="cb1-48" title="48">        <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; M; i++)</a><a class="sourceLine" id="cb1-49" title="49">            wss[i] = <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-50" title="50">        <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; n; i++)</a><a class="sourceLine" id="cb1-51" title="51">            wss[wv[i]]++;</a><a class="sourceLine" id="cb1-52" title="52">        <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt; M; i++)</a><a class="sourceLine" id="cb1-53" title="53">            wss[i] += wss[i - <span class="dv">1</span>];</a><a class="sourceLine" id="cb1-54" title="54">        <span class="cf">for</span> (i = n - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; i--)</a><a class="sourceLine" id="cb1-55" title="55">            sa[--wss[wv[i]]] = y[i];</a><a class="sourceLine" id="cb1-56" title="56">        <span class="cf">for</span> (t = x, x = y, y = t, p = <span class="dv">1</span>, x[sa[<span class="dv">0</span>]] = <span class="dv">0</span>, i = <span class="dv">1</span>; i &lt; n; i++)</a><a class="sourceLine" id="cb1-57" title="57">            x[sa[i]] = cmp(y, sa[i - <span class="dv">1</span>], sa[i], j) ? p - <span class="dv">1</span> : p++;</a><a class="sourceLine" id="cb1-58" title="58">    }</a><a class="sourceLine" id="cb1-59" title="59">    <span class="cf">return</span>;</a><a class="sourceLine" id="cb1-60" title="60">}</a><a class="sourceLine" id="cb1-61" title="61"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb1-62" title="62">{</a><a class="sourceLine" id="cb1-63" title="63">    <span class="co">//freopen("./A.in", "r", stdin);</span></a><a class="sourceLine" id="cb1-64" title="64">    <span class="cf">while</span> (scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>, &amp;n) != EOF) {</a><a class="sourceLine" id="cb1-65" title="65">        fill(cal, cal + maxn, <span class="dv">0</span>);</a><a class="sourceLine" id="cb1-66" title="66">        scanf(<span class="st">"</span><span class="sc">%s</span><span class="st">"</span>, s + <span class="dv">1</span>);</a><a class="sourceLine" id="cb1-67" title="67">        <span class="dt">int</span> pre[<span class="dv">2</span>] = { n + <span class="dv">1</span>, n + <span class="dv">1</span> };</a><a class="sourceLine" id="cb1-68" title="68">        <span class="cf">for</span> (<span class="dt">int</span> i = n; i &gt;= <span class="dv">1</span>; i--) {</a><a class="sourceLine" id="cb1-69" title="69">            <span class="cf">if</span> (pre[s[i] - <span class="ch">'a'</span>] == n + <span class="dv">1</span>) {</a><a class="sourceLine" id="cb1-70" title="70">                cal[i] = n;</a><a class="sourceLine" id="cb1-71" title="71">            } <span class="cf">else</span> {</a><a class="sourceLine" id="cb1-72" title="72">                cal[i] = pre[s[i] - <span class="ch">'a'</span>] - i;</a><a class="sourceLine" id="cb1-73" title="73">            }</a><a class="sourceLine" id="cb1-74" title="74">            pre[s[i] - <span class="ch">'a'</span>] = i;</a><a class="sourceLine" id="cb1-75" title="75">        }</a><a class="sourceLine" id="cb1-76" title="76">        cal[n + <span class="dv">1</span>] = n + <span class="dv">1</span>;</a><a class="sourceLine" id="cb1-77" title="77">        <span class="co">//puts("cal: ");</span></a><a class="sourceLine" id="cb1-78" title="78">        <span class="co">//for (int i = 1; i &lt;= n + 1; i++) {</span></a><a class="sourceLine" id="cb1-79" title="79">        <span class="co">//  printf("%d ",cal[i]);</span></a><a class="sourceLine" id="cb1-80" title="80">        <span class="co">//}</span></a><a class="sourceLine" id="cb1-81" title="81">        <span class="co">//puts("");</span></a><a class="sourceLine" id="cb1-82" title="82">        <span class="co">//puts("----------------------");</span></a><a class="sourceLine" id="cb1-83" title="83"></a><a class="sourceLine" id="cb1-84" title="84">        da(cal + <span class="dv">1</span>, sa, n + <span class="dv">2</span>, n + <span class="dv">2</span>);</a><a class="sourceLine" id="cb1-85" title="85">        <span class="cf">for</span> (<span class="dt">int</span> i = n; i &gt;= <span class="dv">1</span>; i--) {</a><a class="sourceLine" id="cb1-86" title="86">            printf(<span class="st">"</span><span class="sc">%d%c</span><span class="st">"</span>, sa[i] + <span class="dv">1</span>, i == <span class="dv">1</span> ? <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span> : <span class="ch">' '</span>);</a><a class="sourceLine" id="cb1-87" title="87">        }</a><a class="sourceLine" id="cb1-88" title="88">    }</a><a class="sourceLine" id="cb1-89" title="89">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-90" title="90">}</a></code></pre></div><p>这道题<span class="math inline">\(n\)</span>的值一定要是<span class="math inline">\(n+2\)</span>，<span class="math inline">\(m\)</span>的值一定也要是<span class="math inline">\(n+2\)</span>！否则不是RE就是WA！</p><h3 id="b">B</h3><p>待补</p><h3 id="c">C</h3><p>待补</p><h3 id="d">D</h3><p>待补</p><h3 id="e">E</h3><p>待补</p><h3 id="f">F</h3><p>假设两个字符串<span class="math inline">\(a,b\)</span>是同一个字符串的循环节，然后在<span class="math inline">\(2\times max(len(a),len(b))\)</span>的范围内比较即可。如果发现没有不相等的字符，则说明两个无穷字符串是同一个字符串，也就是相等。否则，如果<span class="math inline">\(a_i&lt;b_i\)</span>，则<span class="math inline">\(a&lt;b\)</span>；大于的情况同理。这道题的比较范围比较玄学，是猜出来的，但根据题解，范围只需要到<span class="math inline">\(len(a)+len(b)-gcd(len(a),len(b))\)</span>即可。但目前没想明白为什么。。。等一波详细题解。</p><div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb2-3" title="3"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb2-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb2-5" title="5"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb2-6" title="6"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb2-7" title="7"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb2-8" title="8"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb2-9" title="9"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb2-10" title="10"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb2-11" title="11"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb2-12" title="12"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a><a class="sourceLine" id="cb2-13" title="13"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb2-14" title="14"><span class="pp">#define mst</span>(a,<span class="pp"> </span>b)<span class="pp"> </span>memset((a),<span class="pp"> </span>(b),<span class="pp"> </span><span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb2-15" title="15"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb2-16" title="16"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb2-17" title="17"><span class="pp">#define lson </span>lef,<span class="pp"> </span>mid,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb2-18" title="18"><span class="pp">#define rson </span>mid<span class="pp"> </span>+<span class="pp"> </span><span class="dv">1</span>,<span class="pp"> </span>rig,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span><span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb2-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</a><a class="sourceLine" id="cb2-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb2-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb2-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb2-23" title="23"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb2-24" title="24">{</a><a class="sourceLine" id="cb2-25" title="25">    string sa, sb;</a><a class="sourceLine" id="cb2-26" title="26">    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio(<span class="dv">0</span>);</a><a class="sourceLine" id="cb2-27" title="27">    <span class="cf">while</span> (cin &gt;&gt; sa &gt;&gt; sb) {</a><a class="sourceLine" id="cb2-28" title="28">        <span class="dt">int</span> lena = sa.size();</a><a class="sourceLine" id="cb2-29" title="29">        <span class="dt">int</span> lenb = sb.size();</a><a class="sourceLine" id="cb2-30" title="30">        <span class="dt">int</span> bnd = <span class="dv">2</span> * max(lena, lenb);</a><a class="sourceLine" id="cb2-31" title="31">        <span class="dt">int</span> ans = <span class="dv">0</span>;</a><a class="sourceLine" id="cb2-32" title="32">        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; bnd; i++) {</a><a class="sourceLine" id="cb2-33" title="33">            <span class="cf">if</span> (sa[i % lena] &lt; sb[i % lenb]) {</a><a class="sourceLine" id="cb2-34" title="34">                ans = <span class="dv">1</span>; <span class="co">// &lt;</span></a><a class="sourceLine" id="cb2-35" title="35">                <span class="cf">break</span>;</a><a class="sourceLine" id="cb2-36" title="36">            } <span class="cf">else</span> <span class="cf">if</span> (sa[i % lena] &gt; sb[i % lenb]) {</a><a class="sourceLine" id="cb2-37" title="37">                ans = <span class="dv">2</span>; <span class="co">// &gt;</span></a><a class="sourceLine" id="cb2-38" title="38">                <span class="cf">break</span>;</a><a class="sourceLine" id="cb2-39" title="39">            }</a><a class="sourceLine" id="cb2-40" title="40">        }</a><a class="sourceLine" id="cb2-41" title="41">        cout &lt;&lt; <span class="st">"=&lt;&gt;"</span>[ans] &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>;</a><a class="sourceLine" id="cb2-42" title="42">    }</a><a class="sourceLine" id="cb2-43" title="43">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb2-44" title="44">}</a></code></pre></div><h3 id="g">G</h3><p>待补</p><h3 id="h">H</h3><p>题意是说，给定一个<span class="math inline">\(n\)</span>个点<span class="math inline">\(m\)</span>条边的流网络，有<span class="math inline">\(q\)</span>次询问，第<span class="math inline">\(i\)</span>次询问会把图上所有边的容量都设为<span class="math inline">\(\frac{u_i}{v_i}\)</span>，查询当前情况下，从点1发送一个单位的流到点<span class="math inline">\(n\)</span>的最小花费是多少。</p><p>为了方便处理，将所有边的容量都乘以<span class="math inline">\(\frac{v_i}{u_i}\)</span>，使其变成1；原本发送一个单位的流，现在变成发送<span class="math inline">\(\frac{v_i}{u_i}\)</span>个单位的流（实际上就相当于定义了一个新单位，该单位和原单位的进率是<span class="math inline">\(\frac{v_i}{u_i}\)</span>）。然后在算最大流的时候，再记录下不同流量下的最小花费。</p><p>而NaN的情况有两种：</p><ul><li><span class="math inline">\(u=0\)</span>（不考虑这种情况会有除零错误）</li><li><span class="math inline">\(v/u&gt;\)</span>最大流（非整除）</li></ul><p>最后，注意一下处理最终答案的方法（代码165行）</p><p>代码如下：</p><div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb3-2" title="2"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb3-3" title="3"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb3-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb3-5" title="5"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb3-6" title="6"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb3-7" title="7"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb3-8" title="8"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb3-9" title="9"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb3-10" title="10"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb3-11" title="11"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb3-12" title="12"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a><a class="sourceLine" id="cb3-13" title="13"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb3-14" title="14"><span class="pp">#define mst</span>(a,<span class="pp"> </span>b)<span class="pp"> </span>memset((a),<span class="pp"> </span>(b),<span class="pp"> </span><span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb3-15" title="15"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb3-16" title="16"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb3-17" title="17"><span class="pp">#define lson </span>lef,<span class="pp"> </span>mid,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb3-18" title="18"><span class="pp">#define rson </span>mid<span class="pp"> </span>+<span class="pp"> </span><span class="dv">1</span>,<span class="pp"> </span>rig,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span><span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb3-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;</a><a class="sourceLine" id="cb3-20" title="20"><span class="at">const</span> <span class="dt">int</span> maxm = <span class="dv">200</span> + <span class="dv">5</span>;</a><a class="sourceLine" id="cb3-21" title="21"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb3-22" title="22"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb3-23" title="23"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb3-24" title="24"><span class="kw">struct</span> edge {</a><a class="sourceLine" id="cb3-25" title="25">    <span class="dt">int</span> to;</a><a class="sourceLine" id="cb3-26" title="26">    <span class="dt">int</span> nxt;</a><a class="sourceLine" id="cb3-27" title="27">    <span class="dt">int</span> cap;</a><a class="sourceLine" id="cb3-28" title="28">    <span class="dt">int</span> flow;</a><a class="sourceLine" id="cb3-29" title="29">    <span class="dt">int</span> cost;</a><a class="sourceLine" id="cb3-30" title="30">} es[maxm];</a><a class="sourceLine" id="cb3-31" title="31"><span class="dt">int</span> head[maxn];</a><a class="sourceLine" id="cb3-32" title="32"><span class="dt">int</span> tol;</a><a class="sourceLine" id="cb3-33" title="33"><span class="dt">int</span> pre[maxn], dis[maxn];</a><a class="sourceLine" id="cb3-34" title="34"><span class="dt">bool</span> vis[maxn];</a><a class="sourceLine" id="cb3-35" title="35">ll ansarr[maxm];</a><a class="sourceLine" id="cb3-36" title="36"><span class="dt">int</span> N; <span class="co">// 节点总个数, 节点从0~N-1</span></a><a class="sourceLine" id="cb3-37" title="37"><span class="dt">int</span> M;</a><a class="sourceLine" id="cb3-38" title="38"><span class="kw">inline</span> <span class="dt">void</span> init(<span class="dt">int</span> n)</a><a class="sourceLine" id="cb3-39" title="39">{</a><a class="sourceLine" id="cb3-40" title="40">    N = n;</a><a class="sourceLine" id="cb3-41" title="41">    tol = <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-42" title="42">    mst(head, -<span class="dv">1</span>);</a><a class="sourceLine" id="cb3-43" title="43">}</a><a class="sourceLine" id="cb3-44" title="44"><span class="kw">inline</span> <span class="dt">void</span> addedge(<span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">int</span> cap, <span class="dt">int</span> cost)</a><a class="sourceLine" id="cb3-45" title="45">{</a><a class="sourceLine" id="cb3-46" title="46">    es[tol].to = v;</a><a class="sourceLine" id="cb3-47" title="47">    es[tol].cap = cap;</a><a class="sourceLine" id="cb3-48" title="48">    es[tol].cost = cost;</a><a class="sourceLine" id="cb3-49" title="49">    es[tol].flow = <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-50" title="50">    es[tol].nxt = head[u];</a><a class="sourceLine" id="cb3-51" title="51">    head[u] = tol++;</a><a class="sourceLine" id="cb3-52" title="52"></a><a class="sourceLine" id="cb3-53" title="53">    es[tol].to = u;</a><a class="sourceLine" id="cb3-54" title="54">    es[tol].cap = <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-55" title="55">    es[tol].cost = -cost;</a><a class="sourceLine" id="cb3-56" title="56">    es[tol].flow = <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-57" title="57">    es[tol].nxt = head[v];</a><a class="sourceLine" id="cb3-58" title="58">    head[v] = tol++;</a><a class="sourceLine" id="cb3-59" title="59">}</a><a class="sourceLine" id="cb3-60" title="60"><span class="dt">bool</span> spfa(<span class="dt">int</span> s, <span class="dt">int</span> t)</a><a class="sourceLine" id="cb3-61" title="61">{</a><a class="sourceLine" id="cb3-62" title="62">    queue&lt;<span class="dt">int</span>&gt; que;</a><a class="sourceLine" id="cb3-63" title="63">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; i++) {</a><a class="sourceLine" id="cb3-64" title="64">        dis[i] = INF;</a><a class="sourceLine" id="cb3-65" title="65">        vis[i] = <span class="kw">false</span>;</a><a class="sourceLine" id="cb3-66" title="66">        pre[i] = -<span class="dv">1</span>;</a><a class="sourceLine" id="cb3-67" title="67">    }</a><a class="sourceLine" id="cb3-68" title="68">    dis[s] = <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-69" title="69">    vis[s] = <span class="kw">true</span>;</a><a class="sourceLine" id="cb3-70" title="70">    que.push(s);</a><a class="sourceLine" id="cb3-71" title="71">    <span class="cf">while</span> (!que.empty()) {</a><a class="sourceLine" id="cb3-72" title="72">        <span class="dt">int</span> u = que.front();</a><a class="sourceLine" id="cb3-73" title="73">        que.pop();</a><a class="sourceLine" id="cb3-74" title="74">        vis[u] = <span class="kw">false</span>;</a><a class="sourceLine" id="cb3-75" title="75">        <span class="cf">for</span> (<span class="dt">int</span> i = head[u]; i != -<span class="dv">1</span>; i = es[i].nxt) {</a><a class="sourceLine" id="cb3-76" title="76">            <span class="dt">int</span> v = es[i].to;</a><a class="sourceLine" id="cb3-77" title="77">            <span class="cf">if</span> (es[i].cap &gt; es[i].flow &amp;&amp; dis[v] &gt; dis[u] + es[i].cost) {</a><a class="sourceLine" id="cb3-78" title="78">                dis[v] = dis[u] + es[i].cost;</a><a class="sourceLine" id="cb3-79" title="79">                pre[v] = i;</a><a class="sourceLine" id="cb3-80" title="80">                <span class="cf">if</span> (!vis[v]) {</a><a class="sourceLine" id="cb3-81" title="81">                    vis[v] = <span class="kw">true</span>;</a><a class="sourceLine" id="cb3-82" title="82">                    que.push(v);</a><a class="sourceLine" id="cb3-83" title="83">                }</a><a class="sourceLine" id="cb3-84" title="84">            }</a><a class="sourceLine" id="cb3-85" title="85">        }</a><a class="sourceLine" id="cb3-86" title="86">    }</a><a class="sourceLine" id="cb3-87" title="87">    <span class="cf">if</span> (pre[t] == -<span class="dv">1</span>)</a><a class="sourceLine" id="cb3-88" title="88">        <span class="cf">return</span> <span class="kw">false</span>;</a><a class="sourceLine" id="cb3-89" title="89">    <span class="cf">else</span></a><a class="sourceLine" id="cb3-90" title="90">        <span class="cf">return</span> <span class="kw">true</span>;</a><a class="sourceLine" id="cb3-91" title="91">}</a><a class="sourceLine" id="cb3-92" title="92">ll mcmf(<span class="dt">int</span> s, <span class="dt">int</span> t, ll&amp; cost)</a><a class="sourceLine" id="cb3-93" title="93">{</a><a class="sourceLine" id="cb3-94" title="94">    ll flow = <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-95" title="95">    cost = <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-96" title="96">    <span class="cf">while</span> (spfa(s, t)) {</a><a class="sourceLine" id="cb3-97" title="97">        ll Min = INF;</a><a class="sourceLine" id="cb3-98" title="98">        <span class="cf">for</span> (<span class="dt">int</span> i = pre[t]; i != -<span class="dv">1</span>; i = pre[es[i ^ <span class="dv">1</span>].to]) {</a><a class="sourceLine" id="cb3-99" title="99">            <span class="cf">if</span> (Min &gt; es[i].cap - es[i].flow) {</a><a class="sourceLine" id="cb3-100" title="100">                Min = es[i].cap - es[i].flow;</a><a class="sourceLine" id="cb3-101" title="101">            }</a><a class="sourceLine" id="cb3-102" title="102">        }</a><a class="sourceLine" id="cb3-103" title="103">        <span class="cf">for</span> (<span class="dt">int</span> i = pre[t]; i != -<span class="dv">1</span>; i = pre[es[i ^ <span class="dv">1</span>].to]) {</a><a class="sourceLine" id="cb3-104" title="104">            es[i].flow += Min;</a><a class="sourceLine" id="cb3-105" title="105">            es[i ^ <span class="dv">1</span>].flow -= Min;</a><a class="sourceLine" id="cb3-106" title="106">            cost += es[i].cost * Min;</a><a class="sourceLine" id="cb3-107" title="107">        }</a><a class="sourceLine" id="cb3-108" title="108">        flow += Min;</a><a class="sourceLine" id="cb3-109" title="109">        ansarr[(<span class="dt">int</span>)flow] = cost;</a><a class="sourceLine" id="cb3-110" title="110">    }</a><a class="sourceLine" id="cb3-111" title="111">    <span class="cf">return</span> flow;</a><a class="sourceLine" id="cb3-112" title="112">}</a><a class="sourceLine" id="cb3-113" title="113"><span class="kw">inline</span> <span class="dt">int</span> read()</a><a class="sourceLine" id="cb3-114" title="114">{</a><a class="sourceLine" id="cb3-115" title="115">    <span class="dt">char</span> ch;</a><a class="sourceLine" id="cb3-116" title="116">    <span class="dt">int</span> x = <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-117" title="117">    <span class="dt">int</span> sign = <span class="dv">1</span>;</a><a class="sourceLine" id="cb3-118" title="118">    <span class="cf">do</span> {</a><a class="sourceLine" id="cb3-119" title="119">        ch = getchar();</a><a class="sourceLine" id="cb3-120" title="120">        <span class="cf">if</span> (ch == <span class="ch">'-'</span>)</a><a class="sourceLine" id="cb3-121" title="121">            sign = -<span class="dv">1</span>;</a><a class="sourceLine" id="cb3-122" title="122">    } <span class="cf">while</span> (ch &gt; <span class="ch">'9'</span> || ch &lt; <span class="ch">'0'</span>);</a><a class="sourceLine" id="cb3-123" title="123">    <span class="cf">while</span> (<span class="ch">'0'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="ch">'9'</span>) {</a><a class="sourceLine" id="cb3-124" title="124">        x = (x &lt;&lt; <span class="dv">3</span>) + (x &lt;&lt; <span class="dv">1</span>) + (ch - <span class="ch">'0'</span>);</a><a class="sourceLine" id="cb3-125" title="125">        ch = getchar();</a><a class="sourceLine" id="cb3-126" title="126">    }</a><a class="sourceLine" id="cb3-127" title="127">    <span class="cf">return</span> x * sign;</a><a class="sourceLine" id="cb3-128" title="128">}</a><a class="sourceLine" id="cb3-129" title="129">ll gcd(ll a, ll b)</a><a class="sourceLine" id="cb3-130" title="130">{</a><a class="sourceLine" id="cb3-131" title="131">    <span class="cf">return</span> b == <span class="dv">0</span> ? a : gcd(b, a % b);</a><a class="sourceLine" id="cb3-132" title="132">}</a><a class="sourceLine" id="cb3-133" title="133"><span class="co">//inline void Swap(ll&amp; a,ll&amp; b)</span></a><a class="sourceLine" id="cb3-134" title="134"><span class="co">//{</span></a><a class="sourceLine" id="cb3-135" title="135"><span class="co">//ll tmp=a;</span></a><a class="sourceLine" id="cb3-136" title="136"><span class="co">//a=b;b=tmp;</span></a><a class="sourceLine" id="cb3-137" title="137"><span class="co">//}</span></a><a class="sourceLine" id="cb3-138" title="138"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb3-139" title="139">{</a><a class="sourceLine" id="cb3-140" title="140">    <span class="cf">while</span> (scanf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>, &amp;N, &amp;M) != EOF) {</a><a class="sourceLine" id="cb3-141" title="141">        init(N);</a><a class="sourceLine" id="cb3-142" title="142">        <span class="dt">int</span> ai, bi, ci;</a><a class="sourceLine" id="cb3-143" title="143">        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; M; i++) {</a><a class="sourceLine" id="cb3-144" title="144">            ai = read();</a><a class="sourceLine" id="cb3-145" title="145">            bi = read();</a><a class="sourceLine" id="cb3-146" title="146">            ci = read();</a><a class="sourceLine" id="cb3-147" title="147">            ai--;</a><a class="sourceLine" id="cb3-148" title="148">            bi--;</a><a class="sourceLine" id="cb3-149" title="149">            addedge(ai, bi, <span class="dv">1</span>, ci);</a><a class="sourceLine" id="cb3-150" title="150">        }</a><a class="sourceLine" id="cb3-151" title="151">        ll miniflow;</a><a class="sourceLine" id="cb3-152" title="152">        ll maxiflow = mcmf(<span class="dv">0</span>, N - <span class="dv">1</span>, miniflow);</a><a class="sourceLine" id="cb3-153" title="153">        <span class="dt">int</span> q;</a><a class="sourceLine" id="cb3-154" title="154">        q = read();</a><a class="sourceLine" id="cb3-155" title="155">        <span class="dt">int</span> u, v;</a><a class="sourceLine" id="cb3-156" title="156">        <span class="cf">while</span> (q--) {</a><a class="sourceLine" id="cb3-157" title="157">            u = read();</a><a class="sourceLine" id="cb3-158" title="158">            v = read();</a><a class="sourceLine" id="cb3-159" title="159">            <span class="co">//printf("maxiflow = %lld\n",maxiflow);</span></a><a class="sourceLine" id="cb3-160" title="160">            <span class="cf">if</span> (u == <span class="dv">0</span> || ((<span class="dv">1</span><span class="bu">LL</span> * v) / u == maxiflow &amp;&amp; (<span class="dv">1</span><span class="bu">LL</span> * v) % u &gt; <span class="dv">0</span>) || (<span class="dv">1</span><span class="bu">LL</span> * v) / u &gt; maxiflow) {</a><a class="sourceLine" id="cb3-161" title="161">                puts(<span class="st">"NaN"</span>);</a><a class="sourceLine" id="cb3-162" title="162">                <span class="cf">continue</span>;</a><a class="sourceLine" id="cb3-163" title="163">            }</a><a class="sourceLine" id="cb3-164" title="164">            <span class="dt">int</span> idx = v / u;</a><a class="sourceLine" id="cb3-165" title="165">            ll up = ansarr[idx] * u + (ansarr[idx + <span class="dv">1</span>] - ansarr[idx]) * (v % u);</a><a class="sourceLine" id="cb3-166" title="166">            <span class="co">//if(v&lt;up) Swap(v, up)</span></a><a class="sourceLine" id="cb3-167" title="167">            ll g = gcd(<span class="dv">1</span><span class="bu">LL</span> * v, up);</a><a class="sourceLine" id="cb3-168" title="168">            printf(<span class="st">"</span><span class="sc">%lld</span><span class="st">/</span><span class="sc">%lld\n</span><span class="st">"</span>, up / g, v / g);</a><a class="sourceLine" id="cb3-169" title="169">        }</a><a class="sourceLine" id="cb3-170" title="170">    }</a><a class="sourceLine" id="cb3-171" title="171">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-172" title="172">}</a></code></pre></div><h3 id="i">I</h3><p>待补</p><h3 id="j">J</h3><p>高数签到题。虽然这题是我A的，但是因为高数太菜，所以其实积分结果是在OEIS上找到的hhh。</p><p>积分过程如下： <span class="math display">\[\begin{aligned}\because (x-x^2)^n&amp;=\frac{1}{4}-\left( \frac{1}{2}-x\right )^2 \\\therefore \int_0^1(x-x^2)^ndx&amp;=\int_0^1\left(\frac{1}{4}-\left(\frac{1}{2}-x\right)^2\right)^ndx\\&amp;=\frac{1}{4^n}\int_0^1\left(1-4\left(\frac{1}{2}-x\right)^2\right)^ndx\\&amp;=\frac{1}{4^n}\int_0^1\left(1-(2x-1)^2\right)^ndx\end{aligned}\]</span> 令<span class="math inline">\(\sin t=2x-1\)</span>，则有 <span class="math display">\[\begin{aligned}\int_0^1(x-x^2)^ndx&amp;=\frac{1}{4^n}\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}(1-\sin^2t)^ndx\\&amp;=\frac{1}{4^n}\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}(1-\sin^2t)^n\frac{\cos t}{2}dt\\&amp;=\frac{1}{4^n}\int_0^{\frac{\pi}{2}}\cos^{2n+1}tdt\end{aligned}\]</span></p><p>由Wallis公式： <span class="math display">\[\int_0^{\frac{\pi}{2}}\cos^nxdx=\begin{cases}\frac{\pi(2k)!!}{2(2k+1)!!}&amp;\text{n=2k}\\\frac{(2k)!!}{(2k+1)!!}&amp;\text{n=2k+1}\end{cases}\]</span> 其中，<span class="math inline">\(\frac{(2k)!!}{(2k+1)!!}=\frac{2\times4\times6\times\dots\times(2n-2)\times2n}{1\times3\times5\times\dots\times(2n-1)\times(2n+1)}\)</span>。因此，有 <span class="math display">\[\begin{aligned}\int_0^1(x-x^2)^ndx&amp;=\frac{1}{4^n}\frac{(2n)!!}{(2n+1)!!}\\&amp;=\frac{1}{4^n}\frac{(2n)!!}{\frac{(2n+1)!}{(2n)!!}}\\&amp;=\frac{1}{4^n}\frac{(2n!!)^2}{(2n+1)!}\\&amp;=\frac{1}{4^n}\frac{4^n(n!)^2}{(2n+1)!}\\&amp;=\frac{(n!)^2}{(2n+1)!}\end{aligned}\]</span> 得到上面的积分结果后，套式子再求个逆元就行了。</p><p>代码如下：</p><div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb4-2" title="2"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb4-3" title="3"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb4-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb4-5" title="5"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb4-6" title="6"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb4-7" title="7"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb4-8" title="8"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb4-9" title="9"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb4-10" title="10"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb4-11" title="11"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb4-12" title="12"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a><a class="sourceLine" id="cb4-13" title="13"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb4-14" title="14"><span class="pp">#define mst</span>(a,<span class="pp"> </span>b)<span class="pp"> </span>memset((a),<span class="pp"> </span>(b),<span class="pp"> </span><span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb4-15" title="15"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb4-16" title="16"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb4-17" title="17"><span class="pp">#define lson </span>lef,<span class="pp"> </span>mid,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb4-18" title="18"><span class="pp">#define rson </span>mid<span class="pp"> </span>+<span class="pp"> </span><span class="dv">1</span>,<span class="pp"> </span>rig,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span><span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb4-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</a><a class="sourceLine" id="cb4-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb4-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb4-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb4-23" title="23"><span class="at">const</span> <span class="dt">int</span> bnd = <span class="fl">2e6</span> + <span class="dv">2</span>;</a><a class="sourceLine" id="cb4-24" title="24"><span class="at">const</span> ll mod = <span class="dv">998244353</span>;</a><a class="sourceLine" id="cb4-25" title="25">ll frac[bnd];</a><a class="sourceLine" id="cb4-26" title="26"><span class="kw">inline</span> <span class="dt">void</span> init()</a><a class="sourceLine" id="cb4-27" title="27">{</a><a class="sourceLine" id="cb4-28" title="28">    frac[<span class="dv">0</span>] = frac[<span class="dv">1</span>] = <span class="dv">1</span>;</a><a class="sourceLine" id="cb4-29" title="29">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= bnd; i++) {</a><a class="sourceLine" id="cb4-30" title="30">        frac[i] = (frac[i - <span class="dv">1</span>] % mod * i % mod) % mod;</a><a class="sourceLine" id="cb4-31" title="31">    }</a><a class="sourceLine" id="cb4-32" title="32">}</a><a class="sourceLine" id="cb4-33" title="33">ll exgcd(ll a, ll b, ll&amp; x, ll&amp; y)</a><a class="sourceLine" id="cb4-34" title="34">{</a><a class="sourceLine" id="cb4-35" title="35">    <span class="cf">if</span> (a == <span class="dv">0</span> &amp;&amp; b == <span class="dv">0</span>) {</a><a class="sourceLine" id="cb4-36" title="36">        <span class="cf">return</span> -<span class="dv">1</span>;</a><a class="sourceLine" id="cb4-37" title="37">    }</a><a class="sourceLine" id="cb4-38" title="38">    <span class="cf">if</span> (b == <span class="dv">0</span>) {</a><a class="sourceLine" id="cb4-39" title="39">        x = <span class="dv">1</span>;</a><a class="sourceLine" id="cb4-40" title="40">        y = <span class="dv">0</span>;</a><a class="sourceLine" id="cb4-41" title="41">        <span class="cf">return</span> a;</a><a class="sourceLine" id="cb4-42" title="42">    }</a><a class="sourceLine" id="cb4-43" title="43">    ll d = exgcd(b, a % b, y, x);</a><a class="sourceLine" id="cb4-44" title="44">    y -= a / b * x;</a><a class="sourceLine" id="cb4-45" title="45">    <span class="cf">return</span> d;</a><a class="sourceLine" id="cb4-46" title="46">}</a><a class="sourceLine" id="cb4-47" title="47">ll inv(ll a, ll n)</a><a class="sourceLine" id="cb4-48" title="48">{</a><a class="sourceLine" id="cb4-49" title="49">    ll x, y;</a><a class="sourceLine" id="cb4-50" title="50">    ll d = exgcd(a, n, x, y);</a><a class="sourceLine" id="cb4-51" title="51">    <span class="cf">if</span> (d == <span class="dv">1</span>)</a><a class="sourceLine" id="cb4-52" title="52">        <span class="cf">return</span> (x % n + n) % n;</a><a class="sourceLine" id="cb4-53" title="53">    <span class="cf">else</span></a><a class="sourceLine" id="cb4-54" title="54">        <span class="cf">return</span> -<span class="dv">1</span>;</a><a class="sourceLine" id="cb4-55" title="55">}</a><a class="sourceLine" id="cb4-56" title="56"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb4-57" title="57">{</a><a class="sourceLine" id="cb4-58" title="58">    init();</a><a class="sourceLine" id="cb4-59" title="59">    ll n;</a><a class="sourceLine" id="cb4-60" title="60">    <span class="cf">while</span> (scanf(<span class="st">"</span><span class="sc">%lld</span><span class="st">"</span>, &amp;n) != EOF) {</a><a class="sourceLine" id="cb4-61" title="61">        ll f = frac[n];</a><a class="sourceLine" id="cb4-62" title="62">        ll ff = frac[<span class="dv">2</span> * n + <span class="dv">1</span>];</a><a class="sourceLine" id="cb4-63" title="63">        ll up = (f % mod * f % mod) % mod;</a><a class="sourceLine" id="cb4-64" title="64">        ll down = ff % mod;</a><a class="sourceLine" id="cb4-65" title="65">        ll ans = (up % mod * inv(down, mod) % mod) % mod;</a><a class="sourceLine" id="cb4-66" title="66">        printf(<span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span>, ans);</a><a class="sourceLine" id="cb4-67" title="67">    }</a><a class="sourceLine" id="cb4-68" title="68">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb4-69" title="69">}</a></code></pre></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f105fed14195aa594b51c3b.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/categories/ACM/"/>
    
    <category term="多校" scheme="https://xtayex.gitee.io/categories/ACM/%E5%A4%9A%E6%A0%A1/"/>
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/tags/ACM/"/>
    
    <category term="多校" scheme="https://xtayex.gitee.io/tags/%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1374E1 - Reading Books (easy version)</title>
    <link href="https://xtayex.gitee.io/2020/07/08/Codeforces-1374E1-Reading-Books-easy-version/"/>
    <id>https://xtayex.gitee.io/2020/07/08/Codeforces-1374E1-Reading-Books-easy-version/</id>
    <published>2020-07-08T14:34:02.000Z</published>
    <updated>2022-09-27T13:46:54.871Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5f05d99d14195aa59424eb9e.jpg"></p><span id="more"></span><h3 id="前言">前言</h3><p>每次期末后的复建运动都格外痛苦（</p><h3 id="正文">正文</h3><p>题意是说，给定<span class="math inline">\(n\)</span>本书，如果书都有属性<span class="math inline">\(a,b,t\)</span>。如果<span class="math inline">\(a=1\)</span>，则说明Alice喜欢读这本书，<span class="math inline">\(0\)</span>则不喜欢；如果<span class="math inline">\(b=1\)</span>，则说明Bob喜欢读这本书，<span class="math inline">\(0\)</span>则不喜欢。<span class="math inline">\(t\)</span>是每本书的代价。从中选出若干本书，这些书中Alice和Bob喜欢读的都不少于<span class="math inline">\(k\)</span>本。问如何选择，才能使代价总和最小。</p><p>思路是贪心。记Alice和Bob都喜欢的书为11类，只有Alice喜欢的为10类，只有Bob喜欢的为01类。容易注意到，选择Alice和Bob都喜欢读的书性价比要更高一些。所以，我们首先对三种属性分别排序，如果当前取了<span class="math inline">\(i\)</span>本11类的书，那么，对于Alice，我们要为她取10类和01类共<span class="math inline">\(k-i\)</span>本书；Bob也是同理。如果发现10类或01类的书的数目小于<span class="math inline">\(k-i\)</span>，则说明在取<span class="math inline">\(i\)</span>本11类书的情况下，没有可行的方案。</p><p>代码如下：</p><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb1-6" title="6"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb1-7" title="7"><span class="pp">#include </span><span class="im">&lt;limits&gt;</span></a><a class="sourceLine" id="cb1-8" title="8"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb1-9" title="9"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb1-10" title="10"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb1-11" title="11"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb1-12" title="12"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb1-13" title="13"><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></a><a class="sourceLine" id="cb1-14" title="14"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb1-15" title="15"><span class="pp">#define mst</span>(a,<span class="pp"> </span>b)<span class="pp"> </span>memset((a),<span class="pp"> </span>(b),<span class="pp"> </span><span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb1-16" title="16"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb1-17" title="17"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb1-18" title="18"><span class="pp">#define lson </span>lef,<span class="pp"> </span>mid,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb1-19" title="19"><span class="pp">#define rson </span>mid<span class="pp"> </span>+<span class="pp"> </span><span class="dv">1</span>,<span class="pp"> </span>rig,<span class="pp"> </span>rt<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span><span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span></a><a class="sourceLine" id="cb1-20" title="20"><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</a><a class="sourceLine" id="cb1-21" title="21"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb1-22" title="22"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb1-23" title="23"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb1-24" title="24"><span class="kw">struct</span> node {</a><a class="sourceLine" id="cb1-25" title="25">    ll t;</a><a class="sourceLine" id="cb1-26" title="26">    <span class="dt">int</span> a;</a><a class="sourceLine" id="cb1-27" title="27">    <span class="dt">int</span> b;</a><a class="sourceLine" id="cb1-28" title="28">    <span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="at">const</span> node&amp; nn) <span class="at">const</span></a><a class="sourceLine" id="cb1-29" title="29">    {</a><a class="sourceLine" id="cb1-30" title="30">        <span class="cf">return</span> t &lt; nn.t;</a><a class="sourceLine" id="cb1-31" title="31">    }</a><a class="sourceLine" id="cb1-32" title="32">};</a><a class="sourceLine" id="cb1-33" title="33">node allone[maxn];</a><a class="sourceLine" id="cb1-34" title="34">node A[maxn];</a><a class="sourceLine" id="cb1-35" title="35">node B[maxn];</a><a class="sourceLine" id="cb1-36" title="36">ll sum1[maxn];</a><a class="sourceLine" id="cb1-37" title="37">ll sum2[maxn];</a><a class="sourceLine" id="cb1-38" title="38">ll sum3[maxn];</a><a class="sourceLine" id="cb1-39" title="39">unordered_map&lt;<span class="dt">int</span>, <span class="dt">bool</span>&gt; mp;</a><a class="sourceLine" id="cb1-40" title="40"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb1-41" title="41">{</a><a class="sourceLine" id="cb1-42" title="42">    mp.clear();</a><a class="sourceLine" id="cb1-43" title="43">    <span class="dt">int</span> n, k;</a><a class="sourceLine" id="cb1-44" title="44">    scanf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>, &amp;n, &amp;k);</a><a class="sourceLine" id="cb1-45" title="45">    <span class="dt">int</span> idx1, idx2, idx3;</a><a class="sourceLine" id="cb1-46" title="46">    idx1 = idx2 = idx3 = <span class="dv">1</span>;</a><a class="sourceLine" id="cb1-47" title="47">    ll <span class="va">t_</span>;</a><a class="sourceLine" id="cb1-48" title="48">    <span class="dt">int</span> <span class="va">a_</span>, <span class="va">b_</span>;</a><a class="sourceLine" id="cb1-49" title="49">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {</a><a class="sourceLine" id="cb1-50" title="50">        scanf(<span class="st">"</span><span class="sc">%lld</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>, &amp;<span class="va">t_</span>, &amp;<span class="va">a_</span>, &amp;<span class="va">b_</span>);</a><a class="sourceLine" id="cb1-51" title="51">        <span class="cf">if</span> (<span class="va">a_</span> &amp;&amp; <span class="va">b_</span>)</a><a class="sourceLine" id="cb1-52" title="52">            allone[idx1++] = { <span class="va">t_</span>, <span class="va">a_</span>, <span class="va">b_</span> };</a><a class="sourceLine" id="cb1-53" title="53">        <span class="cf">if</span> (<span class="va">a_</span> &amp;&amp; !<span class="va">b_</span>)</a><a class="sourceLine" id="cb1-54" title="54">            A[idx2++] = { <span class="va">t_</span>, <span class="va">a_</span>, <span class="va">b_</span> };</a><a class="sourceLine" id="cb1-55" title="55">        <span class="cf">if</span> (!<span class="va">a_</span> &amp;&amp; <span class="va">b_</span>)</a><a class="sourceLine" id="cb1-56" title="56">            B[idx3++] = { <span class="va">t_</span>, <span class="va">a_</span>, <span class="va">b_</span> };</a><a class="sourceLine" id="cb1-57" title="57">    }</a><a class="sourceLine" id="cb1-58" title="58">    sort(allone + <span class="dv">1</span>, allone + idx1);</a><a class="sourceLine" id="cb1-59" title="59">    sort(A + <span class="dv">1</span>, A + idx2);</a><a class="sourceLine" id="cb1-60" title="60">    sort(B + <span class="dv">1</span>, B + idx3);</a><a class="sourceLine" id="cb1-61" title="61">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {</a><a class="sourceLine" id="cb1-62" title="62">        sum1[i] = sum1[i - <span class="dv">1</span>] + allone[i].t;</a><a class="sourceLine" id="cb1-63" title="63">        sum2[i] = sum2[i - <span class="dv">1</span>] + A[i].t;</a><a class="sourceLine" id="cb1-64" title="64">        sum3[i] = sum3[i - <span class="dv">1</span>] + B[i].t;</a><a class="sourceLine" id="cb1-65" title="65">    }</a><a class="sourceLine" id="cb1-66" title="66">    ll inf = numeric_limits&lt;ll&gt;::max();</a><a class="sourceLine" id="cb1-67" title="67">    ll ans = inf;</a><a class="sourceLine" id="cb1-68" title="68">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= min(k, idx1 - <span class="dv">1</span>); i++) {</a><a class="sourceLine" id="cb1-69" title="69">        <span class="dt">int</span> tmp = k - i;</a><a class="sourceLine" id="cb1-70" title="70">        <span class="cf">if</span> (idx2 - <span class="dv">1</span> &gt;= tmp &amp;&amp; idx3 - <span class="dv">1</span> &gt;= tmp) {</a><a class="sourceLine" id="cb1-71" title="71">            ans = min(ans, sum1[i] + sum2[k - i] + sum3[k - i]);</a><a class="sourceLine" id="cb1-72" title="72">        }</a><a class="sourceLine" id="cb1-73" title="73">    }</a><a class="sourceLine" id="cb1-74" title="74">    <span class="cf">if</span> (ans == inf) {</a><a class="sourceLine" id="cb1-75" title="75">        puts(<span class="st">"-1"</span>);</a><a class="sourceLine" id="cb1-76" title="76">    } <span class="cf">else</span> {</a><a class="sourceLine" id="cb1-77" title="77">        printf(<span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span>, ans);</a><a class="sourceLine" id="cb1-78" title="78">    }</a><a class="sourceLine" id="cb1-79" title="79">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-80" title="80">}</a></code></pre></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f05d99d14195aa59424eb9e.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>用手势操控你的电脑——基于Opencv.js，Tensorflow，electron的手势人机交互</title>
    <link href="https://xtayex.gitee.io/2020/07/04/%E7%94%A8%E6%89%8B%E5%8A%BF%E6%93%8D%E6%8E%A7%E4%BD%A0%E7%9A%84%E7%94%B5%E8%84%91%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EOpencv-js%EF%BC%8CTensorflow%EF%BC%8Celectron%E7%9A%84%E6%89%8B%E5%8A%BF%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    <id>https://xtayex.gitee.io/2020/07/04/%E7%94%A8%E6%89%8B%E5%8A%BF%E6%93%8D%E6%8E%A7%E4%BD%A0%E7%9A%84%E7%94%B5%E8%84%91%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EOpencv-js%EF%BC%8CTensorflow%EF%BC%8Celectron%E7%9A%84%E6%89%8B%E5%8A%BF%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/</id>
    <published>2020-07-04T03:59:00.000Z</published>
    <updated>2022-09-27T13:46:54.859Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5f00278014195aa594787856.png"> <span id="more"></span></p><h3 id="前言">前言</h3><p>昨晚看了以下许久没有访问的博客，发现最近一篇博客居然是今年3月份的一份AGC题解。还记得大一的时候，写博客的热情高涨，恨不得日更三篇；上了大二之后，一方面是各方面的压力变大了，另一方面是自己在这方面越来越懒，<del>于是出现了四个月没写过一篇文章的情况</del>。这学期上多媒体课程，期末大作业和刘总一起做了一个基于手势识别的人机交互小程序，就拿来<del>水一水</del>吧</p><h3 id="介绍">介绍</h3><p>看标题就知道，这是一个通过识别手势来完成一些电脑操作的东西。因为是一个桌面应用，同时为了界面好看（好看是第一生产力.jpg），我们选择了electron。首先是用python+Tensorflow训练一个CNN用于手势识别，并导出该模型为json格式；然后，我们在electron中使用opencv.js处理图像，并把上一步训练得到的json格式模型导入到Tensorflow.js中做手势识别；最后，借助robot.js来实现操控电脑。</p><p>放一下结构图</p><p><img src="https://pic.downk.cc/item/5f00239914195aa594769dc9.jpg"></p><p>之所以要分离出前端和服务端，是因为robot.js要塞进electron里面比较麻烦，尝试了好几次之后都没有成功，于是索性不把他放到electron里面。这样一来，避免了配置上的麻烦，而且结构更清晰，代码写起来也更方便。</p><p>目前仅支持在windows上使用，可以完成的操作有：</p><ul><li>切换窗口</li><li>隐藏窗口</li><li>静音/恢复音量</li><li>关闭当前窗口</li><li>上、下、左、右四个方向键</li></ul><h3 id="模型搭建">模型搭建</h3><p>这一步主要就是采集训练样本，然后使用Opencv处理图像，最后扔进Tensorflow里训练。</p><p>先说一下采集训练样本以及处理图像这两部分。通过Opencv调用摄像头，每0.1秒截取一次图像，然后用Opencv处理这一图像。所做的处理包括：</p><ul><li><p>获取ROI（感兴趣区域）</p><p>其实就是从原图像上截取一个指定区域。</p><center><img src="https://pic.downk.cc/item/5f00061014195aa5946a4677.png" style="zoom:50%;"></center><center>处理前</center><center><img src="https://pic.downk.cc/item/5f00064814195aa5946a5c36.png" style="zoom: 67%;"></center><center>处理后</center><p>代码如下：</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> getRoi(frame, x0, y0, width, height):</a><a class="sourceLine" id="cb1-2" title="2">  roi <span class="op">=</span> frame[y0:y0 <span class="op">+</span> height, x0:x0 <span class="op">+</span> width]</a><a class="sourceLine" id="cb1-3" title="3">  cv.imshow(<span class="st">'roi'</span>, roi)</a><a class="sourceLine" id="cb1-4" title="4">  <span class="cf">return</span> roi</a></code></pre></div></li><li><p>使用Otsu法（大津法）进行肤色检测</p><p>大致原理是通过遮罩的方法，计算按位与运算，从而过滤掉那些我们不关心的像素。代码如下：</p><div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">def</span> getSkin(frame):</a><a class="sourceLine" id="cb2-2" title="2">    ycrcb <span class="op">=</span> cv.cvtColor(frame, cv.COLOR_BGR2YCR_CB)</a><a class="sourceLine" id="cb2-3" title="3">    y, cr, cb <span class="op">=</span> cv.split(ycrcb)</a><a class="sourceLine" id="cb2-4" title="4">    cr_ <span class="op">=</span> cv.GaussianBlur(cr, (<span class="dv">5</span>, <span class="dv">5</span>), <span class="dv">0</span>) <span class="co"># 高斯模糊</span></a><a class="sourceLine" id="cb2-5" title="5">   _, skin <span class="op">=</span> cv.threshold(cr_, <span class="dv">0</span>, <span class="dv">255</span>, cv.THRESH_BINARY <span class="op">|</span> cv.THRESH_OTSU) <span class="co"># otsu二值化 </span></a><a class="sourceLine" id="cb2-6" title="6">    ret <span class="op">=</span> cv.bitwise_and(frame, frame, mask<span class="op">=</span>skin)</a><a class="sourceLine" id="cb2-7" title="7">    <span class="cf">return</span> ret</a></code></pre></div><center><img src="https://pic.downk.cc/item/5f00064814195aa5946a5c36.png" style="zoom:50%;"></center><center>处理前</center><center><img src="https://pic.downk.cc/item/5f000a5c14195aa5946bfd10.png" style="zoom:50%;"></center><center>处理后</center></li><li><p>提取轮廓并计算傅里叶算子</p><p>提取轮廓可以用opencv中的findContour。计算傅里叶算子可以理解为提取特征。</p><center><img src="https://pic.downk.cc/item/5f000a5c14195aa5946bfd10.png" style="zoom:50%;"></center><center>处理前</center><center><img src="https://pic.downk.cc/item/5f000ad514195aa5946c30ba.png" style="zoom:50%;"></center><center>处理后</center><p>代码如下：</p><p>提取轮廓</p><div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">def</span> findContour(Laplacian):</a><a class="sourceLine" id="cb3-2" title="2">  h <span class="op">=</span> cv.findContours(Laplacian, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_NONE)</a><a class="sourceLine" id="cb3-3" title="3">  contour <span class="op">=</span> h[<span class="dv">0</span>]</a><a class="sourceLine" id="cb3-4" title="4">  contour <span class="op">=</span> <span class="bu">sorted</span>(contour, key<span class="op">=</span>cv.contourArea, reverse<span class="op">=</span><span class="va">True</span>)</a><a class="sourceLine" id="cb3-5" title="5">  <span class="cf">return</span> contour</a></code></pre></div><p>计算傅里叶算子：</p><div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">def</span> trucate(des):</a><a class="sourceLine" id="cb4-2" title="2">    ret <span class="op">=</span> np.fft.fftshift(des)</a><a class="sourceLine" id="cb4-3" title="3">    centerIdx <span class="op">=</span> <span class="bu">int</span>(<span class="bu">len</span>(ret) <span class="op">/</span> <span class="dv">2</span>)</a><a class="sourceLine" id="cb4-4" title="4">    low, high <span class="op">=</span> centerIdx <span class="op">-</span> <span class="bu">int</span>(MIN_DESCRIPTOR <span class="op">/</span> <span class="dv">2</span>), centerIdx <span class="op">+</span> <span class="bu">int</span>(MIN_DESCRIPTOR <span class="op">/</span> <span class="dv">2</span>)</a><a class="sourceLine" id="cb4-5" title="5">    ret <span class="op">=</span> ret[low:high]</a><a class="sourceLine" id="cb4-6" title="6">    ret <span class="op">=</span> np.fft.ifftshift(ret)</a><a class="sourceLine" id="cb4-7" title="7">    <span class="cf">return</span> ret</a><a class="sourceLine" id="cb4-8" title="8"></a><a class="sourceLine" id="cb4-9" title="9"><span class="kw">def</span> fourier(frame):</a><a class="sourceLine" id="cb4-10" title="10">    gray <span class="op">=</span> cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</a><a class="sourceLine" id="cb4-11" title="11">    dst <span class="op">=</span> cv.Laplacian(gray, cv.CV_16S, ksize<span class="op">=</span><span class="dv">3</span>)</a><a class="sourceLine" id="cb4-12" title="12">    Laplacian <span class="op">=</span> cv.convertScaleAbs(dst)</a><a class="sourceLine" id="cb4-13" title="13">    contour <span class="op">=</span> findContour(Laplacian)</a><a class="sourceLine" id="cb4-14" title="14">    contourArray <span class="op">=</span> contour[<span class="dv">0</span>][:, <span class="dv">0</span>, :]</a><a class="sourceLine" id="cb4-15" title="15">    retbg <span class="op">=</span> np.ones(dst.shape, np.uint8)</a><a class="sourceLine" id="cb4-16" title="16">    ret <span class="op">=</span> cv.drawContours(retbg, contour[<span class="dv">0</span>], <span class="dv">-1</span>, (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>), <span class="dv">1</span>)</a><a class="sourceLine" id="cb4-17" title="17">    contourComplex <span class="op">=</span> np.empty(contourArray.shape[:<span class="op">-</span><span class="dv">1</span>], dtype<span class="op">=</span><span class="bu">complex</span>)</a><a class="sourceLine" id="cb4-18" title="18">    contourComplex.real <span class="op">=</span> contourArray[:, <span class="dv">0</span>]</a><a class="sourceLine" id="cb4-19" title="19">    contourComplex.imag <span class="op">=</span> contourArray[:, <span class="dv">1</span>]</a><a class="sourceLine" id="cb4-20" title="20">    fourierResult <span class="op">=</span> np.fft.fft(contourComplex)</a><a class="sourceLine" id="cb4-21" title="21">    desInUse <span class="op">=</span> trucate(fourierResult)</a><a class="sourceLine" id="cb4-22" title="22">    <span class="cf">return</span> ret, desInUse</a></code></pre></div><p>根据傅里叶算子重构：</p><div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">def</span> reconstruct(img, desInUse):</a><a class="sourceLine" id="cb5-2" title="2">    contour_reconstruct <span class="op">=</span> np.fft.ifft(descirptor_in_use)</a><a class="sourceLine" id="cb5-3" title="3">    contour_reconstruct <span class="op">=</span> np.array([contour_reconstruct.real, contour_reconstruct.imag])</a><a class="sourceLine" id="cb5-4" title="4">    contour_reconstruct <span class="op">=</span> np.transpose(contour_reconstruct)</a><a class="sourceLine" id="cb5-5" title="5">    contour_reconstruct <span class="op">=</span> np.expand_dims(contour_reconstruct, axis<span class="op">=</span><span class="dv">1</span>)</a><a class="sourceLine" id="cb5-6" title="6">    <span class="cf">if</span> contour_reconstruct.<span class="bu">min</span>() <span class="op">&lt;</span> <span class="dv">0</span>:</a><a class="sourceLine" id="cb5-7" title="7">        contour_reconstruct <span class="op">-=</span> contour_reconstruct.<span class="bu">min</span>()</a><a class="sourceLine" id="cb5-8" title="8">    contour_reconstruct <span class="op">*=</span> img.shape[<span class="dv">0</span>] <span class="op">/</span> contour_reconstruct.<span class="bu">max</span>()</a><a class="sourceLine" id="cb5-9" title="9">    contour_reconstruct <span class="op">=</span> contour_reconstruct.astype(np.int32, copy<span class="op">=</span><span class="va">False</span>)</a><a class="sourceLine" id="cb5-10" title="10"></a><a class="sourceLine" id="cb5-11" title="11">    black_np <span class="op">=</span> np.ones(img.shape, np.uint8)  <span class="co"># 创建黑色幕布</span></a><a class="sourceLine" id="cb5-12" title="12">    black <span class="op">=</span> cv2.drawContours(black_np, contour_reconstruct, <span class="dv">-1</span>, (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>), <span class="dv">1</span>)  <span class="co"># 绘制白色轮廓</span></a><a class="sourceLine" id="cb5-13" title="13">    cv2.imshow(<span class="st">'contour_reconstruct'</span>, black)</a><a class="sourceLine" id="cb5-14" title="14">    <span class="cf">return</span> black</a></code></pre></div></li></ul><p>完成上面这些步骤后，就可以得到原始的训练样本了。</p><p>接着还要处理得到测试集与训练集。这里做的事情包括:</p><ul><li><p>改变原始图片尺寸</p><p>将尺寸从<span class="math inline">\(300\times 300\)</span>改成<span class="math inline">\(128\times 128\)</span>。</p></li><li><p>归一化</p><p>将图片中每个像素的值除以255。</p></li><li><p>划分测试集与训练集</p></li></ul><p>最后搭建CNN并训练了。CNN的结构如下：</p><table><thead><tr class="header"><th style="text-align: center;">Layer</th><th style="text-align: center;">Width</th><th style="text-align: center;">Height</th><th style="text-align: center;">Filter</th><th style="text-align: center;">Kernel Size</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Input</td><td style="text-align: center;">128</td><td style="text-align: center;">128</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td></tr><tr class="even"><td style="text-align: center;">Convolution</td><td style="text-align: center;">128</td><td style="text-align: center;">128</td><td style="text-align: center;">32</td><td style="text-align: center;">3×3</td></tr><tr class="odd"><td style="text-align: center;">Max Pooling</td><td style="text-align: center;">64</td><td style="text-align: center;">64</td><td style="text-align: center;">32</td><td style="text-align: center;">2×2</td></tr><tr class="even"><td style="text-align: center;">Convolution</td><td style="text-align: center;">64</td><td style="text-align: center;">64</td><td style="text-align: center;">64</td><td style="text-align: center;">3×3</td></tr><tr class="odd"><td style="text-align: center;">Max Pooling</td><td style="text-align: center;">32</td><td style="text-align: center;">32</td><td style="text-align: center;">64</td><td style="text-align: center;">2×2</td></tr><tr class="even"><td style="text-align: center;">Convolution</td><td style="text-align: center;">32</td><td style="text-align: center;">32</td><td style="text-align: center;">128</td><td style="text-align: center;">3×3</td></tr><tr class="odd"><td style="text-align: center;">Max Pooling</td><td style="text-align: center;">16</td><td style="text-align: center;">16</td><td style="text-align: center;">128</td><td style="text-align: center;">2×2</td></tr><tr class="even"><td style="text-align: center;">Flatten</td><td style="text-align: center;">32768</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td></tr><tr class="odd"><td style="text-align: center;">Dense</td><td style="text-align: center;">64</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td></tr><tr class="even"><td style="text-align: center;">Dropout</td><td style="text-align: center;">64</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td></tr><tr class="odd"><td style="text-align: center;">Dense</td><td style="text-align: center;">9</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td></tr></tbody></table><p>最终训练结果：</p><p><img src="https://pic.downk.cc/item/5f00128a14195aa5946f60ad.jpg"></p><p>效果还不错（至少目前来说）</p><h3 id="前端">前端</h3><p>前端部分做的事情除了展示界面，还包括以下这些：</p><ul><li><p>采集手势</p><p>调用摄像头并读取图像帧。代码如下：</p><div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">function</span> <span class="at">getMedia</span>() <span class="op">{</span></a><a class="sourceLine" id="cb6-2" title="2">  <span class="kw">let</span> constraints <span class="op">=</span> <span class="op">{</span></a><a class="sourceLine" id="cb6-3" title="3">    <span class="dt">video</span><span class="op">:</span> <span class="op">{</span></a><a class="sourceLine" id="cb6-4" title="4">      <span class="dt">width</span><span class="op">:</span> <span class="dv">400</span><span class="op">,</span> </a><a class="sourceLine" id="cb6-5" title="5">      <span class="dt">height</span><span class="op">:</span> <span class="dv">400</span><span class="op">,</span> </a><a class="sourceLine" id="cb6-6" title="6">      <span class="dt">facingMode</span><span class="op">:</span> <span class="st">'user'</span><span class="op">,</span></a><a class="sourceLine" id="cb6-7" title="7">      <span class="dt">mirrored</span><span class="op">:</span> <span class="kw">true</span></a><a class="sourceLine" id="cb6-8" title="8">    <span class="op">},</span></a><a class="sourceLine" id="cb6-9" title="9">    <span class="dt">audio</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span></a><a class="sourceLine" id="cb6-10" title="10">  <span class="op">};</span></a><a class="sourceLine" id="cb6-11" title="11">  <span class="kw">let</span> promise <span class="op">=</span> <span class="va">navigator</span>.<span class="va">mediaDevices</span>.<span class="at">getUserMedia</span>(constraints)<span class="op">;</span></a><a class="sourceLine" id="cb6-12" title="12">  <span class="va">promise</span>.<span class="at">then</span>(<span class="kw">function</span> (MediaStream) <span class="op">{</span></a><a class="sourceLine" id="cb6-13" title="13">    <span class="va">video</span>.<span class="at">srcObject</span> <span class="op">=</span> MediaStream<span class="op">;</span></a><a class="sourceLine" id="cb6-14" title="14">    <span class="va">video</span>.<span class="at">play</span>()<span class="op">;</span></a><a class="sourceLine" id="cb6-15" title="15">  <span class="op">}</span>).<span class="at">catch</span>(<span class="kw">function</span> (PermissionDeniedError) <span class="op">{</span></a><a class="sourceLine" id="cb6-16" title="16">    <span class="va">console</span>.<span class="at">log</span>(PermissionDeniedError)<span class="op">;</span></a><a class="sourceLine" id="cb6-17" title="17">  <span class="op">}</span>)<span class="op">;</span></a><a class="sourceLine" id="cb6-18" title="18"><span class="op">}</span></a></code></pre></div></li><li><p>数据处理</p>其实就是把在Opencv里的东西在Opencv.js上再实现一遍</li><li><p>模型预测</p><p>将处理后的图像帧数据转换为Tensorflow.js输入所对应的格式后，将其输入上述已经训练好的模型中，获得预测值</p></li><li><p>手势判断与输出</p><p>根据模型预测输出的Tensor判断手势类型，且根据“阈值溢出机制”判断是否向服务器发送手势。什么是“阈值溢出机制”呢？实际上就是，单位时间内，如果某个手势的出现频率超过一个阈值<span class="math inline">\(\lambda(&gt;0.5)\)</span>，则认为这一手势就是当前手势。</p></li></ul><h3 id="服务端">服务端</h3><p>这一部分通过TCP协议获取前端的手势识别结果，并根据这一结果，通过调用robot.js来完成相应操作。</p><p>服务端代码：</p><div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">const</span> net <span class="op">=</span> <span class="at">require</span>(<span class="st">'net'</span>)</a><a class="sourceLine" id="cb7-2" title="2"><span class="kw">const</span> robot <span class="op">=</span> <span class="at">require</span>(<span class="st">'robotjs'</span>)</a><a class="sourceLine" id="cb7-3" title="3"><span class="kw">let</span> controlable <span class="op">=</span> <span class="kw">false</span><span class="co">//解锁</span></a><a class="sourceLine" id="cb7-4" title="4"><span class="kw">let</span> directable <span class="op">=</span> <span class="kw">false</span><span class="co">//开启上下左右键</span></a><a class="sourceLine" id="cb7-5" title="5"><span class="kw">let</span> key_set <span class="op">=</span> []</a><a class="sourceLine" id="cb7-6" title="6"><span class="kw">function</span> <span class="at">clear_key</span>() <span class="op">{</span></a><a class="sourceLine" id="cb7-7" title="7">  <span class="cf">for</span> (<span class="kw">let</span> index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> index <span class="op">&lt;</span> <span class="va">key_set</span>.<span class="at">length</span><span class="op">;</span> index<span class="op">++</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-8" title="8">    <span class="va">robot</span>.<span class="at">keyToggle</span>(key_set[index]<span class="op">,</span> <span class="st">'up'</span>)<span class="op">;</span></a><a class="sourceLine" id="cb7-9" title="9">  <span class="op">}</span></a><a class="sourceLine" id="cb7-10" title="10">  key_set <span class="op">=</span> []</a><a class="sourceLine" id="cb7-11" title="11"><span class="op">}</span></a><a class="sourceLine" id="cb7-12" title="12"></a><a class="sourceLine" id="cb7-13" title="13"><span class="kw">function</span> <span class="at">minimize</span>() <span class="op">{</span></a><a class="sourceLine" id="cb7-14" title="14">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'minimize'</span>)</a><a class="sourceLine" id="cb7-15" title="15">  pre_gesture <span class="op">=</span> <span class="dv">7</span><span class="op">;</span></a><a class="sourceLine" id="cb7-16" title="16">  <span class="va">robot</span>.<span class="at">keyToggle</span>(<span class="st">'command'</span><span class="op">,</span> <span class="st">'down'</span>)</a><a class="sourceLine" id="cb7-17" title="17">  <span class="va">robot</span>.<span class="at">keyTap</span>(<span class="st">'D'</span>)</a><a class="sourceLine" id="cb7-18" title="18">  <span class="va">robot</span>.<span class="at">keyToggle</span>(<span class="st">'command'</span><span class="op">,</span> <span class="st">'up'</span>)</a><a class="sourceLine" id="cb7-19" title="19"></a><a class="sourceLine" id="cb7-20" title="20"><span class="op">}</span></a><a class="sourceLine" id="cb7-21" title="21"><span class="kw">function</span> <span class="at">closeWindow</span>() <span class="op">{</span></a><a class="sourceLine" id="cb7-22" title="22">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'closeWin'</span>)</a><a class="sourceLine" id="cb7-23" title="23">  pre_gesture <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></a><a class="sourceLine" id="cb7-24" title="24">  <span class="va">robot</span>.<span class="at">keyToggle</span>(<span class="st">'alt'</span><span class="op">,</span> <span class="st">'down'</span>)</a><a class="sourceLine" id="cb7-25" title="25">  <span class="va">robot</span>.<span class="at">keyTap</span>(<span class="st">'f4'</span>)</a><a class="sourceLine" id="cb7-26" title="26">  <span class="va">robot</span>.<span class="at">keyToggle</span>(<span class="st">'alt'</span><span class="op">,</span> <span class="st">'up'</span>)</a><a class="sourceLine" id="cb7-27" title="27">  </a><a class="sourceLine" id="cb7-28" title="28"><span class="op">}</span></a><a class="sourceLine" id="cb7-29" title="29"><span class="kw">function</span> <span class="at">altTab</span>() <span class="op">{</span></a><a class="sourceLine" id="cb7-30" title="30">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'altTab'</span>)</a><a class="sourceLine" id="cb7-31" title="31">  pre_gesture <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></a><a class="sourceLine" id="cb7-32" title="32">  <span class="va">robot</span>.<span class="at">keyToggle</span>(<span class="st">'alt'</span><span class="op">,</span> <span class="st">'down'</span>)</a><a class="sourceLine" id="cb7-33" title="33">  <span class="va">key_set</span>.<span class="at">push</span>(<span class="st">'alt'</span>)</a><a class="sourceLine" id="cb7-34" title="34">  <span class="va">robot</span>.<span class="at">keyTap</span>(<span class="st">'tab'</span>)</a><a class="sourceLine" id="cb7-35" title="35"><span class="op">}</span></a><a class="sourceLine" id="cb7-36" title="36"><span class="kw">function</span> <span class="at">re_altTab</span>() <span class="op">{</span></a><a class="sourceLine" id="cb7-37" title="37">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'re_altTab'</span>)</a><a class="sourceLine" id="cb7-38" title="38">  pre_gesture <span class="op">=</span> <span class="dv">9</span><span class="op">;</span></a><a class="sourceLine" id="cb7-39" title="39">  <span class="va">robot</span>.<span class="at">keyToggle</span>(<span class="st">'alt'</span><span class="op">,</span> <span class="st">'down'</span>)</a><a class="sourceLine" id="cb7-40" title="40">  <span class="va">key_set</span>.<span class="at">push</span>(<span class="st">'alt'</span>)</a><a class="sourceLine" id="cb7-41" title="41">  <span class="va">robot</span>.<span class="at">keyToggle</span>(<span class="st">'shift'</span><span class="op">,</span> <span class="st">'down'</span>)</a><a class="sourceLine" id="cb7-42" title="42">  <span class="va">key_set</span>.<span class="at">push</span>(<span class="st">'shift'</span>)</a><a class="sourceLine" id="cb7-43" title="43">  <span class="va">robot</span>.<span class="at">keyTap</span>(<span class="st">'tab'</span>)</a><a class="sourceLine" id="cb7-44" title="44"><span class="op">}</span></a><a class="sourceLine" id="cb7-45" title="45"><span class="kw">function</span> <span class="at">audioMute</span>() <span class="op">{</span></a><a class="sourceLine" id="cb7-46" title="46">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'audio_mute'</span>)</a><a class="sourceLine" id="cb7-47" title="47">  <span class="va">robot</span>.<span class="at">keyTap</span>(<span class="st">'audio_mute'</span>)<span class="op">;</span></a><a class="sourceLine" id="cb7-48" title="48"><span class="op">}</span></a><a class="sourceLine" id="cb7-49" title="49"></a><a class="sourceLine" id="cb7-50" title="50"><span class="kw">let</span> pre_gesture<span class="op">;</span></a><a class="sourceLine" id="cb7-51" title="51"><span class="kw">const</span> server <span class="op">=</span> <span class="va">net</span>.<span class="at">createServer</span>(<span class="kw">function</span> (sock) <span class="op">{</span></a><a class="sourceLine" id="cb7-52" title="52">  <span class="va">sock</span>.<span class="at">on</span>(<span class="st">'close'</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span></a><a class="sourceLine" id="cb7-53" title="53">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">'close socket'</span>)</a><a class="sourceLine" id="cb7-54" title="54">    <span class="va">server</span>.<span class="at">close</span>()</a><a class="sourceLine" id="cb7-55" title="55">  <span class="op">}</span>)</a><a class="sourceLine" id="cb7-56" title="56">  <span class="va">sock</span>.<span class="at">on</span>(<span class="st">'data'</span><span class="op">,</span> <span class="kw">function</span> (data) <span class="op">{</span></a><a class="sourceLine" id="cb7-57" title="57">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">'ok!'</span>)</a><a class="sourceLine" id="cb7-58" title="58">    <span class="va">console</span>.<span class="at">log</span>(<span class="va">data</span>.<span class="at">toString</span>())</a><a class="sourceLine" id="cb7-59" title="59">    <span class="kw">let</span> stringifyData <span class="op">=</span> <span class="va">data</span>.<span class="at">toString</span>()</a><a class="sourceLine" id="cb7-60" title="60">    <span class="cf">if</span> (stringifyData <span class="op">===</span> <span class="st">'5'</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-61" title="61">      directable <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></a><a class="sourceLine" id="cb7-62" title="62">      <span class="cf">if</span> (controlable) <span class="op">{</span></a><a class="sourceLine" id="cb7-63" title="63">        controlable <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></a><a class="sourceLine" id="cb7-64" title="64">        <span class="at">clear_key</span>()<span class="op">;</span></a><a class="sourceLine" id="cb7-65" title="65">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a><a class="sourceLine" id="cb7-66" title="66">        controlable <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a><a class="sourceLine" id="cb7-67" title="67">      <span class="op">}</span></a><a class="sourceLine" id="cb7-68" title="68">      pre_gesture <span class="op">=</span> stringifyData<span class="op">;</span></a><a class="sourceLine" id="cb7-69" title="69">    <span class="op">}</span></a><a class="sourceLine" id="cb7-70" title="70">    <span class="cf">if</span> (controlable) <span class="op">{</span></a><a class="sourceLine" id="cb7-71" title="71">      <span class="cf">if</span> (directable) <span class="op">{</span></a><a class="sourceLine" id="cb7-72" title="72">        <span class="cf">if</span> (stringifyData <span class="op">===</span> <span class="st">'1'</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-73" title="73">          <span class="va">console</span>.<span class="at">log</span>(<span class="st">'up'</span>)</a><a class="sourceLine" id="cb7-74" title="74">          <span class="va">robot</span>.<span class="at">keyTap</span>(<span class="st">'up'</span>)</a><a class="sourceLine" id="cb7-75" title="75">        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (stringifyData <span class="op">===</span> <span class="st">'7'</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-76" title="76">          <span class="va">console</span>.<span class="at">log</span>(<span class="st">'down'</span>)</a><a class="sourceLine" id="cb7-77" title="77">          <span class="va">robot</span>.<span class="at">keyTap</span>(<span class="st">'down'</span>)</a><a class="sourceLine" id="cb7-78" title="78">        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (stringifyData <span class="op">===</span> <span class="st">'8'</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-79" title="79">          <span class="va">console</span>.<span class="at">log</span>(<span class="st">'right'</span>)</a><a class="sourceLine" id="cb7-80" title="80">          <span class="va">robot</span>.<span class="at">keyTap</span>(<span class="st">'right'</span>)</a><a class="sourceLine" id="cb7-81" title="81">        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (stringifyData <span class="op">===</span> <span class="st">'9'</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-82" title="82">          <span class="va">console</span>.<span class="at">log</span>(<span class="st">'left'</span>)</a><a class="sourceLine" id="cb7-83" title="83">          <span class="va">robot</span>.<span class="at">keyTap</span>(<span class="st">'left'</span>)</a><a class="sourceLine" id="cb7-84" title="84">        <span class="op">}</span></a><a class="sourceLine" id="cb7-85" title="85">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a><a class="sourceLine" id="cb7-86" title="86">        <span class="cf">if</span> (stringifyData <span class="op">!=</span> pre_gesture) <span class="op">{</span></a><a class="sourceLine" id="cb7-87" title="87">          <span class="at">clear_key</span>()</a><a class="sourceLine" id="cb7-88" title="88">        <span class="op">}</span></a><a class="sourceLine" id="cb7-89" title="89">        <span class="cf">if</span> (stringifyData <span class="op">===</span> <span class="st">'6'</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-90" title="90">          <span class="at">audioMute</span>()</a><a class="sourceLine" id="cb7-91" title="91">        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (stringifyData <span class="op">===</span> <span class="st">'7'</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-92" title="92">          <span class="at">minimize</span>()</a><a class="sourceLine" id="cb7-93" title="93">        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (stringifyData <span class="op">===</span> <span class="st">'4'</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-94" title="94">          directable <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a><a class="sourceLine" id="cb7-95" title="95">        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (stringifyData <span class="op">===</span> <span class="st">'2'</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-96" title="96">          <span class="at">closeWindow</span>()</a><a class="sourceLine" id="cb7-97" title="97">        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (stringifyData <span class="op">===</span> <span class="st">'9'</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-98" title="98">          <span class="at">re_altTab</span>()</a><a class="sourceLine" id="cb7-99" title="99">        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (stringifyData <span class="op">===</span> <span class="st">'8'</span>) <span class="op">{</span></a><a class="sourceLine" id="cb7-100" title="100">          <span class="at">altTab</span>()</a><a class="sourceLine" id="cb7-101" title="101">        <span class="op">}</span></a><a class="sourceLine" id="cb7-102" title="102">      <span class="op">}</span></a><a class="sourceLine" id="cb7-103" title="103">    <span class="op">}</span></a><a class="sourceLine" id="cb7-104" title="104">  <span class="op">}</span>)</a><a class="sourceLine" id="cb7-105" title="105"><span class="op">}</span>)</a><a class="sourceLine" id="cb7-106" title="106"></a><a class="sourceLine" id="cb7-107" title="107"><span class="va">server</span>.<span class="at">on</span>(<span class="st">'listening'</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span></a><a class="sourceLine" id="cb7-108" title="108">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'start listening'</span>)</a><a class="sourceLine" id="cb7-109" title="109"><span class="op">}</span>)</a><a class="sourceLine" id="cb7-110" title="110"></a><a class="sourceLine" id="cb7-111" title="111"><span class="va">server</span>.<span class="at">on</span>(<span class="st">'error'</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span></a><a class="sourceLine" id="cb7-112" title="112">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'listen error'</span>)</a><a class="sourceLine" id="cb7-113" title="113"><span class="op">}</span>)</a><a class="sourceLine" id="cb7-114" title="114"></a><a class="sourceLine" id="cb7-115" title="115"><span class="va">server</span>.<span class="at">on</span>(<span class="st">'close'</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span></a><a class="sourceLine" id="cb7-116" title="116">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'stop listening'</span>)</a><a class="sourceLine" id="cb7-117" title="117"><span class="op">}</span>)</a><a class="sourceLine" id="cb7-118" title="118"></a><a class="sourceLine" id="cb7-119" title="119"><span class="va">server</span>.<span class="at">listen</span>(<span class="op">{</span></a><a class="sourceLine" id="cb7-120" title="120">  <span class="dt">port</span><span class="op">:</span> <span class="dv">6080</span><span class="op">,</span></a><a class="sourceLine" id="cb7-121" title="121">  <span class="dt">host</span><span class="op">:</span> <span class="st">'127.0.0.1'</span><span class="op">,</span></a><a class="sourceLine" id="cb7-122" title="122">  <span class="dt">exclusive</span><span class="op">:</span> <span class="kw">true</span></a><a class="sourceLine" id="cb7-123" title="123"><span class="op">}</span>)</a></code></pre></div><p>electron的主进程中连接服务端并发送手势识别结果</p><div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">const</span> sockConfig <span class="op">=</span> <span class="op">{</span></a><a class="sourceLine" id="cb8-2" title="2">  <span class="dt">port</span><span class="op">:</span> <span class="dv">6080</span><span class="op">,</span></a><a class="sourceLine" id="cb8-3" title="3">  <span class="dt">host</span><span class="op">:</span> <span class="st">'127.0.0.1'</span></a><a class="sourceLine" id="cb8-4" title="4"><span class="op">}</span></a><a class="sourceLine" id="cb8-5" title="5"><span class="kw">const</span> sock <span class="op">=</span> <span class="va">net</span>.<span class="at">connect</span>(sockConfig<span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span></a><a class="sourceLine" id="cb8-6" title="6">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'connected to server!'</span>)</a><a class="sourceLine" id="cb8-7" title="7"><span class="op">}</span>)</a><a class="sourceLine" id="cb8-8" title="8"></a><a class="sourceLine" id="cb8-9" title="9"><span class="va">sock</span>.<span class="at">on</span>(<span class="st">'connect'</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span></a><a class="sourceLine" id="cb8-10" title="10">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">'connect success'</span>)</a><a class="sourceLine" id="cb8-11" title="11"><span class="op">}</span>)</a><a class="sourceLine" id="cb8-12" title="12"></a><a class="sourceLine" id="cb8-13" title="13"><span class="kw">function</span> <span class="at">sendGesture</span>(ges) <span class="op">{</span></a><a class="sourceLine" id="cb8-14" title="14">  <span class="kw">let</span> ges2string <span class="op">=</span> <span class="va">ges</span>.<span class="at">toString</span>()</a><a class="sourceLine" id="cb8-15" title="15">  <span class="va">console</span>.<span class="at">log</span>(ges2string)</a><a class="sourceLine" id="cb8-16" title="16">  <span class="va">sock</span>.<span class="at">write</span>(ges2string)</a><a class="sourceLine" id="cb8-17" title="17"><span class="op">}</span></a></code></pre></div><h2 id="最终实现效果">最终实现效果</h2><p><img src="https://pic.downk.cc/item/5f00185114195aa59471b6bb.png"></p><center>为了避免误操作，一开始是上锁状态，无法操作</center><p><img src="https://pic.downk.cc/item/5f00188214195aa59471cc29.png"></p><center>手势5解锁</center><p><img src="https://pic.downk.cc/item/5f0018a814195aa59471daeb.png"></p><center>无法识别手势，需要调整手势</center>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f00278014195aa594787856.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://xtayex.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://xtayex.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="手势识别" scheme="https://xtayex.gitee.io/tags/%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/"/>
    
    <category term="人机交互" scheme="https://xtayex.gitee.io/tags/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
    <category term="JavaScript" scheme="https://xtayex.gitee.io/tags/JavaScript/"/>
    
    <category term="Electron" scheme="https://xtayex.gitee.io/tags/Electron/"/>
    
    <category term="Tensorflow" scheme="https://xtayex.gitee.io/tags/Tensorflow/"/>
    
    <category term="Python" scheme="https://xtayex.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>AGC016B Colorful Hats</title>
    <link href="https://xtayex.gitee.io/2020/03/03/ACG016B-Colorful-Hats/"/>
    <id>https://xtayex.gitee.io/2020/03/03/ACG016B-Colorful-Hats/</id>
    <published>2020-03-03T15:02:00.000Z</published>
    <updated>2022-09-27T13:46:54.847Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5e5e72b398271cb2b862f2b8.jpg"></p><span id="more"></span><p>题意是说，每只猫都带有一顶帽子，且每只猫能看到除自己以外的其他人的帽子总共有多少种颜色。问是否能构造出一个帽子颜色的序列，满足每只猫看到的颜色数目。</p><p>设看到的颜色数的最大值为<span class="math inline">\(maxi\)</span>，最小值为<span class="math inline">\(mini\)</span>。</p><p>一个显而易见的结论是，如果<span class="math inline">\(maxi-mini&gt;1\)</span>，则结果为No(可自行验证)</p><p>然后考虑<span class="math inline">\(maxi==mini\)</span>的情况。如果两者的值是1或<span class="math inline">\(n-1\)</span>，那结果是Yes</p><p>否则，对于任意一种颜色，必须要有至少两只猫的帽子是这种颜色的。（草稿纸上画个图即可知道，原因是，假设有一种颜色只被一只猫所拥有，因为自己是看不到自己的帽子的，所以对于这只猫来说，他所看到的帽子的颜色会比其他猫所看到的颜色少一种，这就不符合初始条件）</p><p>最后考虑<span class="math inline">\(maxi!=mini\)</span>的情况。对于那些颜色数为<span class="math inline">\(mini\)</span>的猫，其帽子的颜色必然只为它所拥有，即这种颜色只会在一只猫的头上出现；而对于那些颜色数为<span class="math inline">\(maxi\)</span>的猫，其帽子的颜色则至少要被两只猫拥有。所以可以先把颜色数为<span class="math inline">\(mini\)</span>的都填充了，然后看看剩下的颜色是否可以保证填入剩下的猫之后，每种颜色至少被两只猫所拥有。</p><p>PS：蒟蒻第一次做atcoder，感觉真的好锻炼思维qwq</p><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb1-6" title="6"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb1-7" title="7"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb1-8" title="8"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb1-9" title="9"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb1-10" title="10"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb1-11" title="11"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb1-12" title="12"><span class="pp">#define mst</span>(a,b)<span class="pp"> </span>memset((a),(b),<span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb1-13" title="13"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb1-14" title="14"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb1-15" title="15"><span class="pp">#define lson </span>lef,mid,rt&lt;&lt;<span class="dv">1</span></a><a class="sourceLine" id="cb1-16" title="16"><span class="pp">#define rson </span>mid+<span class="dv">1</span>,rig,rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span></a><a class="sourceLine" id="cb1-17" title="17"><span class="at">const</span> <span class="dt">int</span> maxn=<span class="fl">1e5</span>+<span class="dv">5</span>;</a><a class="sourceLine" id="cb1-18" title="18"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb1-19" title="19"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb1-20" title="20"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb1-21" title="21"><span class="dt">int</span> arr[maxn];</a><a class="sourceLine" id="cb1-22" title="22"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb1-23" title="23">{</a><a class="sourceLine" id="cb1-24" title="24">    <span class="dt">int</span> n;scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;n);</a><a class="sourceLine" id="cb1-25" title="25">    <span class="dt">int</span> maxi=-INF;<span class="dt">int</span> mini=INF;</a><a class="sourceLine" id="cb1-26" title="26">    <span class="dt">int</span> minicnt=<span class="dv">0</span>;</a><a class="sourceLine" id="cb1-27" title="27">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++){</a><a class="sourceLine" id="cb1-28" title="28">        scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;arr[i]);</a><a class="sourceLine" id="cb1-29" title="29">        maxi=max(maxi,arr[i]);</a><a class="sourceLine" id="cb1-30" title="30">        mini=min(mini,arr[i]);</a><a class="sourceLine" id="cb1-31" title="31">    }</a><a class="sourceLine" id="cb1-32" title="32">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++){</a><a class="sourceLine" id="cb1-33" title="33">        <span class="cf">if</span>(arr[i]==mini) minicnt++;</a><a class="sourceLine" id="cb1-34" title="34">    }</a><a class="sourceLine" id="cb1-35" title="35">    <span class="cf">if</span>(maxi-mini&gt;<span class="dv">1</span>||maxi&gt;n-<span class="dv">1</span>){</a><a class="sourceLine" id="cb1-36" title="36">        puts(<span class="st">"No"</span>);</a><a class="sourceLine" id="cb1-37" title="37">    }<span class="cf">else</span> <span class="cf">if</span>(maxi==mini){</a><a class="sourceLine" id="cb1-38" title="38">        <span class="cf">if</span>(mini==n-<span class="dv">1</span>||mini==<span class="dv">1</span>) puts(<span class="st">"Yes"</span>);</a><a class="sourceLine" id="cb1-39" title="39">        <span class="cf">else</span>{</a><a class="sourceLine" id="cb1-40" title="40">            <span class="cf">if</span>(n/mini&gt;=<span class="dv">2</span>){</a><a class="sourceLine" id="cb1-41" title="41">                puts(<span class="st">"Yes"</span>);</a><a class="sourceLine" id="cb1-42" title="42">            }<span class="cf">else</span>{</a><a class="sourceLine" id="cb1-43" title="43">                puts(<span class="st">"No"</span>);</a><a class="sourceLine" id="cb1-44" title="44">            }</a><a class="sourceLine" id="cb1-45" title="45">        }</a><a class="sourceLine" id="cb1-46" title="46">    }<span class="cf">else</span> <span class="cf">if</span>(maxi!=mini){</a><a class="sourceLine" id="cb1-47" title="47">        <span class="dt">int</span> x=n-minicnt;</a><a class="sourceLine" id="cb1-48" title="48">        <span class="dt">int</span> y=maxi-minicnt;</a><a class="sourceLine" id="cb1-49" title="49">        <span class="cf">if</span>(y==<span class="dv">0</span>) puts(<span class="st">"No"</span>);</a><a class="sourceLine" id="cb1-50" title="50">        <span class="cf">else</span>{</a><a class="sourceLine" id="cb1-51" title="51">            <span class="cf">if</span>(x/y&lt;<span class="dv">2</span>) puts(<span class="st">"No"</span>);</a><a class="sourceLine" id="cb1-52" title="52">            <span class="cf">else</span> puts(<span class="st">"Yes"</span>);</a><a class="sourceLine" id="cb1-53" title="53">        }</a><a class="sourceLine" id="cb1-54" title="54">    }</a><a class="sourceLine" id="cb1-55" title="55">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-56" title="56">}</a></code></pre></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5e5e72b398271cb2b862f2b8.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/categories/ACM/"/>
    
    <category term="Atcoder" scheme="https://xtayex.gitee.io/categories/ACM/Atcoder/"/>
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/tags/ACM/"/>
    
    <category term="思维" scheme="https://xtayex.gitee.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
    <category term="Atcoder" scheme="https://xtayex.gitee.io/tags/Atcoder/"/>
    
  </entry>
  
  <entry>
    <title>线段树与树状数组总结</title>
    <link href="https://xtayex.gitee.io/2020/02/05/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/"/>
    <id>https://xtayex.gitee.io/2020/02/05/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-05T15:04:00.000Z</published>
    <updated>2022-09-27T13:46:55.123Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5e3adbdf2fb38b8c3ccee2f7.jpg"> <span id="more"></span> 本文章为2020年寒训用资料，有部分删减</p><h2 id="线段树">线段树</h2><h3 id="引入">引入</h3><p>问题引入：</p><ul><li>问题一：给定一个长度为<span class="math inline">\(n\)</span>的数列，可以进行<span class="math inline">\(m\)</span>次询问，每次询问查询区间<span class="math inline">\([l,r]\)</span>内所有数的和<ul><li>如果数据范围很小（例如<span class="math inline">\(n\leq 1000,m\leq 100\)</span>），可以直接枚举。复杂度<span class="math inline">\(O(n)\)</span></li><li>如果数据范围较大（例如<span class="math inline">\(n\leq 1e6,m\leq 1e3\)</span>），可以用前缀和。复杂度<span class="math inline">\(O(n+m)\)</span></li></ul></li><li>问题二：给定一个长度为<span class="math inline">\(n\)</span>的数列，可以进行<span class="math inline">\(m\)</span>次操作，操作分两种，一种是修改单点的数值，另一种是查询区间<span class="math inline">\([l,r]\)</span>内所有数的和<ul><li>如果数据范围很小，依然可以枚举。复杂度<span class="math inline">\(O(n)\)</span></li><li>但大数据范围的情况下会TLE</li><li>此时即使使用前缀和，在进行修改操作后需要维护前缀和，故复杂度与枚举一致。大数据范围的情况下依然会TLE</li></ul></li><li>问题三：给定一个长度为<span class="math inline">\(n\)</span>的数列，可以进行<span class="math inline">\(m\)</span>次操作，操作分两种，一种是修改区间<span class="math inline">\([l,r]\)</span>内每个数的数值，另一种是查询区间<span class="math inline">\([l,r]\)</span>内所有数的和<ul><li>数据范围小的话当然可以枚举……</li><li>如果数据范围很大呢？（例如<span class="math inline">\(n\leq 1e6,m\leq 1e3\)</span>）</li></ul></li></ul><h3 id="线段树是什么">线段树是什么</h3><p>线段树是一种二叉树，它的基本思想是在二叉树的节点上保存区间信息，并在树上进行区间。下图是区间<span class="math inline">\([1,7]\)</span>对应的线段树</p><p><img src="https://pic.downk.cc/item/5e3ada242fb38b8c3cceb6bb.png"></p><p>上面这张图所表示的意思是，以求区间和为例，对于区间<span class="math inline">\([1,7]\)</span>，其区间和等于其左儿子<span class="math inline">\(([1,4])\)</span>的区间和加上其右儿子<span class="math inline">\([5,7]\)</span>的区间和；而区间<span class="math inline">\([1,4]\)</span>的区间和又等于区间<span class="math inline">\([1,2]\)</span>和区间<span class="math inline">\([3,4]\)</span>的和。对于一个区间<span class="math inline">\([lef,rig]\)</span>，其左右儿子分别为<span class="math inline">\([lef,\lfloor(lef+rig)/2\rfloor]\)</span>，<span class="math inline">\([\lfloor(lef+rig)/2\rfloor+1,rig]\)</span>。对于线段树上的各节点，我们采取从上到下、从左往右的编号方法。具体而言，以上图为例，<span class="math inline">\([1,7]\)</span>是编号为1，<span class="math inline">\([1,4]\)</span>编号为2，<span class="math inline">\([5,7]\)</span>编号为3……</p><p>对于查询与修改，线段树的复杂度都是<span class="math inline">\(O(\log_2n)\)</span></p><h3 id="建树">建树</h3><p>根据线段树的结构和节点编号方式，我们很容易得到以下建树方式</p><div class="sourceCode" id="cb1"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">int</span> sum[maxn&lt;&lt;<span class="dv">2</span>]</a><a class="sourceLine" id="cb1-2" title="2"><span class="dt">void</span> pushup(<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb1-3" title="3">{</a><a class="sourceLine" id="cb1-4" title="4">    sum[rt]=sum[rt&lt;&lt;<span class="dv">1</span>]+sum[rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>];</a><a class="sourceLine" id="cb1-5" title="5">}</a><a class="sourceLine" id="cb1-6" title="6"><span class="dt">void</span> build(<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb1-7" title="7">{</a><a class="sourceLine" id="cb1-8" title="8">    <span class="cf">if</span>(lef==rig){</a><a class="sourceLine" id="cb1-9" title="9">        <span class="dt">int</span> tmp;</a><a class="sourceLine" id="cb1-10" title="10">        scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;tmp);</a><a class="sourceLine" id="cb1-11" title="11">        sum[rt]=tmp;</a><a class="sourceLine" id="cb1-12" title="12">        <span class="cf">return</span> ;</a><a class="sourceLine" id="cb1-13" title="13">    }</a><a class="sourceLine" id="cb1-14" title="14">    <span class="dt">int</span> mid=(lef+rig)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb1-15" title="15">    build(lef,mid,rt&lt;&lt;<span class="dv">1</span>);</a><a class="sourceLine" id="cb1-16" title="16">    build(mid+<span class="dv">1</span>,rig,rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>);</a><a class="sourceLine" id="cb1-17" title="17">    pushup(rt);</a><a class="sourceLine" id="cb1-18" title="18">}</a></code></pre></div><p>代码很短，但有些地方可能会让初次接触的人稍微有点疑惑：</p><ul><li><p>maxn&lt;&lt;2是什么意思？</p><p>此处maxn表示的是最大区间长度，maxn&lt;&lt;2等同于4 * maxn。sum是用来存我们的线段树节点的数组。为什么需要开4倍大的空间呢？首先，线段树是一棵完全二叉树， 对于一棵完全二叉树，假如有<span class="math inline">\(n\)</span>个叶子节点（对应到线段树上就是区间总长度为<span class="math inline">\(n\)</span>），其总节点数为<span class="math inline">\(2n-1\)</span>。似乎开2倍就够了呢……但经验告诉我们，开四倍是较为保险的选择，既不会太大导致MLE，也不会太小导致越界。</p></li><li><p>rt&lt;&lt;1和rt&lt;&lt;1|1</p><p>由于线段树节点的编号方式，父节点和其两个子节点的编号存在这样的关系：<span class="math display">\[id_{leftson}=2\times id_{father}\]</span>，<span class="math display">\[id_{rigson}=2\times id_{father}+1\]</span></p><p>为了提高速度，我们使用位运算来代替乘法、加法。</p></li><li><p>pushup</p><p>父亲节点的信息来自于两个子节点，故在完成子节点的建立后，我们要用两个子节点来建立父亲节点</p></li></ul><h3 id="单点操作">单点操作</h3><p>单点操作包括单点查询与单点修改</p><h4 id="单点查询">单点查询</h4><p>单点查询的大致思想与二分查找类似。如果需要查询的位置<span class="math inline">\(pos\)</span>在当前区间的左侧，则查找当前区间的左儿子；否则，查找当前区间的右儿子。重复这一过程，直至区间左右端点相等，则说明已经找到。</p><p>代码如下：</p><div class="sourceCode" id="cb2"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">int</span> ans;</a><a class="sourceLine" id="cb2-2" title="2"><span class="dt">void</span> query(<span class="dt">int</span> pos,<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb2-3" title="3">{</a><a class="sourceLine" id="cb2-4" title="4">    <span class="cf">if</span>(lef==rig){</a><a class="sourceLine" id="cb2-5" title="5">        ans=sum[rt];</a><a class="sourceLine" id="cb2-6" title="6">        <span class="cf">return</span> ;</a><a class="sourceLine" id="cb2-7" title="7">    }</a><a class="sourceLine" id="cb2-8" title="8">    <span class="dt">int</span> mid=(lef+rig)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb2-9" title="9">    <span class="cf">if</span>(pos&lt;=mid) query(pos,lef,mid,rt&lt;&lt;<span class="dv">1</span>);</a><a class="sourceLine" id="cb2-10" title="10">    <span class="cf">else</span> <span class="cf">if</span>(pos&gt;mid) query(pos,mid+<span class="dv">1</span>,rig,rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>);</a><a class="sourceLine" id="cb2-11" title="11">}</a></code></pre></div><h4 id="单点修改">单点修改</h4><p>单点修改代码如下：</p><div class="sourceCode" id="cb3"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">void</span> update(<span class="dt">int</span> pos,<span class="dt">int</span> val,<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb3-2" title="2">{</a><a class="sourceLine" id="cb3-3" title="3">    <span class="cf">if</span>(lef==rig){</a><a class="sourceLine" id="cb3-4" title="4">        sum[rt]+=val;</a><a class="sourceLine" id="cb3-5" title="5">        <span class="cf">return</span> ;</a><a class="sourceLine" id="cb3-6" title="6">    }</a><a class="sourceLine" id="cb3-7" title="7">    <span class="dt">int</span> mid=(lef+rig)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb3-8" title="8">    <span class="cf">if</span>(pos&lt;=mid) update(pos,val,lef,mid,rt&lt;&lt;<span class="dv">1</span>);</a><a class="sourceLine" id="cb3-9" title="9">    <span class="cf">else</span> <span class="cf">if</span>(pos&gt;mid) update(pos,val,mid+<span class="dv">1</span>,rig,rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>);</a><a class="sourceLine" id="cb3-10" title="10">    pushup(rt);</a><a class="sourceLine" id="cb3-11" title="11">}</a></code></pre></div><p>与单点查询基本一致，但要记得最后pushup一下来更新父节点。</p><h3 id="区间操作">区间操作</h3><p>区间操作的总体思想是，对于带查询的区间<span class="math inline">\([L,R]\)</span>，如果当前区间<span class="math inline">\([lef,rig]\)</span>完全包含在带查询区间中，就直接将<span class="math inline">\([lef,rig]\)</span>上的信息统计到答案中。如下所示 <span class="math display">\[\underbrace{L,L+1,\dots \overbrace{lef,lef+1,\dots ,rig-1,rig}\dots ,R-1,R}\]</span> 否则，如果当前区间不是完全包含在待查询区间内，就查询左儿子或右儿子。如下所示 <span class="math display">\[\rlap{\overbrace{\phantom{lef,lef+1,\dots,L,L+1,\dots,rig-1,rig}}} lef,lef+1,\dots, \underbrace{L, L+1,\dots,rig-1,rig,\dots,R-1,R}\]</span></p><h4 id="区间查询">区间查询</h4><p>借用上面所提到的总体思想，可以写出这样的代码：</p><div class="sourceCode" id="cb4"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">int</span> query(<span class="dt">int</span> L,<span class="dt">int</span> R,<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb4-2" title="2">{</a><a class="sourceLine" id="cb4-3" title="3">    <span class="cf">if</span>(lef&gt;=L&amp;&amp;rig&lt;=R){</a><a class="sourceLine" id="cb4-4" title="4">           <span class="cf">return</span> sum[rt];     </a><a class="sourceLine" id="cb4-5" title="5">    }</a><a class="sourceLine" id="cb4-6" title="6">    <span class="dt">int</span> mid=(lef+rig)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb4-7" title="7">    <span class="dt">int</span> ret=<span class="dv">0</span>;</a><a class="sourceLine" id="cb4-8" title="8">    <span class="cf">if</span>(L&lt;=mid) ret+=query(L,R,lef,mid,rt&lt;&lt;<span class="dv">1</span>);</a><a class="sourceLine" id="cb4-9" title="9">    <span class="cf">if</span>(R&gt;mid) ret+=query(L,R,mid+<span class="dv">1</span>,rt&lt;&lt;<span class="dv">1</span>); </a><a class="sourceLine" id="cb4-10" title="10">}</a></code></pre></div><h4 id="区间修改">区间修改</h4><p>借用单点修改的思想，很容易想到，区间修改就是相当于调用多次单点修改，把区间内的数字都修改了。举个例子，对于区间<span class="math inline">\([1,7]\)</span>，如果我们要修改<span class="math inline">\([2,7]\)</span>内的数，那最终被修改的节点如下图所示 <img src="https://pic.downk.cc/item/5e3ada522fb38b8c3ccebc1d.png"></p><p>一个很明显的问题在于，这样做的话，复杂度会比直接暴力修改还高！而且，如果我要查询的只是<span class="math inline">\([5,7]\)</span>的子区间，那就会存在不必要的修改。比如说我要查询<span class="math inline">\([1,5]\)</span>，那<span class="math inline">\([5,6]\)</span>等等的修改就没有用。</p><p>事实上，要修改区间<span class="math inline">\([2,7]\)</span>，我们可以仅仅修改我们需要的区间。具体而言，修改的时候只需要修改<span class="math inline">\([1,7],[1,4],[1,2],[2,2],[3,4],[5,7]\)</span>。等到需要查询这些区间以外的区间时，再去进行相应的修改。这就是懒惰标记（lazy tag）的思想</p><p>所谓懒惰，就是“要用的时候才用，否则就不用”。具体来说，懒惰标记用于存储父节点的修改信息，但暂时不把信息传给子节点，等到需要用到子节点时再把信息传给子节点。</p><p>加上了懒惰标记的区间修改代码如下：</p><div class="sourceCode" id="cb5"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">void</span> pushdown(<span class="dt">int</span> rt,<span class="dt">int</span> len)</a><a class="sourceLine" id="cb5-2" title="2">{</a><a class="sourceLine" id="cb5-3" title="3">    <span class="cf">if</span>(lazy[rt]){</a><a class="sourceLine" id="cb5-4" title="4">        lazy[rt&lt;&lt;<span class="dv">1</span>]+=lazy[rt];</a><a class="sourceLine" id="cb5-5" title="5">        lazy[rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]+=lazy[rt];</a><a class="sourceLine" id="cb5-6" title="6">        sum[rt&lt;&lt;<span class="dv">1</span>]=lazy[rt&lt;&lt;<span class="dv">1</span>]*(len-(len&gt;&gt;<span class="dv">1</span>));</a><a class="sourceLine" id="cb5-7" title="7">        sum[rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=lazy[rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]*(len&gt;&gt;<span class="dv">1</span>);</a><a class="sourceLine" id="cb5-8" title="8">        lazy[rt]=<span class="dv">0</span>;</a><a class="sourceLine" id="cb5-9" title="9">    }</a><a class="sourceLine" id="cb5-10" title="10">}</a><a class="sourceLine" id="cb5-11" title="11"><span class="dt">void</span> update(<span class="dt">int</span> L,<span class="dt">int</span> R,<span class="dt">int</span> val,<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb5-12" title="12">{</a><a class="sourceLine" id="cb5-13" title="13">    <span class="cf">if</span>(lef&gt;=L&amp;&amp;rig&lt;=R){</a><a class="sourceLine" id="cb5-14" title="14">        sum[rt]+=val*(rig-lef+<span class="dv">1</span>);</a><a class="sourceLine" id="cb5-15" title="15">        lazy[rt]+=val;</a><a class="sourceLine" id="cb5-16" title="16">        <span class="cf">return</span> ;</a><a class="sourceLine" id="cb5-17" title="17">    }</a><a class="sourceLine" id="cb5-18" title="18">    pushdown(rt);</a><a class="sourceLine" id="cb5-19" title="19">    <span class="dt">int</span> mid=(lef+rig)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb5-20" title="20">    <span class="cf">if</span>(L&lt;=mid) update(L,R,val,lef,mid,rt&lt;&lt;<span class="dv">1</span>);</a><a class="sourceLine" id="cb5-21" title="21">    <span class="cf">if</span>(R&gt;mid) update(L,R,val,mid+<span class="dv">1</span>);</a><a class="sourceLine" id="cb5-22" title="22">    pushup(rt);</a><a class="sourceLine" id="cb5-23" title="23">}</a></code></pre></div><p>加上懒惰标记后，同样是修改<span class="math inline">\([2,7]\)</span>这一区间，被修改的区间如下所示：</p><p><img src="https://pic.downk.cc/item/5e3ada6a2fb38b8c3ccebf3e.png"></p><p>另外，在引入了懒惰标记后，单点查询、区间查询的代码也要更改（其实就是加上pushdown而已）。具体如下：</p><p>单点查询：</p><div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">int</span> query(<span class="dt">int</span> pos,<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb6-2" title="2">{</a><a class="sourceLine" id="cb6-3" title="3">    <span class="cf">if</span>(lef==rig){</a><a class="sourceLine" id="cb6-4" title="4">           <span class="cf">return</span> sum[rt];     </a><a class="sourceLine" id="cb6-5" title="5">    }</a><a class="sourceLine" id="cb6-6" title="6">    pushdown(rt);</a><a class="sourceLine" id="cb6-7" title="7">    <span class="dt">int</span> ret=<span class="dv">0</span>;</a><a class="sourceLine" id="cb6-8" title="8">    <span class="dt">int</span> mid=(lef+rig)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb6-9" title="9">    <span class="cf">if</span>(lef&lt;=mid) ret+=query(pos,lef,mid,rt&lt;&lt;<span class="dv">1</span>);</a><a class="sourceLine" id="cb6-10" title="10">    <span class="cf">else</span> <span class="cf">if</span>(rig&gt;mid) ret+=query(pos,mid+<span class="dv">1</span>,rig,rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>);</a><a class="sourceLine" id="cb6-11" title="11">    <span class="cf">return</span> ret;</a><a class="sourceLine" id="cb6-12" title="12">}</a></code></pre></div><p>区间查询：</p><div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">int</span> query(<span class="dt">int</span> L,<span class="dt">int</span> R,<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb7-2" title="2">{</a><a class="sourceLine" id="cb7-3" title="3">    <span class="cf">if</span>(L&gt;=lef&amp;&amp;R&lt;=rig){</a><a class="sourceLine" id="cb7-4" title="4">        <span class="cf">return</span> sum[rt];</a><a class="sourceLine" id="cb7-5" title="5">    }</a><a class="sourceLine" id="cb7-6" title="6">    pushdown(rt);</a><a class="sourceLine" id="cb7-7" title="7">    <span class="dt">int</span> ret=<span class="dv">0</span>;</a><a class="sourceLine" id="cb7-8" title="8">    <span class="dt">int</span> mid=(lef+rig)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb7-9" title="9">    <span class="cf">if</span>(L&lt;=mid) ret+=query(L,R,lef,mid,rt&lt;&lt;<span class="dv">1</span>);</a><a class="sourceLine" id="cb7-10" title="10">    <span class="cf">if</span>(R&gt;mid) ret+=query(L,R,mid+<span class="dv">1</span>,rig,rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>);</a><a class="sourceLine" id="cb7-11" title="11">    <span class="cf">return</span> ret;</a><a class="sourceLine" id="cb7-12" title="12">}</a></code></pre></div><h3 id="减法运算和乘法运算">减法运算和乘法运算</h3><p>上面所提到的都是修改与查询都是基于加法的，那如果是减法、乘法、除法呢？</p><ul><li><p>如果是减法的话就直接加上负数即可。</p></li><li><p>如果是乘法或除法的话，就要另当别论。</p><p>（此处只讨论区间查询与区间修改，如果区间的会了，单点肯定也会吧 :D）</p><ul><li><p>对于乘法，只需要像这个样子修改update：</p><div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="dt">void</span> update(<span class="dt">int</span> L,<span class="dt">int</span> R,<span class="dt">int</span> val,<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb8-2" title="2">{</a><a class="sourceLine" id="cb8-3" title="3">    <span class="cf">if</span>(lef&gt;=L&amp;&amp;rig&lt;=R){</a><a class="sourceLine" id="cb8-4" title="4">        lazy[rt]*=val;</a><a class="sourceLine" id="cb8-5" title="5">        sum[rt]*=lazy[rt];</a><a class="sourceLine" id="cb8-6" title="6">        <span class="cf">return</span> ;</a><a class="sourceLine" id="cb8-7" title="7">    }</a><a class="sourceLine" id="cb8-8" title="8">    pushdown(rt);</a><a class="sourceLine" id="cb8-9" title="9">    <span class="dt">int</span> mid=(lef+rig)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb8-10" title="10">    <span class="cf">if</span>(L&lt;=mid) update(L,R,val,lson);</a><a class="sourceLine" id="cb8-11" title="11">    <span class="cf">if</span>(R&gt;mid) update(L,R,val,rson);</a><a class="sourceLine" id="cb8-12" title="12">}</a></code></pre></div><p>这样修改pushdown：</p><div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">void</span> pushdown(<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb9-2" title="2">{</a><a class="sourceLine" id="cb9-3" title="3">    <span class="cf">if</span>(lazy[rt]!=<span class="dv">1</span>){</a><a class="sourceLine" id="cb9-4" title="4">        lazy[rt&lt;&lt;<span class="dv">1</span>]*=lazy[rt];</a><a class="sourceLine" id="cb9-5" title="5">        lazy[rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]*=lazy[rt];</a><a class="sourceLine" id="cb9-6" title="6">        sum[rt&lt;&lt;<span class="dv">1</span>]=sum[rt&lt;&lt;<span class="dv">1</span>]*lazy[rt];</a><a class="sourceLine" id="cb9-7" title="7">        sum[rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=sum[rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]*lazy[rt];</a><a class="sourceLine" id="cb9-8" title="8">        lazy[rt]=<span class="dv">1</span>;</a><a class="sourceLine" id="cb9-9" title="9">    }</a><a class="sourceLine" id="cb9-10" title="10">}</a></code></pre></div><p>另外要记得初始化lazy中所有数为1</p><p>PS：思考一下，如果是乘法和加法同时进行，即区间修改操作中，既可以将区间上的数乘以一个数，也可以将区间上的数加上一个数，那要怎么维护sum和lazy呢？</p></li></ul></li></ul><h3 id="离散化">离散化</h3><p>所谓离散化指的是，在某些情况下，由于数据范围过大，直接保存数据的做法会导致MLE；但要解出题目其实并不需要保存实际的数据，只需要保存数据之间的相对大小即可。举个例子，现在要在一条长度为<span class="math inline">\(1e9\)</span>的线段上进行区间染色，颜色与颜色之间会相互覆盖，求最终线段上可以看到多少种颜色。显然，我们不可能开一个长度为<span class="math inline">\(4e9\)</span>的数组来存线段树节点，也不可能开一个长度为<span class="math inline">\(4e9\)</span>的数组来存懒惰标记。如何解决这一问题呢？注意到，我们现在其实并不关心被染色的线段具体有多长，而只关心线段之间的关系（相对大小，位置关系）。所以我们可以为每一个需要染色的区间的左右端点分配一个id，并通过id来建立线段树。所有的修改与查询都在这棵”id线段树“上进行。离散化的实际实现一般通过sort()和unique。</p><p>下面用一道例题来讲解：</p><p><a href="http://poj.org/problem?id=2528">Mayor's posters</a></p><p>题目大意是说，有一堵长为10000000，现在要在墙上贴<span class="math inline">\(n(1\leq n\leq 10000)\)</span>张海报（海报与海报之间会相互覆盖），问贴完所有海报后，能看到的海报有多少张？</p><p>与上面提到的染色问题思路一致，将每张海报离散化后，用离散化得到的id建立线段树，并通过query查询能看到的海报的数目。完成离散化后，通过lower_bound()查询左右端点对应的id。</p><p>参考代码：</p><div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb10-2" title="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb10-3" title="3"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb10-4" title="4"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb10-5" title="5"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb10-6" title="6"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb10-7" title="7"><span class="pp">#include </span><span class="im">&lt;list&gt;</span></a><a class="sourceLine" id="cb10-8" title="8"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb10-9" title="9"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb10-10" title="10"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb10-11" title="11"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb10-12" title="12"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb10-13" title="13"><span class="pp">#define mst</span>(a,b)<span class="pp"> </span>memset((a),(b),<span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb10-14" title="14"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb10-15" title="15"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb10-16" title="16"><span class="pp">#define lson </span>lef,mid,rt&lt;&lt;<span class="dv">1</span></a><a class="sourceLine" id="cb10-17" title="17"><span class="pp">#define rson </span>mid+<span class="dv">1</span>,rig,rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span></a><a class="sourceLine" id="cb10-18" title="18"><span class="at">const</span> <span class="dt">int</span> maxn=<span class="dv">10005</span>;</a><a class="sourceLine" id="cb10-19" title="19"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb10-20" title="20"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb10-21" title="21"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb10-22" title="22"><span class="dt">int</span> vis[<span class="dv">10000</span>+<span class="dv">5</span>];</a><a class="sourceLine" id="cb10-23" title="23"><span class="dt">int</span> lazy[maxn&lt;&lt;<span class="dv">3</span>];</a><a class="sourceLine" id="cb10-24" title="24"><span class="kw">struct</span> node{</a><a class="sourceLine" id="cb10-25" title="25">    <span class="dt">int</span> lef;</a><a class="sourceLine" id="cb10-26" title="26">    <span class="dt">int</span> rig;</a><a class="sourceLine" id="cb10-27" title="27">};</a><a class="sourceLine" id="cb10-28" title="28">node ps[<span class="dv">20000</span>+<span class="dv">5</span>];</a><a class="sourceLine" id="cb10-29" title="29"><span class="dt">void</span> pushdown(<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb10-30" title="30">{</a><a class="sourceLine" id="cb10-31" title="31">    <span class="cf">if</span>(lazy[rt]!=<span class="dv">0</span>){</a><a class="sourceLine" id="cb10-32" title="32">        lazy[rt&lt;&lt;<span class="dv">1</span>]=lazy[rt&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=lazy[rt];</a><a class="sourceLine" id="cb10-33" title="33">        lazy[rt]=<span class="dv">0</span>;</a><a class="sourceLine" id="cb10-34" title="34">    }</a><a class="sourceLine" id="cb10-35" title="35">    <span class="cf">return</span> ;</a><a class="sourceLine" id="cb10-36" title="36">}</a><a class="sourceLine" id="cb10-37" title="37"><span class="dt">int</span> ans=<span class="dv">0</span>;</a><a class="sourceLine" id="cb10-38" title="38"><span class="dt">void</span> update(<span class="dt">int</span> toL,<span class="dt">int</span> toR,<span class="dt">int</span> todo,<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb10-39" title="39">{</a><a class="sourceLine" id="cb10-40" title="40">    <span class="cf">if</span>(toL&lt;=lef&amp;&amp;toR&gt;=rig){</a><a class="sourceLine" id="cb10-41" title="41">        lazy[rt]=todo;</a><a class="sourceLine" id="cb10-42" title="42">        <span class="cf">return</span> ;</a><a class="sourceLine" id="cb10-43" title="43">    }</a><a class="sourceLine" id="cb10-44" title="44">    pushdown(rt);</a><a class="sourceLine" id="cb10-45" title="45">    <span class="dt">int</span> mid=lef+(rig-lef)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb10-46" title="46">    <span class="cf">if</span>(toL&lt;=mid)</a><a class="sourceLine" id="cb10-47" title="47">        update(toL,toR,todo,lson);</a><a class="sourceLine" id="cb10-48" title="48">    <span class="cf">if</span>(toR&gt;mid)</a><a class="sourceLine" id="cb10-49" title="49">        update(toL,toR,todo,rson);</a><a class="sourceLine" id="cb10-50" title="50">    <span class="cf">return</span> ;</a><a class="sourceLine" id="cb10-51" title="51">}</a><a class="sourceLine" id="cb10-52" title="52"><span class="dt">void</span> query(<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> rt)</a><a class="sourceLine" id="cb10-53" title="53">{</a><a class="sourceLine" id="cb10-54" title="54">    <span class="cf">if</span>(lazy[rt]){</a><a class="sourceLine" id="cb10-55" title="55">        <span class="cf">if</span>(!vis[lazy[rt]]){</a><a class="sourceLine" id="cb10-56" title="56">            ans++;</a><a class="sourceLine" id="cb10-57" title="57">            vis[lazy[rt]]=<span class="dv">1</span>;    </a><a class="sourceLine" id="cb10-58" title="58">        }</a><a class="sourceLine" id="cb10-59" title="59">        <span class="cf">return</span> ;</a><a class="sourceLine" id="cb10-60" title="60">    }</a><a class="sourceLine" id="cb10-61" title="61">    <span class="cf">if</span>(lef==rig)</a><a class="sourceLine" id="cb10-62" title="62">        <span class="cf">return</span> ;</a><a class="sourceLine" id="cb10-63" title="63">    pushdown(rt);</a><a class="sourceLine" id="cb10-64" title="64">    <span class="dt">int</span> mid=lef+(rig-lef)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb10-65" title="65">    <span class="cf">if</span>(lef&lt;=mid)</a><a class="sourceLine" id="cb10-66" title="66">        query(lson);</a><a class="sourceLine" id="cb10-67" title="67">    <span class="cf">if</span>(rig&gt;mid)</a><a class="sourceLine" id="cb10-68" title="68">        query(rson);</a><a class="sourceLine" id="cb10-69" title="69">}</a><a class="sourceLine" id="cb10-70" title="70"><span class="dt">int</span> lsh[maxn&lt;&lt;<span class="dv">2</span>];</a><a class="sourceLine" id="cb10-71" title="71"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb10-72" title="72">{</a><a class="sourceLine" id="cb10-73" title="73">    <span class="dt">int</span> t;</a><a class="sourceLine" id="cb10-74" title="74">    cin&gt;&gt;t;</a><a class="sourceLine" id="cb10-75" title="75">    <span class="cf">while</span>(t--){</a><a class="sourceLine" id="cb10-76" title="76">        <span class="dt">int</span> idx=<span class="dv">0</span>;</a><a class="sourceLine" id="cb10-77" title="77">        mst(lsh,<span class="dv">0</span>);</a><a class="sourceLine" id="cb10-78" title="78">        mst(lazy,<span class="dv">0</span>);mst(vis,<span class="dv">0</span>);</a><a class="sourceLine" id="cb10-79" title="79">        ans=<span class="dv">0</span>;</a><a class="sourceLine" id="cb10-80" title="80">        <span class="dt">int</span> n;cin&gt;&gt;n;</a><a class="sourceLine" id="cb10-81" title="81">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){</a><a class="sourceLine" id="cb10-82" title="82">            scanf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>,&amp;ps[i].lef,&amp;ps[i].rig);</a><a class="sourceLine" id="cb10-83" title="83">            lsh[idx++]=ps[i].lef;lsh[idx++]=ps[i].rig;</a><a class="sourceLine" id="cb10-84" title="84">        }</a><a class="sourceLine" id="cb10-85" title="85">        sort(lsh,lsh+idx);</a><a class="sourceLine" id="cb10-86" title="86">        <span class="dt">int</span> cnt=unique(lsh,lsh+idx)-lsh;</a><a class="sourceLine" id="cb10-87" title="87">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){</a><a class="sourceLine" id="cb10-88" title="88">            <span class="dt">int</span> L=lower_bound(lsh,lsh+cnt,ps[i].lef)-lsh+<span class="dv">1</span>;</a><a class="sourceLine" id="cb10-89" title="89">            <span class="dt">int</span> R=lower_bound(lsh,lsh+cnt,ps[i].rig)-lsh+<span class="dv">1</span>;</a><a class="sourceLine" id="cb10-90" title="90">            update(L,R,i+<span class="dv">1</span>,<span class="dv">1</span>,cnt+<span class="dv">1</span>,<span class="dv">1</span>);</a><a class="sourceLine" id="cb10-91" title="91">        }</a><a class="sourceLine" id="cb10-92" title="92">        query(<span class="dv">1</span>,cnt+<span class="dv">1</span>,<span class="dv">1</span>);</a><a class="sourceLine" id="cb10-93" title="93">        printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>,ans);</a><a class="sourceLine" id="cb10-94" title="94">    }</a><a class="sourceLine" id="cb10-95" title="95">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb10-96" title="96">}</a></code></pre></div><h3 id="拓展">拓展</h3><p>拓展内容包括：</p><ul><li><p>区间除、维护区间平方和、维护区间立方和、区间位运算...</p></li><li>扫描线</li><li>权值线段树</li><li>主席树</li><li><p>etc...</p></li></ul><h2 id="树状数组">树状数组</h2><h3 id="引入-1">引入</h3><p>所谓树状数组，就是用数组来模拟树形结构，常用于解决一些区间问题（区间加、区间求和等）。相较于线段树，其优点在于常数更小，且代码更短。缺点在于功能比较有限，对于一些复杂的区间问题很难解决，甚至是无法解决。可以说，能用树状数组解决的问题都能用线段树解决，但能用线段树解决的问题不一定能用树状数组解决。</p><h3 id="辅助数组c与lowbit">辅助数组c与lowbit</h3><p>首先，定义一个序列<span class="math inline">\(a_n\)</span>，其长度为<span class="math inline">\(n(1\leq n\leq1e6)\)</span>，可进行<span class="math inline">\(m(1\leq m \leq 1e3)\)</span>次操作，每次操作要么是对一个数加上一个数值（单点修改），要么是查询一段区间内的总和（区间查询）。</p><p>这一问题当然可以用上面所说的线段树来解决，但现在我们引入树状数组。</p><p>首先定义函数<span class="math inline">\(lowbit(x)\)</span>，有 <span class="math display">\[lowbit(x)=x\&amp;(-x)\]</span></p><p><span class="math inline">\(lowbit(x)\)</span>的具体含义在于，求出<span class="math display">\[x\]</span>最低位1所对应的值。比方说，<span class="math display">\[lowbit(10100_2)=100_2=4_{10}\]</span>，<span class="math display">\[lowbit(10001111_2)=1_2=1_{10}\]</span>，<span class="math display">\[lowbit(100010_2)=10_2=2_{10}\]</span></p><p>再定义一个辅助数组<span class="math inline">\(c_i\)</span>，有 <span class="math display">\[$c_i=a_{i}+a_{i-1}+\dots+a_{i-lowbit(i)+1}\]</span>$</p><p>也就是说，c[i]表示的是, 从a[i]开始，一直到 a[i-lowbit(i)+1] 这一长度为lowbit(i) 的连续区间的总和。如下图</p><p><img src="https://pic.downk.cc/item/5e3adb222fb38b8c3cced2a6.png"></p><p>构建出来的树状数组大致长下面这个样子</p><p><img src="https://pic.downk.cc/item/5e3adb452fb38b8c3cced59d.jpg"></p><h3 id="修改与查询">修改与查询</h3><p>此处只考虑单点修改和区间查询。</p><ul><li><p>单点修改：当我们要修改<span class="math display">\[a_j\]</span>的时候，因为有<span class="math display">\[c_i=a_i+a_{i-1}+\dots+a_{i-lowbit(i)+1}\]</span>，所以修改一个数可能会导致多个<span class="math display">\[c_i\]</span>的改变。所以我们这么编写单点修改的代码：</p><div class="sourceCode" id="cb11"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="dt">void</span> add(<span class="dt">int</span> i,<span class="dt">int</span> val)</a><a class="sourceLine" id="cb11-2" title="2">{</a><a class="sourceLine" id="cb11-3" title="3">    <span class="cf">while</span>(i&lt;=n){</a><a class="sourceLine" id="cb11-4" title="4">        c[i]+=val;</a><a class="sourceLine" id="cb11-5" title="5">        i+=lowbit(i);</a><a class="sourceLine" id="cb11-6" title="6">    }</a><a class="sourceLine" id="cb11-7" title="7">}</a></code></pre></div></li><li><p>对于区间查询，<span class="math inline">\(c_i\)</span>的定义让我们想到，是否可以通过求前缀和的方法求区间和。因此，查询的代码可以这样编写：</p><div class="sourceCode" id="cb12"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="dt">int</span> query(<span class="dt">int</span> i)</a><a class="sourceLine" id="cb12-2" title="2">{</a><a class="sourceLine" id="cb12-3" title="3">    <span class="dt">int</span> ans=<span class="dv">0</span>;</a><a class="sourceLine" id="cb12-4" title="4">    <span class="cf">while</span>(i&gt;<span class="dv">0</span>){</a><a class="sourceLine" id="cb12-5" title="5">        ans+=c[i];</a><a class="sourceLine" id="cb12-6" title="6">        i-=lowbit(i);</a><a class="sourceLine" id="cb12-7" title="7">    }</a><a class="sourceLine" id="cb12-8" title="8">}</a></code></pre></div></li></ul><p>通过观察修改、查询的代码，以及树状数组的结构，我们可以看出，树状数组其实巧用二进制来对整个序列进行分段。以一个长度为7的序列为例，有 <span class="math display">\[\begin{aligned}lowbit(1)&amp;=1,c_1=a_1;\\lowbit(2)&amp;=2,c_2=a_2+a_1;\\lowbit(3)&amp;=1,c_2=a_3;\\lowbit(4)&amp;=4,c_4=a_4+a_3+a_2+a_1;\\lowbit(5)&amp;=1,c_5=a_5;\\lowbit(6)&amp;=2,c_6=a_6+a_5;\\lowbit(7)&amp;=1,c_7=a_7;\end{aligned}\]</span> 我们把这些数据套到query()代码中，可以发现，加上的<span class="math inline">\(c[i]\)</span>分别是<span class="math inline">\(c[7],c[6],c[4]\)</span>，也就是<span class="math inline">\(a[7],a[6]+a[5],a[4]+a[3]+a[2]+a[1]\)</span>这三段。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5e3adbdf2fb38b8c3ccee2f7.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/categories/ACM/"/>
    
    <category term="数据结构" scheme="https://xtayex.gitee.io/categories/ACM/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树" scheme="https://xtayex.gitee.io/categories/ACM/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/tags/ACM/"/>
    
    <category term="数据结构" scheme="https://xtayex.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树" scheme="https://xtayex.gitee.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="树状数组" scheme="https://xtayex.gitee.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019算法学习总结</title>
    <link href="https://xtayex.gitee.io/2019/11/25/2018%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://xtayex.gitee.io/2019/11/25/2018%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-25T10:30:00.000Z</published>
    <updated>2022-10-04T12:07:14.947Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a2779b4771de6898045c7578e02d2a4235b1f2d4acea5c866d417f689715a0a6">bc222d1b1305729f70b2ed8cb52da7f36b9c72240c71ae81b9f8ec63be1c5e838182444e1b19d7385d4d05442635c90a41d833ad31621c75ae753e6c38886085776bb69d8aba51109a40b8fda30c079edb943f57bf3009d08dff59a6929a995afa5abb4e7e6e59c69dc10424240805ac1c10aedf5a258ae4576270c947a63a3d264e86776097b4337a82e93cdeda758e0e42a889227bafc5b3c022c5deaf2f6b332e0aa54264cc1425621238077832c0eebb5a134c416be807345b2cbaba1c83b1f3ca374fa5a8e4737cf54ad7aeb72a0fc8b8314e114fcdd78d070c0021fe566797fe3d3d68de6b835ce02e85ecfc23dc6e998f2d8bebde4dbdccc281d1264490069104f8fc7023afb949e628be8f231c03c44a33d2d96cd37ae84866f5d26c0fe8ec061d8f5fd55e493be114c086ec5b59f9ccfb234f371a9114c542d88f1c80db946fbe3cfa119a2fdc7c54e769676788c41ba21e915fb1b8024e6bab125b690822695bf75e08c98f47f133206e8e197dc6f00b1c72ae16d4cdd505ae1557e761d97b6478f2a6f32197f1e3a072b8a8910497588c0de282b1b7f9f681272794f54506b094368b58d55a61db03f7f8f7624e628dd5bb3fa7489341b8f42c478875c99709024d305dc35b175170a980a0d758cd9e615e4ce2a7364a28ba4029b258378429c524d1944843ec5cb78e8b1268e3aea2a8e6acba4cde761c5d4af56113091bc87eb7995a16dbb6f72ae0874e26c27eb2193ac65aad01be42a5df593fe17a5d5525001416f001865a1cedde7059e3f51933ccbb6f656e66ee03f6f9137fabf501f25af698dc3e5c3d4a6f3f553223ed7aef3b079b313fcc92304af0ead4cb7ec4607b9b750908f5c40d4617dc88eb2102d76328dc24977f445f482e55c74bca809cdf5403cf07cac1a518a864f8b58f2fd8255ce3bcb9c4cbcfa913b0ce0f7a61f65d70ef9eb1109b722cfed4b8b87cb0a2d10358bc2eedb39466f9114c14d25344566c66adde76bb75c7329ff70fc1e4cf45f16e376f6b34134ad21af1f476a098c58cdc11b772ce73fa7f1b12314e4ddd80db5f04d11a5a2987b90fee9c2bbee198c8fd915cd6a95d6e77898cc2c76389ae3c841099a0994fa6c30729b642fe6161f6ff03c9f968b55b6bb32e6c18d9a2346c9cc879da21ec34969e3783d94279ac8031d723e167f53c84f692d4c9bfc9cf666204782b33b239057596dd11980b7baeac29c8b8bc732794afb60c38175b5dbda03d593d336cb98f0f754102bd05426728b77d83773ca5236749e3fc055554754dbe88d8cd0bb6619b1153f7b8fad3b93870797b20091a03bb41eee1261233cde30f78f2ea501a722224831a1df364154f3721580e6bd55fe0592521cc32e3dca8404a32698ef002604ea015275712677e263b6112525ed8133281de0d83629141a127372cd96890b515f34bc37b29031ef1f20d967d6b7365f123101f10ed0ca448ce403384b49c74986d5706cc3fab8f2376fcee025dbef9b051527fbd5bb096a95105afe68b612f703d415e0d19fa1df4b94349dc97aa44cc009f8946d7b1721b54c8e8b7ee8eee3b52b5c59a39cd287e0737ad2870e5162e2292ec0cb92e9dd41c9b393dfe594788f867433979207db20d2b574d3178a0b93afef9267ba71a1651976d64a2dba187fc0ae0c7880169e2eea2f27fbd17227090b87456458fe5cc6d350db3bed0600596fbefe01d20af2232a1590f058142b27abfce26d1f06b11931725ca424aae53245ad1a0287ea2d570140e0f34425d80b3b616888485e93e22c42fc65310431eb4d434247166006887579a614ec9e8cbf55d999c48f61533ecaeab73a433d490e390de155b680807cd7d88346033f477315e8ea647c8b0177a578e78ad050397ca82000491241a0574ee77c5484f26bc35f022ebd98ffcb6f71666fc2139a2f267c2498d2dcbb1c9a9b8dcbfc3c1061fd1658f94dbbf4c45fa86d531f20f6eba4bd32d0c36b1f05958e388a20edc2283bc336da5de8f56465f2fd64d5c1ae4477213868f53615a501a9d87843c450a23b7e863e360c555dd42fb3ced6e1c16fc107a16daf621656981eaaab3f54cce224bb7ad490baf2292a574b0033dde1f72896027312172324c2e32081e492ea8e260c0c79de3e9cec0ed321061f74eb997e32ccd2640d6d5adb039dbf4af33a6efef20462cf2cea2226f1a8898255c33585ce46b946c6fca465ea60e6cdd2cecc23fa185834ce4e4e8de944a3d4d21327c4717ac98e086243627c397f1f0190b90803efc48565a203be7cb4b694461375b62f14277c3400711a24700cd22e1b3afdd21e1f63bef8e9c478cbc92c61aa70ba91435902e69370aee9004e137ef0a571204ce7b68f4806e49d1442b57116e8103a96d0d9530c8d4856129d2581237b1f1ac8d0b477f0a951c7963db84dc73b1082d2a9aa7d4f410c0374358d11b36a8d666b5f4a92eea5d0ba512efdc3b01c24dc84356625415929a87cd90a4eea88c2acf7bc881290278afd709272d8fbcde0027b131e65035fdaa6d98c3e8c1b1d3c84124e8f226575aefd86f9edbcdb859b81f953d35d5d152ece43e15ad4f3971450d9dd4e1271f49094bb9bd69bab2cf390cd5532f6bc7d0310d1a5db2a7cf27d33a853625cddd5ca739a8b3d44103b3b57b4ca8de5677f987cc62793e079f1c96a599ee54f9a80029561a1f18117e999bb1901d1712e0365217cb0f408eb20e001e8ab2cd293de9101fa4dabf6b2dbbc3074ca6d6fe515451d625263e7dddbc0ead14792b48e2c8a95fcb9e9adbbd5508a8cc6d2562cd4e66c2666859bcd20f60027072979a79dc2c25f4cf5775c304494c0566c08818f966d531f28be1307f0751013ba70d79ee7dfdfb19dc282936dbc9d81f5ec5ef735bcc0dbb5093603af3293385f3496ab3e7a9cb7000781049ffade79f64c0e03716278ad3db37b0b511683acb7566d04a46f4802c4bc578a3d96791b100f9a53f490d424d06fd8d4a024f992d1f0d357204d86b3e4bd4810bf85b0454494be17da528b22a43a5835cad5f1cde0a5bb58ecfe6fcd289f56487aa343efcc97a7c884bcefd5a231ce58e1dfd7cdcca1ef6cb2e3e97a8ce5bbede7a050b8b6ffb60fc4be411d25191663deba446e3df30d113badd4e9139350bde897321eadf2a11d743b560abaf12bbba002fce72a3fc0b361242edcd72da0e4f62f941b7b2f778d9d86a9dbfd3a371918795e2686f49fc1c3a43b6617172ded220a6f56465e3fcfc0cddeeaca33e25dde700eb4708215688caf23180a7213234a6ce413179798720690a0387ce27f9bff15bf656158cdd102505c4331ba423586cbc73a5128c333be6f63c0aa78b8ed0c07a2a86f4d398b68bba67445d7c1e5eb7d55a2f96fed8969398266b95f6e1f656ba14887649f1d256e8ed04c562463507b5704c2430c828b02777625caeda04ee3a655ff13adcc2ab82bde0855ad1d5cebee865122d06975fd4b6875ca14d7ea138f2e995a324f8d549dce9911c7b68b3c4f34980c8e00f19075a98f17dbe66d87f1d9219e63a0364e54d53f938f4879b846e52aaaaa9f0b3be701116956989b5af61cdcee9c7492cb89a829d63617974abbec352e41034a5a9109a5f5080c04265af9bd253e694f15024342355f98eee9133a5b650e32aa7df5c868d41d7f143cf8e77201ecdd836879f004543b5f4c56e7c0c7403cf3b86146b1664df172cd8cfb93daef46038d463cadb7c9466f6a41a75d43ae43e8f08bea7de4f25021d0e5f155875f4a77b9d1ecd7a860644f65eb5acad673c6711f000c38614456fce48e851797a7c89af2a0a403c53c401fc4d61d6e3ad5cff310b6b70c1e8cb8fc19bef7aee786d4380251dd3b0fef1592eb38b9eaa32ac64da28c91caa647e48c5d0cdbdab293759b29aa6bc2e7a8e2e84b90736144f0612bceb3b1d9bbc56ddfc781c8ca80231c5151a3a14f4c706c2e7c624fa752bcb2cd7736afaf62c85c9f80080ada4d390eb20d6d7bdd560f2f98fb4c365b9cd20df301c6b739e1c23c250c66f05195e077b67b93458ac0bfd6e4855ea970c9d31955bba13e262c8a0e480eadeffab9491ed455afd70f59cbd32753219a6293e8019f6eea7e71abba6804d709d0933eb11f8e57f7a3812473082910e84278ee40a5c32d050c82b13906f31437bad7007139c659d1f26283e89412ff66b5e353247af5ff701979bfe2a45b1a15c734c3eed8cb8622a5a87aa8aaf925e9d0a0575dc7c519bd998580c4e60b5984cd3ddb17654978a2c9ab50c0d738015fa7cce617452a169ee07d1e02af1f834f78658ce014b9e412798d621ca1621af729ebbb59838f09e4835a1c15121dde5a1e65484196e5f0ad5ebf816582478a43eabdb31728edbb5f1328c0f1d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/categories/ACM/"/>
    
    <category term="总结" scheme="https://xtayex.gitee.io/categories/ACM/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/tags/ACM/"/>
    
    <category term="总结" scheme="https://xtayex.gitee.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>CCPC2019哈尔滨站总结</title>
    <link href="https://xtayex.gitee.io/2019/10/15/CCPC2019%E5%93%88%E5%B0%94%E6%BB%A8%E7%AB%99%E6%80%BB%E7%BB%93/"/>
    <id>https://xtayex.gitee.io/2019/10/15/CCPC2019%E5%93%88%E5%B0%94%E6%BB%A8%E7%AB%99%E6%80%BB%E7%BB%93/</id>
    <published>2019-10-15T14:54:00.000Z</published>
    <updated>2022-09-27T13:46:54.835Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ae01.alicdn.com/kf/Hc44a6b020fd5413ca3b54eea908034afn.jpg"></p><span id="more"></span><h4 id="前言">前言</h4><p>萌新的第一场区域赛，抱队友大腿拿了个铜，不至于打铁qwq。队友实在太强辣！</p><h4 id="热身赛">热身赛</h4><p>热身赛四道题，A，B都是傻逼题；C，D是牛客多校原题，然而我们并没有敲出来......C题原本的想法是枚举矩阵起点，然后单调栈维护纵向横向两个方向最远可以拓展的距离；后来听对面女队的小姐姐讨论，觉得可以尺取法搞搞，结果热身赛结束了都没弄出来😭。后悔没有好好补多校的题😭</p><p>热身赛草草结束，去东林恰了个晚饭，<del>东林的饭堂还挺好吃的</del></p><h4 id="正赛">正赛</h4><p>正赛一共过了下面四题</p><table><thead><tr class="header"><th>Problem</th><th>Solution</th></tr></thead><tbody><tr class="odd"><td>F - Fixing Banners</td><td>直接6!暴力枚举</td></tr><tr class="even"><td>I - Interesting Permutation</td><td>牛逼队友找规律，我一脸懵逼......</td></tr><tr class="odd"><td>J - Justifying the Conjecture</td><td>&gt;=5的情况都有解，奇数分解成3 + x，偶数分解成2 + x</td></tr><tr class="even"><td>K - Keeping Rabbits</td><td>无论经过多少天，概率分布都不会变化</td></tr></tbody></table><p>开场看题时沿用了我们队一直以来的策略，我从后面开始看题，zh学长从前面开始看题，pzc中间随便看。根据赛前训练的经验，签到题一般是倒数第二或第三题，再加上这次的倒数第一题是一道题面贼长的大模拟，于是看题时我没有从倒数第一题开始，而是直接选了最签到的 J，发现果然是水题，于是把题意喂给主代码手，10min内水过。</p><p>往后又看到了K，于是把题意告诉学长，然后自己接着看题。看题过程中发现了F和I，觉得有搞头，然后去搞了搞F，喂给学长和代码手，过了。紧接着是学长敲K，也是一发过。开场签到感觉很顺利，<del>然后就开始自闭了</del></p><p>签完前三题后，开始搞I 。题意是说给定一个<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>的排列<span class="math inline">\(a_1,a_2,a_3,...,a_n\)</span>，对于两个序列<span class="math display">\[f_i=max\{a_1,a_2,a_3,...,a_i\}\]</span>，<span class="math display">\[g_i=min\{a_1,a_2,a_3,...,a_i\}\]</span>，定义<span class="math inline">\(h_i=f_i-g_i\)</span>。现在给出一个<span class="math inline">\(h\)</span>序列，问有多少个<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>的排列，可以生成这样的一个<span class="math inline">\(h\)</span>序列。</p><p>第一反应是dp，但队里的dp选手想不出要怎么d OTZ。过了一会后牛逼队友发现这东西可以找规律解决，结果打了个表对拍一下，结果发现规律好像推错了......于是继续自闭，直到差不多一点的时候，队友才把正确的规律搞了出来，然后搞搞搞，终于过了😭。对于这题我个人感觉挺惭愧的，可以说除了读题对拍意外没有其他贡献，<del>后期还挂机了</del>。I题过了之后，排名上升到了121，终于苟到铜牌了OTZ</p><p>这时候还剩下一个半小时，感觉如果不把E过掉，很可能会打铁（不过事实证明还是能有铜的）。于是疯狂搞E，但最终还是很遗憾没有弄出来。赛后跟我校的另一支队了解了一下，得知他们将快读换成了A题题面上的快读就过了......过了......队友听到这都要哭了，<del>我也要哭了qwq</del></p><p>第一场区域赛，没有打铁，我个人已经非常满意了。大致总结一下自身的问题，一就是精神不够集中，容易进入挂机状态。无论是平时训练还是现场赛都是如此。二就是时间的利用效率还不够高，比如说这次现场赛，后期卡E题的时候，我对这题几乎是0贡献，那这时为什么我不去搞搞那两道模拟题，想个大概的框架，然后把题意和自己的想法喂给擅长模拟题的队友呢？或许这样我们能A五题？</p><p>就这样吧，这周银川站加油💪</p><h4 id="一些题外话">一些题外话</h4><p><img src="https://ae01.alicdn.com/kf/H7d0f28ea3f4c49c19ad981ce10d5ac0du.jpg"></p><center>摄于深圳—哈尔滨的飞机上</center><p><img src="https://ae01.alicdn.com/kf/Hb1000c4c83664acb8eda52e37b4c3bdce.png"></p><center>东林里面居然还有个自然博物馆，我酸了qwq</center><p><img src="https://ae01.alicdn.com/kf/H3d63cdbd1f44496ca159ea95fcf3795cR.jpg"></p><center>哈尔滨特色锅包肉，然而并不喜欢甜食。。。</center><p><img src="https://ae01.alicdn.com/kf/Hc44a6b020fd5413ca3b54eea908034afn.jpg"></p><center>摄于哈尔滨太阳岛</center>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/Hc44a6b020fd5413ca3b54eea908034afn.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/categories/ACM/"/>
    
    <category term="赛后总结" scheme="https://xtayex.gitee.io/categories/ACM/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/tags/ACM/"/>
    
    <category term="CCPC" scheme="https://xtayex.gitee.io/tags/CCPC/"/>
    
    <category term="赛后总结" scheme="https://xtayex.gitee.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>最大流，最大流最小割与最大权闭合子图</title>
    <link href="https://xtayex.gitee.io/2019/10/10/%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%8C%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
    <id>https://xtayex.gitee.io/2019/10/10/%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%8C%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/</id>
    <published>2019-10-10T11:46:00.000Z</published>
    <updated>2022-09-27T13:46:55.111Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H5f34d005235d4ae08a65080af36eb1b35.jpg"> <span id="more"></span></p><h3 id="前言">前言</h3><p>很久之前学过最大流，但当时网络流的学习便止步于此。国庆时做了几套去年ICPC Regional的题目，有好几道网络流相关的题目，遂决定复习一下最大流，同时学点新东西</p><h3 id="最大流">最大流</h3><p>解决最大流问题主要有FF，EK，Dinic，ISAP这四种算法。FF和EK在时间复杂度上较劣，不适合用来解题，故大多数情况使用的都是Dinic和ISAP。而这两种算法相比较，虽然ISAP会比Dinic更快一点，但由于网络流相关的题目重点往往不在算法实现，而在于如何对问题建模。再加上Dinic的思路比ISAP更简明，实现也很简单，故实际解题时，Dinic使用得更多一些。</p><h4 id="dinic">Dinic</h4><h5 id="该算法的大致步骤如下">该算法的大致步骤如下：</h5><ol type="1"><li>连边，建立网络</li><li>BFS建立分层图</li><li>判断分层后汇点所处层次是否为-1。若是，说明此时汇点已不可达，直接输出答案；否则，进行下一步</li><li>一边DFS完成所有增广。对于网络中的每一条边，都加上当前的最小残量，同时对于每一条边的反向边，都减去当前的最小残量，并将答案加上该最小残量。</li><li>返回步骤2</li></ol><p>该算法的最坏时间复杂度为：<span class="math inline">\(O(n^2 m)\)</span>，但大多数情况下都是挺快的</p><h5 id="当前弧优化">当前弧优化</h5><p>每一次在做dfs时，对于一个点，有可能有一些边在之前已经计算过了，那我们在遍历这个点的边的时候，就没必要再计算那些已经计算过的边。因此，我们可以用一个cur[]数组记录某个点已经计算到了那条边。</p><h5 id="代码">代码</h5><div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb1-6" title="6"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb1-7" title="7"><span class="pp">#define mst</span>(a,b)<span class="pp"> </span>memset((a),(b),<span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb1-8" title="8"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb1-9" title="9"><span class="at">const</span> <span class="dt">int</span> maxn=<span class="fl">1e5</span>+<span class="dv">5</span>;</a><a class="sourceLine" id="cb1-10" title="10"><span class="dt">int</span> head[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb1-11" title="11"><span class="dt">int</span> dep[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb1-12" title="12"><span class="dt">int</span> cur[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb1-13" title="13"><span class="dt">int</span> cnt;</a><a class="sourceLine" id="cb1-14" title="14"><span class="kw">struct</span> edge{</a><a class="sourceLine" id="cb1-15" title="15">    <span class="dt">int</span> to;<span class="dt">int</span> next;</a><a class="sourceLine" id="cb1-16" title="16">    <span class="dt">int</span> wei;</a><a class="sourceLine" id="cb1-17" title="17">};</a><a class="sourceLine" id="cb1-18" title="18">edge es[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb1-19" title="19"><span class="kw">inline</span> <span class="dt">void</span> init()</a><a class="sourceLine" id="cb1-20" title="20">{</a><a class="sourceLine" id="cb1-21" title="21">    cnt=<span class="dv">0</span>;mst(head,-<span class="dv">1</span>);</a><a class="sourceLine" id="cb1-22" title="22">    mst(dep,-<span class="dv">1</span>);mst(cur,-<span class="dv">1</span>);</a><a class="sourceLine" id="cb1-23" title="23">}</a><a class="sourceLine" id="cb1-24" title="24"><span class="dt">void</span> add(<span class="dt">int</span> u,<span class="dt">int</span> v,<span class="dt">int</span> wei)</a><a class="sourceLine" id="cb1-25" title="25">{</a><a class="sourceLine" id="cb1-26" title="26">    es[cnt].to=v;</a><a class="sourceLine" id="cb1-27" title="27">    es[cnt].wei=wei;</a><a class="sourceLine" id="cb1-28" title="28">    es[cnt].next=head[u];</a><a class="sourceLine" id="cb1-29" title="29">    head[u]=cnt++;</a><a class="sourceLine" id="cb1-30" title="30">}</a><a class="sourceLine" id="cb1-31" title="31"><span class="dt">void</span> add_edge(<span class="dt">int</span> u,<span class="dt">int</span> v,<span class="dt">int</span> wei)</a><a class="sourceLine" id="cb1-32" title="32">{</a><a class="sourceLine" id="cb1-33" title="33">    add(u,v,wei);</a><a class="sourceLine" id="cb1-34" title="34">    add(v,u,<span class="dv">0</span>);</a><a class="sourceLine" id="cb1-35" title="35">}</a><a class="sourceLine" id="cb1-36" title="36"><span class="dt">bool</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> t)</a><a class="sourceLine" id="cb1-37" title="37">{</a><a class="sourceLine" id="cb1-38" title="38">    queue&lt;<span class="dt">int</span>&gt; que;</a><a class="sourceLine" id="cb1-39" title="39">    mst(dep,-<span class="dv">1</span>);dep[s]=<span class="dv">0</span>;</a><a class="sourceLine" id="cb1-40" title="40">    que.push(s);</a><a class="sourceLine" id="cb1-41" title="41">    <span class="cf">while</span>(!que.empty()){</a><a class="sourceLine" id="cb1-42" title="42">        <span class="dt">int</span> u=que.front();</a><a class="sourceLine" id="cb1-43" title="43">        que.pop();</a><a class="sourceLine" id="cb1-44" title="44">        <span class="cf">for</span>(<span class="dt">int</span> i=head[u];i!=-<span class="dv">1</span>;i=es[i].next){</a><a class="sourceLine" id="cb1-45" title="45">            <span class="cf">if</span>(es[i].wei&gt;<span class="dv">0</span>&amp;&amp;dep[es[i].to]==-<span class="dv">1</span>){</a><a class="sourceLine" id="cb1-46" title="46">                dep[es[i].to]=dep[u]+<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-47" title="47">                que.push(es[i].to);</a><a class="sourceLine" id="cb1-48" title="48">            }</a><a class="sourceLine" id="cb1-49" title="49">        }</a><a class="sourceLine" id="cb1-50" title="50">    }</a><a class="sourceLine" id="cb1-51" title="51">    <span class="cf">return</span> dep[t]!=-<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-52" title="52">}</a><a class="sourceLine" id="cb1-53" title="53"><span class="dt">int</span> dfs(<span class="dt">int</span> s,<span class="dt">int</span> t,<span class="dt">int</span> mini)</a><a class="sourceLine" id="cb1-54" title="54">{</a><a class="sourceLine" id="cb1-55" title="55">    <span class="cf">if</span>(s==t) <span class="cf">return</span> mini;</a><a class="sourceLine" id="cb1-56" title="56">    <span class="cf">for</span>(<span class="dt">int</span> &amp;i=cur[s];i!=-<span class="dv">1</span>;i=es[i].next){</a><a class="sourceLine" id="cb1-57" title="57">        <span class="cf">if</span>(es[i].wei&gt;<span class="dv">0</span>&amp;&amp;dep[es[i].to]==dep[s]+<span class="dv">1</span>){</a><a class="sourceLine" id="cb1-58" title="58">            <span class="dt">int</span> d=dfs(es[i].to,t,min(es[i].wei,mini));</a><a class="sourceLine" id="cb1-59" title="59">            <span class="cf">if</span>(d&gt;<span class="dv">0</span>){</a><a class="sourceLine" id="cb1-60" title="60">                es[i].wei-=d;</a><a class="sourceLine" id="cb1-61" title="61">                es[i^<span class="dv">1</span>].wei+=d;</a><a class="sourceLine" id="cb1-62" title="62">                <span class="cf">return</span> d;</a><a class="sourceLine" id="cb1-63" title="63">            }</a><a class="sourceLine" id="cb1-64" title="64">        }</a><a class="sourceLine" id="cb1-65" title="65">    }</a><a class="sourceLine" id="cb1-66" title="66">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-67" title="67">}</a><a class="sourceLine" id="cb1-68" title="68"><span class="dt">int</span> Dinic(<span class="dt">int</span> s,<span class="dt">int</span> t,<span class="dt">int</span> n)</a><a class="sourceLine" id="cb1-69" title="69">{</a><a class="sourceLine" id="cb1-70" title="70">    <span class="dt">int</span> ans=<span class="dv">0</span>;<span class="dt">int</span> tmp;</a><a class="sourceLine" id="cb1-71" title="71">    <span class="cf">while</span>(bfs(s,t)){</a><a class="sourceLine" id="cb1-72" title="72">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;=n;i++) cur[i]=head[i];</a><a class="sourceLine" id="cb1-73" title="73">        <span class="cf">while</span>((tmp=dfs(s,t,INF))&gt;<span class="dv">0</span>){</a><a class="sourceLine" id="cb1-74" title="74">            ans+=tmp;</a><a class="sourceLine" id="cb1-75" title="75">        }</a><a class="sourceLine" id="cb1-76" title="76">    }</a><a class="sourceLine" id="cb1-77" title="77">    <span class="cf">return</span> ans;</a><a class="sourceLine" id="cb1-78" title="78">}</a><a class="sourceLine" id="cb1-79" title="79"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb1-80" title="80">{</a><a class="sourceLine" id="cb1-81" title="81">    <span class="dt">int</span> n,m,s,t;</a><a class="sourceLine" id="cb1-82" title="82">    scanf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</a><a class="sourceLine" id="cb1-83" title="83">    init();</a><a class="sourceLine" id="cb1-84" title="84">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++){</a><a class="sourceLine" id="cb1-85" title="85">        <span class="dt">int</span> u,v,w;</a><a class="sourceLine" id="cb1-86" title="86">        scanf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>,&amp;u,&amp;v,&amp;w);</a><a class="sourceLine" id="cb1-87" title="87">        add_edge(u,v,w);</a><a class="sourceLine" id="cb1-88" title="88">    }</a><a class="sourceLine" id="cb1-89" title="89">    <span class="dt">int</span> ans=Dinic(s,t,n);</a><a class="sourceLine" id="cb1-90" title="90">    printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>,ans);</a><a class="sourceLine" id="cb1-91" title="91">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-92" title="92">}</a></code></pre></div><h5 id="验板子">验板子</h5><p><a href="https://www.luogu.org/problem/P3376">P3376 【模板】网络最大流</a></p><h3 id="最大流最小割">最大流最小割</h3><h4 id="什么是割什么是最小割">什么是割?什么是最小割？</h4><p>所谓的割，指的是对于一个网络上的一个边集，如果从网络上将该边集中的边都删去后，不存在一条从源点到汇点的路，则该边集称为割。最小割指的就是边权和最小的割</p><h4 id="一个结论">一个结论</h4><center><strong>最小割 == 最大流</strong></center><p>我是这么理解这个结论的：因为割的意思是指拿掉割里面的边以后，就不能找到一条从源点到汇点的路了，也就是说割将网络的两个部分连接起来，拿掉之后网络就分成了两个部分。那我们是否可以将割集中的边合并成一条边呢？这样去理解的话就可以很容易得出这样一个结论：在满足最大流的情况下，这一条边的流量就是等于最大流。而又因为流量不能超过容量，故在满足最大流的情况下，任意一个割的容量和都是大于等于最大流的。在这个基础上，我们不断地去找容量和更小的割，最终一定能够找到一个割，他们的容量和等于最大流。为什么一定能找到呢？因为最大流意味着满流，意味着我们已经无法继续增广了。</p><h4 id="来道例题">来道例题</h4><p><a href="https://www.luogu.org/problem/P2774">P2774 方格取数</a></p><p>第一反应是贪心，隔一个数取一个什么的。但很容易就能举出反例。正确的做法是按照<span class="math inline">\((i+j)\)</span>（<span class="math inline">\(i,j\)</span>分别是行数和列数）的奇偶来连边构建一个二分图。对于一个方格，如果其所在行加上所在列<span class="math display">\[ row_{cur} + col_{cur}\]</span>为奇数，则将其与超级源点连一条容量为1的边；如果为偶数，则将其与超级汇点连一条容量为1的边。最后，对于左侧的奇数点，将它们与所有<strong>不符合限制的不能取的</strong>偶数点，即与它们相邻的那些点各连一条容量为INF的边。最后算一遍最小割，将所有方格的数的总和减去最小割即为答案。</p><p>代码如下：</p><div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb2-3" title="3"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb2-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb2-5" title="5"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb2-6" title="6"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb2-7" title="7"><span class="pp">#define mst</span>(a,b)<span class="pp"> </span>memset((a),(b),<span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb2-8" title="8"><span class="pp">#define debug </span>puts(<span class="st">"debug"</span>)</a><a class="sourceLine" id="cb2-9" title="9"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb2-10" title="10"><span class="at">const</span> <span class="dt">int</span> maxn=<span class="fl">1e5</span>+<span class="dv">5</span>;</a><a class="sourceLine" id="cb2-11" title="11"><span class="dt">int</span> head[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb2-12" title="12"><span class="dt">int</span> dep[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb2-13" title="13"><span class="dt">int</span> cur[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb2-14" title="14"><span class="dt">int</span> cnt;</a><a class="sourceLine" id="cb2-15" title="15"><span class="kw">struct</span> edge{</a><a class="sourceLine" id="cb2-16" title="16">    <span class="dt">int</span> to;<span class="dt">int</span> next;</a><a class="sourceLine" id="cb2-17" title="17">    <span class="dt">int</span> wei;</a><a class="sourceLine" id="cb2-18" title="18">};</a><a class="sourceLine" id="cb2-19" title="19">edge es[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb2-20" title="20"><span class="kw">inline</span> <span class="dt">void</span> init()</a><a class="sourceLine" id="cb2-21" title="21">{</a><a class="sourceLine" id="cb2-22" title="22">    cnt=<span class="dv">0</span>;mst(head,-<span class="dv">1</span>);</a><a class="sourceLine" id="cb2-23" title="23">    mst(dep,-<span class="dv">1</span>);mst(cur,<span class="dv">0</span>);</a><a class="sourceLine" id="cb2-24" title="24">}</a><a class="sourceLine" id="cb2-25" title="25"><span class="dt">void</span> add(<span class="dt">int</span> u,<span class="dt">int</span> v,<span class="dt">int</span> wei)</a><a class="sourceLine" id="cb2-26" title="26">{</a><a class="sourceLine" id="cb2-27" title="27">    es[cnt].to=v;</a><a class="sourceLine" id="cb2-28" title="28">    es[cnt].wei=wei;</a><a class="sourceLine" id="cb2-29" title="29">    es[cnt].next=head[u];</a><a class="sourceLine" id="cb2-30" title="30">    head[u]=cnt++;</a><a class="sourceLine" id="cb2-31" title="31">}</a><a class="sourceLine" id="cb2-32" title="32"><span class="dt">void</span> add_edge(<span class="dt">int</span> u,<span class="dt">int</span> v,<span class="dt">int</span> wei)</a><a class="sourceLine" id="cb2-33" title="33">{</a><a class="sourceLine" id="cb2-34" title="34">    add(u,v,wei);</a><a class="sourceLine" id="cb2-35" title="35">    add(v,u,<span class="dv">0</span>);</a><a class="sourceLine" id="cb2-36" title="36">}</a><a class="sourceLine" id="cb2-37" title="37"><span class="dt">bool</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> t)</a><a class="sourceLine" id="cb2-38" title="38">{</a><a class="sourceLine" id="cb2-39" title="39">    queue&lt;<span class="dt">int</span>&gt; que;</a><a class="sourceLine" id="cb2-40" title="40">    mst(dep,-<span class="dv">1</span>);dep[s]=<span class="dv">0</span>;</a><a class="sourceLine" id="cb2-41" title="41">    que.push(s);</a><a class="sourceLine" id="cb2-42" title="42">    <span class="cf">while</span>(!que.empty()){</a><a class="sourceLine" id="cb2-43" title="43">        <span class="dt">int</span> u=que.front();</a><a class="sourceLine" id="cb2-44" title="44">        que.pop();</a><a class="sourceLine" id="cb2-45" title="45">        <span class="cf">for</span>(<span class="dt">int</span> i=head[u];i!=-<span class="dv">1</span>;i=es[i].next){</a><a class="sourceLine" id="cb2-46" title="46">            <span class="cf">if</span>(es[i].wei&gt;<span class="dv">0</span>&amp;&amp;dep[es[i].to]==-<span class="dv">1</span>){</a><a class="sourceLine" id="cb2-47" title="47">                dep[es[i].to]=dep[u]+<span class="dv">1</span>;</a><a class="sourceLine" id="cb2-48" title="48">                que.push(es[i].to);</a><a class="sourceLine" id="cb2-49" title="49">            }</a><a class="sourceLine" id="cb2-50" title="50">        }</a><a class="sourceLine" id="cb2-51" title="51">    }</a><a class="sourceLine" id="cb2-52" title="52">    <span class="cf">return</span> dep[t]!=-<span class="dv">1</span>;</a><a class="sourceLine" id="cb2-53" title="53">}</a><a class="sourceLine" id="cb2-54" title="54"><span class="dt">int</span> dfs(<span class="dt">int</span> s,<span class="dt">int</span> t,<span class="dt">int</span> mini)</a><a class="sourceLine" id="cb2-55" title="55">{</a><a class="sourceLine" id="cb2-56" title="56">    <span class="cf">if</span>(s==t) <span class="cf">return</span> mini;</a><a class="sourceLine" id="cb2-57" title="57">    <span class="cf">for</span>(<span class="dt">int</span> &amp;i=cur[s];i!=-<span class="dv">1</span>;i=es[i].next){</a><a class="sourceLine" id="cb2-58" title="58">        <span class="cf">if</span>(es[i].wei&gt;<span class="dv">0</span>&amp;&amp;dep[es[i].to]==dep[s]+<span class="dv">1</span>){</a><a class="sourceLine" id="cb2-59" title="59">            <span class="dt">int</span> d=dfs(es[i].to,t,min(es[i].wei,mini));</a><a class="sourceLine" id="cb2-60" title="60">            <span class="cf">if</span>(d&gt;<span class="dv">0</span>){</a><a class="sourceLine" id="cb2-61" title="61">                es[i].wei-=d;</a><a class="sourceLine" id="cb2-62" title="62">                es[i^<span class="dv">1</span>].wei+=d;</a><a class="sourceLine" id="cb2-63" title="63">                <span class="cf">return</span> d;</a><a class="sourceLine" id="cb2-64" title="64">            }</a><a class="sourceLine" id="cb2-65" title="65">        }</a><a class="sourceLine" id="cb2-66" title="66">    }</a><a class="sourceLine" id="cb2-67" title="67">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb2-68" title="68">}</a><a class="sourceLine" id="cb2-69" title="69"><span class="dt">int</span> Dinic(<span class="dt">int</span> s,<span class="dt">int</span> t,<span class="dt">int</span> n)</a><a class="sourceLine" id="cb2-70" title="70">{</a><a class="sourceLine" id="cb2-71" title="71">    <span class="dt">int</span> ans=<span class="dv">0</span>;<span class="dt">int</span> tmp;</a><a class="sourceLine" id="cb2-72" title="72">    <span class="cf">while</span>(bfs(s,t)){</a><a class="sourceLine" id="cb2-73" title="73">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;=n;i++) cur[i]=head[i];</a><a class="sourceLine" id="cb2-74" title="74">        <span class="cf">while</span>((tmp=dfs(s,t,INF))&gt;<span class="dv">0</span>){</a><a class="sourceLine" id="cb2-75" title="75">            ans+=tmp;</a><a class="sourceLine" id="cb2-76" title="76">        }</a><a class="sourceLine" id="cb2-77" title="77">    }</a><a class="sourceLine" id="cb2-78" title="78">    <span class="cf">return</span> ans;</a><a class="sourceLine" id="cb2-79" title="79">}</a><a class="sourceLine" id="cb2-80" title="80"><span class="dt">int</span> mp[<span class="dv">105</span>][<span class="dv">105</span>];</a><a class="sourceLine" id="cb2-81" title="81"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb2-82" title="82">{</a><a class="sourceLine" id="cb2-83" title="83">    init();</a><a class="sourceLine" id="cb2-84" title="84">    <span class="dt">int</span> n,m;scanf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>,&amp;n,&amp;m);</a><a class="sourceLine" id="cb2-85" title="85">    <span class="dt">int</span> sum=<span class="dv">0</span>;</a><a class="sourceLine" id="cb2-86" title="86">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++){</a><a class="sourceLine" id="cb2-87" title="87">        <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;j&lt;=m;j++){</a><a class="sourceLine" id="cb2-88" title="88">            scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;mp[i][j]);</a><a class="sourceLine" id="cb2-89" title="89">            sum+=mp[i][j]; </a><a class="sourceLine" id="cb2-90" title="90">        }</a><a class="sourceLine" id="cb2-91" title="91">    }</a><a class="sourceLine" id="cb2-92" title="92">    <span class="dt">int</span> cntt=<span class="dv">1</span>;</a><a class="sourceLine" id="cb2-93" title="93">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++){</a><a class="sourceLine" id="cb2-94" title="94">        <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;j&lt;=m;j++,cntt++){</a><a class="sourceLine" id="cb2-95" title="95">            <span class="cf">if</span>((i+j)%<span class="dv">2</span>==<span class="dv">0</span>){</a><a class="sourceLine" id="cb2-96" title="96">                add_edge(<span class="dv">0</span>,cntt,mp[i][j]);</a><a class="sourceLine" id="cb2-97" title="97">                <span class="cf">if</span>(j&lt;m) </a><a class="sourceLine" id="cb2-98" title="98">                    add_edge(cntt,cntt+<span class="dv">1</span>,INF);</a><a class="sourceLine" id="cb2-99" title="99">                <span class="cf">if</span>(j&gt;<span class="dv">1</span>) </a><a class="sourceLine" id="cb2-100" title="100">                    add_edge(cntt,cntt-<span class="dv">1</span>,INF);</a><a class="sourceLine" id="cb2-101" title="101">                <span class="cf">if</span>(i&gt;<span class="dv">1</span>) </a><a class="sourceLine" id="cb2-102" title="102">                    add_edge(cntt,cntt-m,INF);</a><a class="sourceLine" id="cb2-103" title="103">                <span class="cf">if</span>(i&lt;n) </a><a class="sourceLine" id="cb2-104" title="104">                    add_edge(cntt,cntt+m,INF);</a><a class="sourceLine" id="cb2-105" title="105">            }<span class="cf">else</span>{</a><a class="sourceLine" id="cb2-106" title="106">                add_edge(cntt,n*m+<span class="dv">1</span>,mp[i][j]);</a><a class="sourceLine" id="cb2-107" title="107">            }</a><a class="sourceLine" id="cb2-108" title="108">        }</a><a class="sourceLine" id="cb2-109" title="109">    }</a><a class="sourceLine" id="cb2-110" title="110"><span class="co">//    debug;</span></a><a class="sourceLine" id="cb2-111" title="111">    <span class="dt">int</span> ans=Dinic(<span class="dv">0</span>,n*m+<span class="dv">1</span>,n*m*<span class="dv">2</span>);</a><a class="sourceLine" id="cb2-112" title="112">    ans=sum-ans;    <span class="co">//总和减去最小割</span></a><a class="sourceLine" id="cb2-113" title="113">    printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>,ans);</a><a class="sourceLine" id="cb2-114" title="114">    <span class="cf">return</span> <span class="dv">0</span>; </a><a class="sourceLine" id="cb2-115" title="115">}</a></code></pre></div><p>从这道题中我们可以看出，最小割可以解决这样的一类问题，在满足某些限制的情况下，计算可以获得的最大价值。在这种情况下，我们可以先假设所有价值都可取，然后将那些不满足情况的作为割删去，那么求最小割就等价于求最小损失。</p><h3 id="最大权闭合子图">最大权闭合子图</h3><h4 id="什么是最大权闭合子图">什么是最大权闭合子图？</h4><p>首先，闭合子图指的是对于一个图，我们从中选出一个子图，它的任意一个点的出度指向的点仍然在这个子图内。而最大权闭合子图指的就是所有闭合子图中点权和最大的那一个。</p><h4 id="如何求最大权闭合子图">如何求最大权闭合子图？</h4><p>有一个结论，对于一个图，满足</p><center><strong>最大权闭合子图权值=所有权值为正的权值总和-最大流</strong></center><p>证明不会......</p><p>如何得到这样的一个图呢？</p><ol type="1"><li>抽象出一个超级源点和一个超级汇点</li><li>将权值为正的点与源点连边，容量分别为各点点权</li><li>将权值为负的点与汇点连边，容量分别为各点点权的绝对值</li><li>权值为0的点不做处理</li><li>将除了源点和汇点之外的边按照题目中的关系连边，容量为INF</li></ol><h4 id="代码-1">代码</h4><div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb3-2" title="2"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb3-3" title="3"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb3-4" title="4"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb3-5" title="5"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb3-6" title="6"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb3-7" title="7"><span class="pp">#define mst</span>(a,b)<span class="pp"> </span>memset((a),(b),<span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb3-8" title="8"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb3-9" title="9"><span class="at">const</span> <span class="dt">int</span> maxn=<span class="fl">1e5</span>+<span class="dv">5</span>;</a><a class="sourceLine" id="cb3-10" title="10"><span class="dt">int</span> head[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb3-11" title="11"><span class="dt">int</span> dep[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb3-12" title="12"><span class="dt">int</span> cur[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb3-13" title="13"><span class="dt">int</span> cnt;</a><a class="sourceLine" id="cb3-14" title="14"><span class="kw">struct</span> edge{</a><a class="sourceLine" id="cb3-15" title="15">    <span class="dt">int</span> to;<span class="dt">int</span> next;</a><a class="sourceLine" id="cb3-16" title="16">    <span class="dt">int</span> wei;</a><a class="sourceLine" id="cb3-17" title="17">};</a><a class="sourceLine" id="cb3-18" title="18">edge es[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb3-19" title="19"><span class="kw">inline</span> <span class="dt">void</span> init()</a><a class="sourceLine" id="cb3-20" title="20">{</a><a class="sourceLine" id="cb3-21" title="21">    cnt=<span class="dv">0</span>;mst(head,-<span class="dv">1</span>);</a><a class="sourceLine" id="cb3-22" title="22">    mst(dep,-<span class="dv">1</span>);mst(cur,-<span class="dv">1</span>);</a><a class="sourceLine" id="cb3-23" title="23">}</a><a class="sourceLine" id="cb3-24" title="24"><span class="dt">void</span> add(<span class="dt">int</span> u,<span class="dt">int</span> v,<span class="dt">int</span> wei)</a><a class="sourceLine" id="cb3-25" title="25">{</a><a class="sourceLine" id="cb3-26" title="26">    es[cnt].to=v;</a><a class="sourceLine" id="cb3-27" title="27">    es[cnt].wei=wei;</a><a class="sourceLine" id="cb3-28" title="28">    es[cnt].next=head[u];</a><a class="sourceLine" id="cb3-29" title="29">    head[u]=cnt++;</a><a class="sourceLine" id="cb3-30" title="30">}</a><a class="sourceLine" id="cb3-31" title="31"><span class="dt">void</span> add_edge(<span class="dt">int</span> u,<span class="dt">int</span> v,<span class="dt">int</span> wei)</a><a class="sourceLine" id="cb3-32" title="32">{</a><a class="sourceLine" id="cb3-33" title="33">    add(u,v,wei);</a><a class="sourceLine" id="cb3-34" title="34">    add(v,u,<span class="dv">0</span>);</a><a class="sourceLine" id="cb3-35" title="35">}</a><a class="sourceLine" id="cb3-36" title="36"><span class="dt">bool</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> t)</a><a class="sourceLine" id="cb3-37" title="37">{</a><a class="sourceLine" id="cb3-38" title="38">    queue&lt;<span class="dt">int</span>&gt; que;</a><a class="sourceLine" id="cb3-39" title="39">    mst(dep,-<span class="dv">1</span>);dep[s]=<span class="dv">0</span>;</a><a class="sourceLine" id="cb3-40" title="40">    que.push(s);</a><a class="sourceLine" id="cb3-41" title="41">    <span class="cf">while</span>(!que.empty()){</a><a class="sourceLine" id="cb3-42" title="42">        <span class="dt">int</span> u=que.front();</a><a class="sourceLine" id="cb3-43" title="43">        que.pop();</a><a class="sourceLine" id="cb3-44" title="44">        <span class="cf">for</span>(<span class="dt">int</span> i=head[u];i!=-<span class="dv">1</span>;i=es[i].next){</a><a class="sourceLine" id="cb3-45" title="45">            <span class="cf">if</span>(es[i].wei&gt;<span class="dv">0</span>&amp;&amp;dep[es[i].to]==-<span class="dv">1</span>){</a><a class="sourceLine" id="cb3-46" title="46">                dep[es[i].to]=dep[u]+<span class="dv">1</span>;</a><a class="sourceLine" id="cb3-47" title="47">                que.push(es[i].to);</a><a class="sourceLine" id="cb3-48" title="48">            }</a><a class="sourceLine" id="cb3-49" title="49">        }</a><a class="sourceLine" id="cb3-50" title="50">    }</a><a class="sourceLine" id="cb3-51" title="51">    <span class="cf">return</span> dep[t]!=-<span class="dv">1</span>;</a><a class="sourceLine" id="cb3-52" title="52">}</a><a class="sourceLine" id="cb3-53" title="53"><span class="dt">int</span> dfs(<span class="dt">int</span> s,<span class="dt">int</span> t,<span class="dt">int</span> mini)</a><a class="sourceLine" id="cb3-54" title="54">{</a><a class="sourceLine" id="cb3-55" title="55">    <span class="cf">if</span>(s==t) <span class="cf">return</span> mini;</a><a class="sourceLine" id="cb3-56" title="56">    <span class="cf">for</span>(<span class="dt">int</span> &amp;i=cur[s];i!=-<span class="dv">1</span>;i=es[i].next){</a><a class="sourceLine" id="cb3-57" title="57">        <span class="cf">if</span>(es[i].wei&gt;<span class="dv">0</span>&amp;&amp;dep[es[i].to]==dep[s]+<span class="dv">1</span>){</a><a class="sourceLine" id="cb3-58" title="58">            <span class="dt">int</span> d=dfs(es[i].to,t,min(es[i].wei,mini));</a><a class="sourceLine" id="cb3-59" title="59">            <span class="cf">if</span>(d&gt;<span class="dv">0</span>){</a><a class="sourceLine" id="cb3-60" title="60">                es[i].wei-=d;</a><a class="sourceLine" id="cb3-61" title="61">                es[i^<span class="dv">1</span>].wei+=d;</a><a class="sourceLine" id="cb3-62" title="62">                <span class="cf">return</span> d;</a><a class="sourceLine" id="cb3-63" title="63">            }</a><a class="sourceLine" id="cb3-64" title="64">        }</a><a class="sourceLine" id="cb3-65" title="65">    }</a><a class="sourceLine" id="cb3-66" title="66">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-67" title="67">}</a><a class="sourceLine" id="cb3-68" title="68"><span class="dt">int</span> Dinic(<span class="dt">int</span> s,<span class="dt">int</span> t,<span class="dt">int</span> n)</a><a class="sourceLine" id="cb3-69" title="69">{</a><a class="sourceLine" id="cb3-70" title="70">    <span class="dt">int</span> ans=<span class="dv">0</span>;<span class="dt">int</span> tmp;</a><a class="sourceLine" id="cb3-71" title="71">    <span class="cf">while</span>(bfs(s,t)){</a><a class="sourceLine" id="cb3-72" title="72">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;=n;i++) cur[i]=head[i];</a><a class="sourceLine" id="cb3-73" title="73">        <span class="cf">while</span>((tmp=dfs(s,t,INF))&gt;<span class="dv">0</span>){</a><a class="sourceLine" id="cb3-74" title="74">            ans+=tmp;</a><a class="sourceLine" id="cb3-75" title="75">        }</a><a class="sourceLine" id="cb3-76" title="76">    }</a><a class="sourceLine" id="cb3-77" title="77">    <span class="cf">return</span> ans;</a><a class="sourceLine" id="cb3-78" title="78">}</a><a class="sourceLine" id="cb3-79" title="79"><span class="dt">int</span> a[maxn&lt;&lt;<span class="dv">1</span>],b[maxn&lt;&lt;<span class="dv">1</span>];</a><a class="sourceLine" id="cb3-80" title="80"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb3-81" title="81">{</a><a class="sourceLine" id="cb3-82" title="82">    init();</a><a class="sourceLine" id="cb3-83" title="83">    <span class="dt">int</span> n,m;scanf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>,&amp;n,&amp;m);</a><a class="sourceLine" id="cb3-84" title="84">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=m;i++)</a><a class="sourceLine" id="cb3-85" title="85">        scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;b[i]);        <span class="co">//学生 </span></a><a class="sourceLine" id="cb3-86" title="86">    <span class="dt">int</span> sum=<span class="dv">0</span>;</a><a class="sourceLine" id="cb3-87" title="87">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++){        <span class="co">//活动 </span></a><a class="sourceLine" id="cb3-88" title="88">        scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;a[i]);</a><a class="sourceLine" id="cb3-89" title="89">        sum+=a[i];</a><a class="sourceLine" id="cb3-90" title="90">        <span class="dt">int</span> k;scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;k);</a><a class="sourceLine" id="cb3-91" title="91">        <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;j&lt;=k;j++){</a><a class="sourceLine" id="cb3-92" title="92">            <span class="dt">int</span> v;scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;v);</a><a class="sourceLine" id="cb3-93" title="93">            add_edge(i,v+n,INF);</a><a class="sourceLine" id="cb3-94" title="94">        }</a><a class="sourceLine" id="cb3-95" title="95">    }</a><a class="sourceLine" id="cb3-96" title="96">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++) add_edge(<span class="dv">0</span>,i,a[i]);</a><a class="sourceLine" id="cb3-97" title="97">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=m;i++) add_edge(i+n,n+m+<span class="dv">1</span>,b[i]);</a><a class="sourceLine" id="cb3-98" title="98">    <span class="dt">int</span> ans=Dinic(<span class="dv">0</span>,n+m+<span class="dv">1</span>,n+m+<span class="dv">3</span>);</a><a class="sourceLine" id="cb3-99" title="99">    ans=sum-ans;</a><a class="sourceLine" id="cb3-100" title="100">    printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>,ans);</a><a class="sourceLine" id="cb3-101" title="101">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb3-102" title="102">}</a></code></pre></div><h4 id="测一下板子">测一下板子</h4><p><a href="https://vjudge.net/problem/HihoCoder-1398">网络流五·最大权闭合子图</a></p><h3 id="参考博文">参考博文</h3><ul><li><a href="https://www.cnblogs.com/songorz/p/9642840.html">最大权闭合子图</a></li><li><a href="https://blog.csdn.net/qq_41357771/article/details/79416899">网络流【最大流&amp;&amp;最小割&amp;&amp;费用流】——一篇简单易懂的博文</a></li><li><a href="https://www.cnblogs.com/linzhengmin/p/9313216.html">[算法]网络最大流Dinic 前言</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/H5f34d005235d4ae08a65080af36eb1b35.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/categories/ACM/"/>
    
    <category term="图论" scheme="https://xtayex.gitee.io/categories/ACM/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="https://xtayex.gitee.io/categories/ACM/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/tags/ACM/"/>
    
    <category term="网络流" scheme="https://xtayex.gitee.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="最大流" scheme="https://xtayex.gitee.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
    <category term="最大流最小割" scheme="https://xtayex.gitee.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
    <category term="最大权闭合子图" scheme="https://xtayex.gitee.io/tags/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>POJ2104 - Kth number 主席树or划分树模板</title>
    <link href="https://xtayex.gitee.io/2019/09/07/HDU2665-Kth-Number-%E4%B8%BB%E5%B8%AD%E6%A0%91or%E5%88%92%E5%88%86%E6%A0%91%E6%A8%A1%E6%9D%BF/"/>
    <id>https://xtayex.gitee.io/2019/09/07/HDU2665-Kth-Number-%E4%B8%BB%E5%B8%AD%E6%A0%91or%E5%88%92%E5%88%86%E6%A0%91%E6%A8%A1%E6%9D%BF/</id>
    <published>2019-09-07T01:00:00.000Z</published>
    <updated>2022-09-27T13:46:55.099Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ae01.alicdn.com/kf/He1712fd2c08f40a985b1ef436e9be051G.jpg"></p><span id="more"></span><p><a href="http://poj.org/problem?id=2104">Kth number</a></p><p>模板题，题意是求区间第k大，套一下主席树模板或者划分树模板即可（屯板子）</p><p>代码如下：</p><p>主席树：</p><div class="sourceCode" id="cb1"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb1-6" title="6"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb1-7" title="7"><span class="pp">#include </span><span class="im">&lt;list&gt;</span></a><a class="sourceLine" id="cb1-8" title="8"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb1-9" title="9"><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></a><a class="sourceLine" id="cb1-10" title="10"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb1-11" title="11"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb1-12" title="12"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb1-13" title="13"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb1-14" title="14"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb1-15" title="15"><span class="pp">#define mst</span>(a,b)<span class="pp"> </span>memset((a),(b),<span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb1-16" title="16"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb1-17" title="17"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb1-18" title="18"><span class="pp">#define IOS </span><span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio(<span class="kw">false</span>)</a><a class="sourceLine" id="cb1-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn=<span class="fl">1e5</span>+<span class="dv">5</span>;</a><a class="sourceLine" id="cb1-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb1-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb1-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb1-23" title="23"><span class="dt">int</span> rt[maxn&lt;&lt;<span class="dv">5</span>];</a><a class="sourceLine" id="cb1-24" title="24"><span class="dt">int</span> sum[maxn&lt;&lt;<span class="dv">5</span>];</a><a class="sourceLine" id="cb1-25" title="25"><span class="dt">int</span> ls[maxn&lt;&lt;<span class="dv">5</span>],rs[maxn&lt;&lt;<span class="dv">5</span>];</a><a class="sourceLine" id="cb1-26" title="26"><span class="dt">int</span> tot;</a><a class="sourceLine" id="cb1-27" title="27"><span class="dt">int</span> p;</a><a class="sourceLine" id="cb1-28" title="28"><span class="dt">void</span> build(<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span>&amp; root)        <span class="co">//其实就是一个为各节点分配id的过程 </span></a><a class="sourceLine" id="cb1-29" title="29">{</a><a class="sourceLine" id="cb1-30" title="30">    root=++tot;</a><a class="sourceLine" id="cb1-31" title="31">    <span class="cf">if</span>(lef==rig)    <span class="cf">return</span> ;</a><a class="sourceLine" id="cb1-32" title="32">    <span class="dt">int</span> mid=lef+(rig-lef)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb1-33" title="33">    build(lef,mid,ls[root]);</a><a class="sourceLine" id="cb1-34" title="34">    build(mid+<span class="dv">1</span>,rig,rs[root]);</a><a class="sourceLine" id="cb1-35" title="35">}</a><a class="sourceLine" id="cb1-36" title="36"><span class="dt">int</span> update(<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> root)        </a><a class="sourceLine" id="cb1-37" title="37">{</a><a class="sourceLine" id="cb1-38" title="38">    <span class="dt">int</span> <span class="va">root_</span>=++tot;        <span class="co">//建一棵新树 </span></a><a class="sourceLine" id="cb1-39" title="39">    ls[<span class="va">root_</span>]=ls[root];</a><a class="sourceLine" id="cb1-40" title="40">    rs[<span class="va">root_</span>]=rs[root];</a><a class="sourceLine" id="cb1-41" title="41">    sum[<span class="va">root_</span>]=sum[root]+<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-42" title="42">    <span class="cf">if</span>(lef==rig)    <span class="cf">return</span> <span class="va">root_</span>;</a><a class="sourceLine" id="cb1-43" title="43">    <span class="dt">int</span> mid=lef+(rig-lef)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb1-44" title="44">    <span class="cf">if</span>(p&lt;=mid){</a><a class="sourceLine" id="cb1-45" title="45">        ls[<span class="va">root_</span>]=update(lef,mid,ls[<span class="va">root_</span>]);        <span class="co">//如果修改点在左儿子，就新建一个左儿子 </span></a><a class="sourceLine" id="cb1-46" title="46">    }<span class="cf">else</span>{</a><a class="sourceLine" id="cb1-47" title="47">        rs[<span class="va">root_</span>]=update(mid+<span class="dv">1</span>,rig,rs[<span class="va">root_</span>]);        <span class="co">//如果修改点在右儿子，就新建一个右儿子 </span></a><a class="sourceLine" id="cb1-48" title="48">    }</a><a class="sourceLine" id="cb1-49" title="49">    <span class="cf">return</span> <span class="va">root_</span>;</a><a class="sourceLine" id="cb1-50" title="50">}</a><a class="sourceLine" id="cb1-51" title="51"><span class="dt">int</span> query(<span class="dt">int</span> u,<span class="dt">int</span> v,<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> k)</a><a class="sourceLine" id="cb1-52" title="52">{</a><a class="sourceLine" id="cb1-53" title="53">    <span class="dt">int</span> ans=<span class="dv">0</span>;</a><a class="sourceLine" id="cb1-54" title="54">    <span class="dt">int</span> mid=lef+(rig-lef)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb1-55" title="55">    <span class="dt">int</span> x=sum[ls[v]]-sum[ls[u]];</a><a class="sourceLine" id="cb1-56" title="56">    <span class="cf">if</span>(lef==rig)    <span class="cf">return</span> lef;</a><a class="sourceLine" id="cb1-57" title="57">    <span class="cf">if</span>(x&gt;=k){</a><a class="sourceLine" id="cb1-58" title="58">        ans=query(ls[u],ls[v],lef,mid,k);</a><a class="sourceLine" id="cb1-59" title="59">    }<span class="cf">else</span>{</a><a class="sourceLine" id="cb1-60" title="60">        ans=query(rs[u],rs[v],mid+<span class="dv">1</span>,rig,k-x);</a><a class="sourceLine" id="cb1-61" title="61">    }</a><a class="sourceLine" id="cb1-62" title="62">    <span class="cf">return</span> ans;</a><a class="sourceLine" id="cb1-63" title="63">}</a><a class="sourceLine" id="cb1-64" title="64"><span class="dt">int</span> arr[maxn];</a><a class="sourceLine" id="cb1-65" title="65"><span class="dt">int</span> lisan[maxn];</a><a class="sourceLine" id="cb1-66" title="66"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb1-67" title="67">{</a><a class="sourceLine" id="cb1-68" title="68">    tot=<span class="dv">0</span>;</a><a class="sourceLine" id="cb1-69" title="69">    <span class="dt">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</a><a class="sourceLine" id="cb1-70" title="70">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)    cin&gt;&gt;arr[i],lisan[i]=arr[i];</a><a class="sourceLine" id="cb1-71" title="71">    sort(lisan+<span class="dv">1</span>,lisan+<span class="dv">1</span>+n);</a><a class="sourceLine" id="cb1-72" title="72">    <span class="dt">int</span> len=unique(lisan+<span class="dv">1</span>,lisan+<span class="dv">1</span>+n)-lisan-<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-73" title="73">    build(<span class="dv">1</span>,len,rt[<span class="dv">0</span>]);</a><a class="sourceLine" id="cb1-74" title="74">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++){</a><a class="sourceLine" id="cb1-75" title="75">        p=lower_bound(lisan+<span class="dv">1</span>,lisan+<span class="dv">1</span>+len,arr[i])-lisan;</a><a class="sourceLine" id="cb1-76" title="76">        rt[i]=update(<span class="dv">1</span>,len,rt[i-<span class="dv">1</span>]);</a><a class="sourceLine" id="cb1-77" title="77">    }</a><a class="sourceLine" id="cb1-78" title="78">    <span class="dt">int</span> ans=<span class="dv">0</span>;</a><a class="sourceLine" id="cb1-79" title="79">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++){</a><a class="sourceLine" id="cb1-80" title="80">        <span class="dt">int</span> L,R,k;cin&gt;&gt;L&gt;&gt;R&gt;&gt;k;</a><a class="sourceLine" id="cb1-81" title="81">        ans=query(rt[L-<span class="dv">1</span>],rt[R],<span class="dv">1</span>,len,k);</a><a class="sourceLine" id="cb1-82" title="82">        cout&lt;&lt;lisan[ans]&lt;&lt;<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>;</a><a class="sourceLine" id="cb1-83" title="83">    }</a><a class="sourceLine" id="cb1-84" title="84">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-85" title="85">    </a><a class="sourceLine" id="cb1-86" title="86">}</a></code></pre></div><p>划分树：</p><div class="sourceCode" id="cb2"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb2-3" title="3"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb2-4" title="4"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb2-5" title="5"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb2-6" title="6"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb2-7" title="7"><span class="pp">#include </span><span class="im">&lt;list&gt;</span></a><a class="sourceLine" id="cb2-8" title="8"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb2-9" title="9"><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></a><a class="sourceLine" id="cb2-10" title="10"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb2-11" title="11"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb2-12" title="12"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb2-13" title="13"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb2-14" title="14"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb2-15" title="15"><span class="pp">#define mst</span>(a,b)<span class="pp"> </span>memset((a),(b),<span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb2-16" title="16"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb2-17" title="17"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb2-18" title="18"><span class="pp">#define IOS </span><span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio(<span class="kw">false</span>)</a><a class="sourceLine" id="cb2-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn=<span class="fl">1e5</span>+<span class="dv">50</span>;</a><a class="sourceLine" id="cb2-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb2-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb2-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb2-23" title="23"><span class="dt">int</span> tree[<span class="dv">20</span>][maxn];</a><a class="sourceLine" id="cb2-24" title="24"><span class="dt">int</span> to_lef[<span class="dv">20</span>][maxn]; </a><a class="sourceLine" id="cb2-25" title="25"><span class="dt">int</span> sorted[maxn];</a><a class="sourceLine" id="cb2-26" title="26"><span class="dt">void</span> build(<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> lev)</a><a class="sourceLine" id="cb2-27" title="27">{</a><a class="sourceLine" id="cb2-28" title="28">    <span class="cf">if</span>(lef==rig) <span class="cf">return</span> ;</a><a class="sourceLine" id="cb2-29" title="29">    <span class="dt">int</span> mid=lef+(rig-lef)/<span class="dv">2</span>; </a><a class="sourceLine" id="cb2-30" title="30">    <span class="dt">int</span> sup=mid-lef+<span class="dv">1</span>;</a><a class="sourceLine" id="cb2-31" title="31">    <span class="cf">for</span>(<span class="dt">int</span> i=lef;i&lt;=rig;i++){</a><a class="sourceLine" id="cb2-32" title="32">        <span class="cf">if</span>(tree[lev][i]&lt;sorted[mid]){</a><a class="sourceLine" id="cb2-33" title="33">            sup--;</a><a class="sourceLine" id="cb2-34" title="34">        }</a><a class="sourceLine" id="cb2-35" title="35">    }</a><a class="sourceLine" id="cb2-36" title="36">    <span class="dt">int</span> sublef=lef;<span class="dt">int</span> subrig=mid+<span class="dv">1</span>;</a><a class="sourceLine" id="cb2-37" title="37">    <span class="cf">for</span>(<span class="dt">int</span> i=lef;i&lt;=rig;i++){</a><a class="sourceLine" id="cb2-38" title="38">        <span class="cf">if</span>(i==lef){</a><a class="sourceLine" id="cb2-39" title="39">            to_lef[lev][i]=<span class="dv">0</span>;</a><a class="sourceLine" id="cb2-40" title="40">        }<span class="cf">else</span>{</a><a class="sourceLine" id="cb2-41" title="41">            to_lef[lev][i]=to_lef[lev][i-<span class="dv">1</span>];</a><a class="sourceLine" id="cb2-42" title="42">        }</a><a class="sourceLine" id="cb2-43" title="43">        <span class="cf">if</span>(tree[lev][i]&lt;sorted[mid]||tree[lev][i]==sorted[mid]&amp;&amp;sup&gt;<span class="dv">0</span>){</a><a class="sourceLine" id="cb2-44" title="44">            tree[lev+<span class="dv">1</span>][sublef++]=tree[lev][i];</a><a class="sourceLine" id="cb2-45" title="45">            to_lef[lev][i]++;</a><a class="sourceLine" id="cb2-46" title="46">            <span class="cf">if</span>(tree[lev][i]==sorted[mid])    sup--;</a><a class="sourceLine" id="cb2-47" title="47">        }<span class="cf">else</span>{</a><a class="sourceLine" id="cb2-48" title="48">            tree[lev+<span class="dv">1</span>][subrig++]=tree[lev][i]; </a><a class="sourceLine" id="cb2-49" title="49">        }</a><a class="sourceLine" id="cb2-50" title="50">    }</a><a class="sourceLine" id="cb2-51" title="51">    build(lef,mid,lev+<span class="dv">1</span>);</a><a class="sourceLine" id="cb2-52" title="52">    build(mid+<span class="dv">1</span>,rig,lev+<span class="dv">1</span>);</a><a class="sourceLine" id="cb2-53" title="53">}</a><a class="sourceLine" id="cb2-54" title="54"><span class="dt">int</span> query(<span class="dt">int</span> lev,<span class="dt">int</span> lef,<span class="dt">int</span> rig,<span class="dt">int</span> L,<span class="dt">int</span> R,<span class="dt">int</span> k)</a><a class="sourceLine" id="cb2-55" title="55">{</a><a class="sourceLine" id="cb2-56" title="56">    <span class="dt">int</span> mid=lef+(rig-lef)/<span class="dv">2</span>;</a><a class="sourceLine" id="cb2-57" title="57">    <span class="cf">if</span>(L==R)    <span class="cf">return</span> tree[lev][L];</a><a class="sourceLine" id="cb2-58" title="58">    <span class="dt">int</span> <span class="va">lef_</span>,tolef;</a><a class="sourceLine" id="cb2-59" title="59">    <span class="cf">if</span>(L==lef){</a><a class="sourceLine" id="cb2-60" title="60">        <span class="va">lef_</span>=<span class="dv">0</span>;tolef=to_lef[lev][R];</a><a class="sourceLine" id="cb2-61" title="61">    }<span class="cf">else</span>{</a><a class="sourceLine" id="cb2-62" title="62">        <span class="va">lef_</span>=to_lef[lev][L-<span class="dv">1</span>];</a><a class="sourceLine" id="cb2-63" title="63">        tolef=to_lef[lev][R]-<span class="va">lef_</span>;</a><a class="sourceLine" id="cb2-64" title="64">    }</a><a class="sourceLine" id="cb2-65" title="65">    <span class="cf">if</span>(k&lt;=tolef){</a><a class="sourceLine" id="cb2-66" title="66">        <span class="dt">int</span> tmp_lef=lef+<span class="va">lef_</span>;</a><a class="sourceLine" id="cb2-67" title="67">        <span class="dt">int</span> tmp_rig=lef+<span class="va">lef_</span>+tolef-<span class="dv">1</span>;</a><a class="sourceLine" id="cb2-68" title="68">        <span class="cf">return</span> query(lev+<span class="dv">1</span>,lef,mid,tmp_lef,tmp_rig,k);</a><a class="sourceLine" id="cb2-69" title="69">    }<span class="cf">else</span>{</a><a class="sourceLine" id="cb2-70" title="70">        <span class="dt">int</span> tmp_lef=mid+L-lef-<span class="va">lef_</span>+<span class="dv">1</span>;</a><a class="sourceLine" id="cb2-71" title="71">        <span class="dt">int</span> tmp_rig=mid+R-lef-<span class="va">lef_</span>-tolef+<span class="dv">1</span>;</a><a class="sourceLine" id="cb2-72" title="72">        <span class="cf">return</span> query(lev+<span class="dv">1</span>,mid+<span class="dv">1</span>,rig,tmp_lef,tmp_rig,k-tolef);</a><a class="sourceLine" id="cb2-73" title="73">    }</a><a class="sourceLine" id="cb2-74" title="74">}</a><a class="sourceLine" id="cb2-75" title="75"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb2-76" title="76">{</a><a class="sourceLine" id="cb2-77" title="77">    <span class="dt">int</span> n,m;scanf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>,&amp;n,&amp;m);</a><a class="sourceLine" id="cb2-78" title="78">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++){</a><a class="sourceLine" id="cb2-79" title="79">        scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;sorted[i]);</a><a class="sourceLine" id="cb2-80" title="80">        tree[<span class="dv">0</span>][i]=sorted[i];</a><a class="sourceLine" id="cb2-81" title="81">    }</a><a class="sourceLine" id="cb2-82" title="82">    sort(sorted+<span class="dv">1</span>,sorted+<span class="dv">1</span>+n);</a><a class="sourceLine" id="cb2-83" title="83">    build(<span class="dv">1</span>,n,<span class="dv">0</span>);</a><a class="sourceLine" id="cb2-84" title="84">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++){</a><a class="sourceLine" id="cb2-85" title="85">        <span class="dt">int</span> x,y,k;scanf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span>,&amp;x,&amp;y,&amp;k);</a><a class="sourceLine" id="cb2-86" title="86">        <span class="dt">int</span> ans=query(<span class="dv">0</span>,<span class="dv">1</span>,n,x,y,k);</a><a class="sourceLine" id="cb2-87" title="87">        printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>,ans);</a><a class="sourceLine" id="cb2-88" title="88">    }</a><a class="sourceLine" id="cb2-89" title="89">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb2-90" title="90">}</a></code></pre></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/He1712fd2c08f40a985b1ef436e9be051G.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/categories/ACM/"/>
    
    <category term="数据结构" scheme="https://xtayex.gitee.io/categories/ACM/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="主席树" scheme="https://xtayex.gitee.io/categories/ACM/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/tags/ACM/"/>
    
    <category term="数据结构" scheme="https://xtayex.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="主席树" scheme="https://xtayex.gitee.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
    <category term="划分树" scheme="https://xtayex.gitee.io/tags/%E5%88%92%E5%88%86%E6%A0%91/"/>
    
    <category term="屯板子" scheme="https://xtayex.gitee.io/tags/%E5%B1%AF%E6%9D%BF%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>HDU2222 &amp; HDU2896 - AC自动机模板</title>
    <link href="https://xtayex.gitee.io/2019/08/31/HDU2222-HDU2896-AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A8%A1%E6%9D%BF/"/>
    <id>https://xtayex.gitee.io/2019/08/31/HDU2222-HDU2896-AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A8%A1%E6%9D%BF/</id>
    <published>2019-08-31T01:21:00.000Z</published>
    <updated>2022-09-27T13:46:55.095Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ae01.alicdn.com/kf/H65722373b7674099b56790ec509eb5a8B.jpg"></p><span id="more"></span><p>屯板子屯板子......</p><p><a href="https://cn.vjudge.net/problem/HDU-2222">HDU2222 - Keywords Search</a></p><div class="sourceCode" id="cb1"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb1-6" title="6"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb1-7" title="7"><span class="pp">#include </span><span class="im">&lt;list&gt;</span></a><a class="sourceLine" id="cb1-8" title="8"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb1-9" title="9"><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></a><a class="sourceLine" id="cb1-10" title="10"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb1-11" title="11"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb1-12" title="12"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb1-13" title="13"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb1-14" title="14"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb1-15" title="15"><span class="pp">#define mst</span>(a,b)<span class="pp"> </span>memset((a),(b),<span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb1-16" title="16"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb1-17" title="17"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb1-18" title="18"><span class="pp">#define IOS </span><span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio(<span class="kw">false</span>)</a><a class="sourceLine" id="cb1-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn=<span class="fl">1e5</span>+<span class="dv">5</span>;</a><a class="sourceLine" id="cb1-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb1-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb1-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb1-23" title="23"><span class="kw">struct</span> Trie{</a><a class="sourceLine" id="cb1-24" title="24">    <span class="dt">int</span> next[<span class="dv">500005</span>][<span class="dv">26</span>];</a><a class="sourceLine" id="cb1-25" title="25">    <span class="dt">int</span> fail[<span class="dv">500005</span>];</a><a class="sourceLine" id="cb1-26" title="26">    <span class="dt">int</span> ed[<span class="dv">500005</span>];</a><a class="sourceLine" id="cb1-27" title="27">    <span class="dt">int</span> rt,L;</a><a class="sourceLine" id="cb1-28" title="28">    queue&lt;<span class="dt">int</span>&gt; que;</a><a class="sourceLine" id="cb1-29" title="29">    <span class="dt">int</span> newnode(){</a><a class="sourceLine" id="cb1-30" title="30">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">26</span>;i++){</a><a class="sourceLine" id="cb1-31" title="31">            next[L][i]=-<span class="dv">1</span>;</a><a class="sourceLine" id="cb1-32" title="32">        }</a><a class="sourceLine" id="cb1-33" title="33">        ed[L]=<span class="dv">0</span>;<span class="dt">int</span> tmpL=L;L++;</a><a class="sourceLine" id="cb1-34" title="34">        <span class="cf">return</span> tmpL;</a><a class="sourceLine" id="cb1-35" title="35">    }</a><a class="sourceLine" id="cb1-36" title="36">    <span class="dt">void</span> init(){</a><a class="sourceLine" id="cb1-37" title="37">        L=<span class="dv">0</span>;</a><a class="sourceLine" id="cb1-38" title="38">        rt=newnode();</a><a class="sourceLine" id="cb1-39" title="39">        <span class="cf">while</span>(!que.empty())    que.pop();</a><a class="sourceLine" id="cb1-40" title="40">    }</a><a class="sourceLine" id="cb1-41" title="41">    <span class="dt">void</span> <span class="va">insert_</span>(string str){</a><a class="sourceLine" id="cb1-42" title="42">        <span class="dt">int</span> len=str.size();</a><a class="sourceLine" id="cb1-43" title="43">        <span class="dt">int</span> cur=rt;</a><a class="sourceLine" id="cb1-44" title="44">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;len;i++){</a><a class="sourceLine" id="cb1-45" title="45">            <span class="dt">char</span> ch=str[i];</a><a class="sourceLine" id="cb1-46" title="46">            <span class="cf">if</span>(next[cur][ch-<span class="ch">'a'</span>]==-<span class="dv">1</span>){</a><a class="sourceLine" id="cb1-47" title="47">                next[cur][ch-<span class="ch">'a'</span>]=newnode();</a><a class="sourceLine" id="cb1-48" title="48">            }</a><a class="sourceLine" id="cb1-49" title="49">            cur=next[cur][ch-<span class="ch">'a'</span>];</a><a class="sourceLine" id="cb1-50" title="50">        }</a><a class="sourceLine" id="cb1-51" title="51">        ed[cur]++;</a><a class="sourceLine" id="cb1-52" title="52">    } </a><a class="sourceLine" id="cb1-53" title="53">    <span class="dt">void</span> build(){</a><a class="sourceLine" id="cb1-54" title="54">        fail[rt]=rt;</a><a class="sourceLine" id="cb1-55" title="55">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">26</span>;i++){</a><a class="sourceLine" id="cb1-56" title="56">            <span class="cf">if</span>(next[rt][i]==-<span class="dv">1</span>){</a><a class="sourceLine" id="cb1-57" title="57">                next[rt][i]=rt;</a><a class="sourceLine" id="cb1-58" title="58">            }<span class="cf">else</span>{</a><a class="sourceLine" id="cb1-59" title="59">                fail[next[rt][i]]=rt;</a><a class="sourceLine" id="cb1-60" title="60">                que.push(next[rt][i]);</a><a class="sourceLine" id="cb1-61" title="61">            }</a><a class="sourceLine" id="cb1-62" title="62">        }</a><a class="sourceLine" id="cb1-63" title="63">        <span class="cf">while</span>(!que.empty()){</a><a class="sourceLine" id="cb1-64" title="64">            <span class="dt">int</span> u=que.front();</a><a class="sourceLine" id="cb1-65" title="65">            que.pop();</a><a class="sourceLine" id="cb1-66" title="66">            <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">26</span>;i++){</a><a class="sourceLine" id="cb1-67" title="67">                <span class="cf">if</span>(next[u][i]==-<span class="dv">1</span>){</a><a class="sourceLine" id="cb1-68" title="68">                    next[u][i]=next[fail[u]][i];</a><a class="sourceLine" id="cb1-69" title="69">                }<span class="cf">else</span>{</a><a class="sourceLine" id="cb1-70" title="70">                    fail[next[u][i]]=next[fail[u]][i];</a><a class="sourceLine" id="cb1-71" title="71">                    que.push(next[u][i]);</a><a class="sourceLine" id="cb1-72" title="72">                }</a><a class="sourceLine" id="cb1-73" title="73">            }</a><a class="sourceLine" id="cb1-74" title="74">        }</a><a class="sourceLine" id="cb1-75" title="75">    }</a><a class="sourceLine" id="cb1-76" title="76">    <span class="dt">int</span> queue(string str){</a><a class="sourceLine" id="cb1-77" title="77">        <span class="dt">int</span> len=str.size();</a><a class="sourceLine" id="cb1-78" title="78">        <span class="dt">int</span> now=rt;</a><a class="sourceLine" id="cb1-79" title="79">        <span class="dt">int</span> ans=<span class="dv">0</span>;</a><a class="sourceLine" id="cb1-80" title="80">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;len;i++){</a><a class="sourceLine" id="cb1-81" title="81">            now=next[now][str[i]-<span class="ch">'a'</span>];</a><a class="sourceLine" id="cb1-82" title="82">            <span class="dt">int</span> tmp=now;</a><a class="sourceLine" id="cb1-83" title="83">            <span class="cf">while</span>(tmp!=rt){</a><a class="sourceLine" id="cb1-84" title="84">                ans+=ed[tmp];</a><a class="sourceLine" id="cb1-85" title="85">                ed[tmp]=<span class="dv">0</span>;</a><a class="sourceLine" id="cb1-86" title="86">                tmp=fail[tmp];</a><a class="sourceLine" id="cb1-87" title="87">            }</a><a class="sourceLine" id="cb1-88" title="88">        }</a><a class="sourceLine" id="cb1-89" title="89">        <span class="cf">return</span> ans;</a><a class="sourceLine" id="cb1-90" title="90">    }</a><a class="sourceLine" id="cb1-91" title="91">    <span class="dt">void</span> show(){</a><a class="sourceLine" id="cb1-92" title="92">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">100</span>;i++){</a><a class="sourceLine" id="cb1-93" title="93">            cout&lt;&lt;<span class="st">"i = "</span>&lt;&lt;i&lt;&lt;<span class="st">" "</span>&lt;&lt;ed[i]&lt;&lt;<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>;</a><a class="sourceLine" id="cb1-94" title="94">        }</a><a class="sourceLine" id="cb1-95" title="95">    }</a><a class="sourceLine" id="cb1-96" title="96">};</a><a class="sourceLine" id="cb1-97" title="97">Trie acmaton;        <span class="co">//内部有大数组，需要开全局变量 </span></a><a class="sourceLine" id="cb1-98" title="98"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb1-99" title="99">{</a><a class="sourceLine" id="cb1-100" title="100">    IOS;</a><a class="sourceLine" id="cb1-101" title="101">    <span class="dt">int</span> t;cin&gt;&gt;t;</a><a class="sourceLine" id="cb1-102" title="102">    <span class="cf">while</span>(t--){</a><a class="sourceLine" id="cb1-103" title="103">        <span class="dt">int</span> n;cin&gt;&gt;n;</a><a class="sourceLine" id="cb1-104" title="104">        acmaton.init();</a><a class="sourceLine" id="cb1-105" title="105">        string tmps;</a><a class="sourceLine" id="cb1-106" title="106">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){</a><a class="sourceLine" id="cb1-107" title="107">            cin&gt;&gt;tmps;acmaton.<span class="va">insert_</span>(tmps);</a><a class="sourceLine" id="cb1-108" title="108">        }</a><a class="sourceLine" id="cb1-109" title="109">        acmaton.build();</a><a class="sourceLine" id="cb1-110" title="110"><span class="co">//        acmaton.show();</span></a><a class="sourceLine" id="cb1-111" title="111">        cin&gt;&gt;tmps;</a><a class="sourceLine" id="cb1-112" title="112">        <span class="dt">int</span> ans=acmaton.queue(tmps);</a><a class="sourceLine" id="cb1-113" title="113">        cout&lt;&lt;ans&lt;&lt;<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>;</a><a class="sourceLine" id="cb1-114" title="114">    }</a><a class="sourceLine" id="cb1-115" title="115">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb1-116" title="116">}</a></code></pre></div><p><a href="https://cn.vjudge.net/problem/HDU-2896">HDU2896 - 病毒侵袭</a></p><div class="sourceCode" id="cb2"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a><a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a><a class="sourceLine" id="cb2-3" title="3"><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></a><a class="sourceLine" id="cb2-4" title="4"><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></a><a class="sourceLine" id="cb2-5" title="5"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a><a class="sourceLine" id="cb2-6" title="6"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a><a class="sourceLine" id="cb2-7" title="7"><span class="pp">#include </span><span class="im">&lt;list&gt;</span></a><a class="sourceLine" id="cb2-8" title="8"><span class="pp">#include </span><span class="im">&lt;set&gt;</span></a><a class="sourceLine" id="cb2-9" title="9"><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></a><a class="sourceLine" id="cb2-10" title="10"><span class="pp">#include </span><span class="im">&lt;map&gt;</span></a><a class="sourceLine" id="cb2-11" title="11"><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></a><a class="sourceLine" id="cb2-12" title="12"><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></a><a class="sourceLine" id="cb2-13" title="13"><span class="pp">#include </span><span class="im">&lt;string&gt;</span></a><a class="sourceLine" id="cb2-14" title="14"><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></a><a class="sourceLine" id="cb2-15" title="15"><span class="pp">#define mst</span>(a,b)<span class="pp"> </span>memset((a),(b),<span class="kw">sizeof</span>(a))</a><a class="sourceLine" id="cb2-16" title="16"><span class="pp">#define debug </span>printf(<span class="st">"debug</span><span class="sc">\n</span><span class="st">"</span>)</a><a class="sourceLine" id="cb2-17" title="17"><span class="pp">#define INF </span><span class="bn">0x3f3f3f3f</span></a><a class="sourceLine" id="cb2-18" title="18"><span class="pp">#define IOS </span><span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio(<span class="kw">false</span>)</a><a class="sourceLine" id="cb2-19" title="19"><span class="at">const</span> <span class="dt">int</span> maxn=<span class="fl">1e5</span>+<span class="dv">5</span>;</a><a class="sourceLine" id="cb2-20" title="20"><span class="kw">using</span> <span class="kw">namespace</span> std;</a><a class="sourceLine" id="cb2-21" title="21"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</a><a class="sourceLine" id="cb2-22" title="22"><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;</a><a class="sourceLine" id="cb2-23" title="23">vector&lt;<span class="dt">int</span>&gt; ansvec;</a><a class="sourceLine" id="cb2-24" title="24"><span class="kw">struct</span> Trie{</a><a class="sourceLine" id="cb2-25" title="25">    <span class="dt">int</span> next[<span class="dv">100005</span>][<span class="dv">128</span>];</a><a class="sourceLine" id="cb2-26" title="26">    <span class="dt">int</span> fail[<span class="dv">100005</span>];</a><a class="sourceLine" id="cb2-27" title="27">    <span class="dt">int</span> edstr[<span class="dv">100005</span>];</a><a class="sourceLine" id="cb2-28" title="28">    <span class="dt">int</span> rt,L;</a><a class="sourceLine" id="cb2-29" title="29">    <span class="dt">int</span> scnt;    <span class="co">//字符串数量 </span></a><a class="sourceLine" id="cb2-30" title="30">    queue&lt;<span class="dt">int</span>&gt; que;</a><a class="sourceLine" id="cb2-31" title="31">    <span class="dt">int</span> newnode(){</a><a class="sourceLine" id="cb2-32" title="32">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">128</span>;i++){</a><a class="sourceLine" id="cb2-33" title="33">            next[L][i]=-<span class="dv">1</span>;</a><a class="sourceLine" id="cb2-34" title="34">        }</a><a class="sourceLine" id="cb2-35" title="35">        edstr[L]=<span class="dv">0</span>;<span class="dt">int</span> tmpL=L;L++;</a><a class="sourceLine" id="cb2-36" title="36">        <span class="cf">return</span> tmpL;</a><a class="sourceLine" id="cb2-37" title="37">    }</a><a class="sourceLine" id="cb2-38" title="38">    <span class="dt">void</span> init(){</a><a class="sourceLine" id="cb2-39" title="39">        L=<span class="dv">0</span>;scnt=<span class="dv">0</span>;</a><a class="sourceLine" id="cb2-40" title="40">        rt=newnode();</a><a class="sourceLine" id="cb2-41" title="41">        <span class="cf">while</span>(!que.empty())    que.pop();</a><a class="sourceLine" id="cb2-42" title="42">    }</a><a class="sourceLine" id="cb2-43" title="43">    <span class="dt">void</span> <span class="va">insert_</span>(<span class="dt">char</span> str[]){</a><a class="sourceLine" id="cb2-44" title="44">        <span class="dt">int</span> len=strlen(str);</a><a class="sourceLine" id="cb2-45" title="45">        <span class="dt">int</span> cur=rt;</a><a class="sourceLine" id="cb2-46" title="46">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;len;i++){</a><a class="sourceLine" id="cb2-47" title="47">            <span class="dt">char</span> ch=str[i];</a><a class="sourceLine" id="cb2-48" title="48">            <span class="cf">if</span>(next[cur][ch]==-<span class="dv">1</span>){</a><a class="sourceLine" id="cb2-49" title="49">                next[cur][ch]=newnode();</a><a class="sourceLine" id="cb2-50" title="50">            }</a><a class="sourceLine" id="cb2-51" title="51">            cur=next[cur][ch];</a><a class="sourceLine" id="cb2-52" title="52">        }</a><a class="sourceLine" id="cb2-53" title="53">        edstr[cur]=++scnt;</a><a class="sourceLine" id="cb2-54" title="54">    } </a><a class="sourceLine" id="cb2-55" title="55">    <span class="dt">void</span> build(){</a><a class="sourceLine" id="cb2-56" title="56">        fail[rt]=rt;</a><a class="sourceLine" id="cb2-57" title="57">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">128</span>;i++){</a><a class="sourceLine" id="cb2-58" title="58">            <span class="cf">if</span>(next[rt][i]==-<span class="dv">1</span>){</a><a class="sourceLine" id="cb2-59" title="59">                next[rt][i]=rt;</a><a class="sourceLine" id="cb2-60" title="60">            }<span class="cf">else</span>{</a><a class="sourceLine" id="cb2-61" title="61">                fail[next[rt][i]]=rt;</a><a class="sourceLine" id="cb2-62" title="62">                que.push(next[rt][i]);</a><a class="sourceLine" id="cb2-63" title="63">            }</a><a class="sourceLine" id="cb2-64" title="64">        }</a><a class="sourceLine" id="cb2-65" title="65">        <span class="cf">while</span>(!que.empty()){</a><a class="sourceLine" id="cb2-66" title="66">            <span class="dt">int</span> u=que.front();</a><a class="sourceLine" id="cb2-67" title="67">            que.pop();</a><a class="sourceLine" id="cb2-68" title="68">            <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">128</span>;i++){</a><a class="sourceLine" id="cb2-69" title="69">                <span class="cf">if</span>(next[u][i]==-<span class="dv">1</span>){</a><a class="sourceLine" id="cb2-70" title="70">                    next[u][i]=next[fail[u]][i];</a><a class="sourceLine" id="cb2-71" title="71">                }<span class="cf">else</span>{</a><a class="sourceLine" id="cb2-72" title="72">                    fail[next[u][i]]=next[fail[u]][i];</a><a class="sourceLine" id="cb2-73" title="73">                    que.push(next[u][i]);</a><a class="sourceLine" id="cb2-74" title="74">                }</a><a class="sourceLine" id="cb2-75" title="75">            }</a><a class="sourceLine" id="cb2-76" title="76">        }</a><a class="sourceLine" id="cb2-77" title="77">    }</a><a class="sourceLine" id="cb2-78" title="78">    <span class="dt">void</span> query(<span class="dt">char</span> str[]){</a><a class="sourceLine" id="cb2-79" title="79">        <span class="dt">int</span> len=strlen(str);</a><a class="sourceLine" id="cb2-80" title="80">        <span class="dt">int</span> now=rt;</a><a class="sourceLine" id="cb2-81" title="81">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;len;i++){</a><a class="sourceLine" id="cb2-82" title="82">            now=next[now][str[i]];</a><a class="sourceLine" id="cb2-83" title="83">            <span class="dt">int</span> tmp=now;</a><a class="sourceLine" id="cb2-84" title="84">            <span class="cf">while</span>(tmp!=rt){</a><a class="sourceLine" id="cb2-85" title="85">                <span class="cf">if</span>(edstr[tmp]!=<span class="dv">0</span>)</a><a class="sourceLine" id="cb2-86" title="86">                    ansvec.push_back(edstr[tmp]);</a><a class="sourceLine" id="cb2-87" title="87">                tmp=fail[tmp];</a><a class="sourceLine" id="cb2-88" title="88">            }</a><a class="sourceLine" id="cb2-89" title="89">        }</a><a class="sourceLine" id="cb2-90" title="90">    }</a><a class="sourceLine" id="cb2-91" title="91">    <span class="dt">void</span> show(){</a><a class="sourceLine" id="cb2-92" title="92">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">100</span>;i++){</a><a class="sourceLine" id="cb2-93" title="93">            cout&lt;&lt;<span class="st">"i = "</span>&lt;&lt;i&lt;&lt;<span class="st">" edstr[i] = "</span>&lt;&lt;edstr[i]&lt;&lt;<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>;</a><a class="sourceLine" id="cb2-94" title="94">        }</a><a class="sourceLine" id="cb2-95" title="95">    }</a><a class="sourceLine" id="cb2-96" title="96">};</a><a class="sourceLine" id="cb2-97" title="97">Trie acmaton;        <span class="co">//内部有大数组，需要开全局变量 </span></a><a class="sourceLine" id="cb2-98" title="98"><span class="dt">char</span> cha[<span class="dv">205</span>];</a><a class="sourceLine" id="cb2-99" title="99"><span class="dt">char</span> web[<span class="dv">10005</span>];</a><a class="sourceLine" id="cb2-100" title="100"><span class="dt">int</span> main()</a><a class="sourceLine" id="cb2-101" title="101">{</a><a class="sourceLine" id="cb2-102" title="102">    <span class="dt">int</span> n;</a><a class="sourceLine" id="cb2-103" title="103">    <span class="cf">while</span>(scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;n)!=EOF){</a><a class="sourceLine" id="cb2-104" title="104">        acmaton.init();</a><a class="sourceLine" id="cb2-105" title="105">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){</a><a class="sourceLine" id="cb2-106" title="106">            scanf(<span class="st">"</span><span class="sc">%s</span><span class="st">"</span>,cha);acmaton.<span class="va">insert_</span>(cha);</a><a class="sourceLine" id="cb2-107" title="107">        }</a><a class="sourceLine" id="cb2-108" title="108">        acmaton.build();</a><a class="sourceLine" id="cb2-109" title="109">        <span class="dt">int</span> m;scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>,&amp;m);</a><a class="sourceLine" id="cb2-110" title="110">        <span class="dt">int</span> webtot=<span class="dv">0</span>;</a><a class="sourceLine" id="cb2-111" title="111">        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++){</a><a class="sourceLine" id="cb2-112" title="112">            ansvec.clear();</a><a class="sourceLine" id="cb2-113" title="113">            scanf(<span class="st">"</span><span class="sc">%s</span><span class="st">"</span>,web);</a><a class="sourceLine" id="cb2-114" title="114">    <span class="co">//        printf("web: %s\n",web);</span></a><a class="sourceLine" id="cb2-115" title="115">            acmaton.query(web);</a><a class="sourceLine" id="cb2-116" title="116">            <span class="dt">int</span> cntt=ansvec.size();</a><a class="sourceLine" id="cb2-117" title="117">    <span class="co">//        debug;</span></a><a class="sourceLine" id="cb2-118" title="118">            <span class="cf">if</span>(cntt&gt;<span class="dv">0</span>){</a><a class="sourceLine" id="cb2-119" title="119">                sort(ansvec.begin(),ansvec.end());</a><a class="sourceLine" id="cb2-120" title="120">                webtot++;</a><a class="sourceLine" id="cb2-121" title="121">                printf(<span class="st">"web </span><span class="sc">%d</span><span class="st">: "</span>,i+<span class="dv">1</span>);</a><a class="sourceLine" id="cb2-122" title="122">                <span class="dt">int</span> sz=ansvec.size();</a><a class="sourceLine" id="cb2-123" title="123">                <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;sz;i++){</a><a class="sourceLine" id="cb2-124" title="124">                    <span class="cf">if</span>(i==sz-<span class="dv">1</span>)    printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>,ansvec[i]);</a><a class="sourceLine" id="cb2-125" title="125">                    <span class="cf">else</span> printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> "</span>,ansvec[i]);</a><a class="sourceLine" id="cb2-126" title="126">                }</a><a class="sourceLine" id="cb2-127" title="127">            }</a><a class="sourceLine" id="cb2-128" title="128">        }</a><a class="sourceLine" id="cb2-129" title="129">    <span class="co">//    cout&lt;&lt;"total: "&lt;&lt;webtot&lt;&lt;"\n";//</span></a><a class="sourceLine" id="cb2-130" title="130">        printf(<span class="st">"total: </span><span class="sc">%d\n</span><span class="st">"</span>,webtot);</a><a class="sourceLine" id="cb2-131" title="131">    }</a><a class="sourceLine" id="cb2-132" title="132">    <span class="cf">return</span> <span class="dv">0</span>;</a><a class="sourceLine" id="cb2-133" title="133">}</a></code></pre></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/H65722373b7674099b56790ec509eb5a8B.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/categories/ACM/"/>
    
    <category term="字符串" scheme="https://xtayex.gitee.io/categories/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="AC自动机" scheme="https://xtayex.gitee.io/categories/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
    <category term="ACM" scheme="https://xtayex.gitee.io/tags/ACM/"/>
    
    <category term="AC自动机" scheme="https://xtayex.gitee.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
</feed>
